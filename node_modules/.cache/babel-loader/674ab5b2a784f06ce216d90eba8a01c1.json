{"ast":null,"code":"function getIterator(e) {\n  if (\"function\" == typeof e.next) return e;\n  if (\"function\" == typeof e[Symbol.iterator]) return e[Symbol.iterator]();\n  if (\"function\" == typeof e[Symbol.asyncIterator]) return e[Symbol.asyncIterator]();\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\nfunction defer() {\n  let e, t;\n  return {\n    promise: new Promise((r, n) => {\n      t = r, e = n;\n    }),\n    reject: e,\n    resolve: t\n  };\n}\nfunction _transform(e, t, r) {\n  const n = getIterator(r),\n    o = [],\n    i = [];\n  let s = !1,\n    a = !1,\n    c = 0,\n    u = null;\n  function f() {\n    for (; i.length > 0 && o.length > 0;) {\n      const {\n        resolve: e\n      } = i.shift();\n      e({\n        done: !1,\n        value: o.shift()\n      });\n    }\n    for (; i.length > 0 && 0 === c && s;) {\n      const {\n        resolve: e,\n        reject: t\n      } = i.shift();\n      u ? (t(u), u = null) : e({\n        done: !0,\n        value: void 0\n      });\n    }\n  }\n  async function l() {\n    if (s) f();else if (!(a || c + o.length >= e)) {\n      a = !0, c++;\n      try {\n        const {\n          done: e,\n          value: r\n        } = await n.next();\n        e ? (s = !0, c--, f()) : async function (e) {\n          try {\n            const r = await t(e);\n            o.push(r);\n          } catch (e) {\n            s = !0, u = e;\n          }\n          c--, f(), l();\n        }(r);\n      } catch (e) {\n        s = !0, c--, u = e, f();\n      }\n      a = !1, l();\n    }\n  }\n  const h = {\n    next: async function () {\n      if (0 === o.length) {\n        const e = defer();\n        return i.push(e), l(), e.promise;\n      }\n      const e = o.shift();\n      return l(), {\n        done: !1,\n        value: e\n      };\n    },\n    [Symbol.asyncIterator]: () => h\n  };\n  return h;\n}\nfunction transform(e, t, r) {\n  return void 0 === t ? (t, r) => r ? transform(e, t, r) : transform(e, t) : void 0 === r ? r => transform(e, t, r) : _transform(e, t, r);\n}\nvar commonjsGlobal = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\nfunction getDefaultExportFromCjs(e) {\n  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nfunction getAugmentedNamespace(e) {\n  if (e.__esModule) return e;\n  var t = Object.defineProperty({}, \"__esModule\", {\n    value: !0\n  });\n  return Object.keys(e).forEach(function (r) {\n    var n = Object.getOwnPropertyDescriptor(e, r);\n    Object.defineProperty(t, r, n.get ? n : {\n      enumerable: !0,\n      get: function () {\n        return e[r];\n      }\n    });\n  }), t;\n}\nvar pRetry$2 = {\n    exports: {}\n  },\n  retry$2 = {};\nfunction RetryOperation(e, t) {\n  \"boolean\" == typeof t && (t = {\n    forever: t\n  }), this._originalTimeouts = JSON.parse(JSON.stringify(e)), this._timeouts = e, this._options = t || {}, this._maxRetryTime = t && t.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._timer = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));\n}\nvar retry_operation = RetryOperation;\nRetryOperation.prototype.reset = function () {\n  this._attempts = 1, this._timeouts = this._originalTimeouts.slice(0);\n}, RetryOperation.prototype.stop = function () {\n  this._timeout && clearTimeout(this._timeout), this._timer && clearTimeout(this._timer), this._timeouts = [], this._cachedTimeouts = null;\n}, RetryOperation.prototype.retry = function (e) {\n  if (this._timeout && clearTimeout(this._timeout), !e) return !1;\n  var t = new Date().getTime();\n  if (e && t - this._operationStart >= this._maxRetryTime) return this._errors.push(e), this._errors.unshift(new Error(\"RetryOperation timeout occurred\")), !1;\n  this._errors.push(e);\n  var r = this._timeouts.shift();\n  if (void 0 === r) {\n    if (!this._cachedTimeouts) return !1;\n    this._errors.splice(0, this._errors.length - 1), r = this._cachedTimeouts.slice(-1);\n  }\n  var n = this;\n  return this._timer = setTimeout(function () {\n    n._attempts++, n._operationTimeoutCb && (n._timeout = setTimeout(function () {\n      n._operationTimeoutCb(n._attempts);\n    }, n._operationTimeout), n._options.unref && n._timeout.unref()), n._fn(n._attempts);\n  }, r), this._options.unref && this._timer.unref(), !0;\n}, RetryOperation.prototype.attempt = function (e, t) {\n  this._fn = e, t && (t.timeout && (this._operationTimeout = t.timeout), t.cb && (this._operationTimeoutCb = t.cb));\n  var r = this;\n  this._operationTimeoutCb && (this._timeout = setTimeout(function () {\n    r._operationTimeoutCb();\n  }, r._operationTimeout)), this._operationStart = new Date().getTime(), this._fn(this._attempts);\n}, RetryOperation.prototype.try = function (e) {\n  console.log(\"Using RetryOperation.try() is deprecated\"), this.attempt(e);\n}, RetryOperation.prototype.start = function (e) {\n  console.log(\"Using RetryOperation.start() is deprecated\"), this.attempt(e);\n}, RetryOperation.prototype.start = RetryOperation.prototype.try, RetryOperation.prototype.errors = function () {\n  return this._errors;\n}, RetryOperation.prototype.attempts = function () {\n  return this._attempts;\n}, RetryOperation.prototype.mainError = function () {\n  if (0 === this._errors.length) return null;\n  for (var e = {}, t = null, r = 0, n = 0; n < this._errors.length; n++) {\n    var o = this._errors[n],\n      i = o.message,\n      s = (e[i] || 0) + 1;\n    e[i] = s, s >= r && (t = o, r = s);\n  }\n  return t;\n}, function (e) {\n  var t = retry_operation;\n  e.operation = function (r) {\n    var n = e.timeouts(r);\n    return new t(n, {\n      forever: r && (r.forever || r.retries === 1 / 0),\n      unref: r && r.unref,\n      maxRetryTime: r && r.maxRetryTime\n    });\n  }, e.timeouts = function (e) {\n    if (e instanceof Array) return [].concat(e);\n    var t = {\n      retries: 10,\n      factor: 2,\n      minTimeout: 1e3,\n      maxTimeout: 1 / 0,\n      randomize: !1\n    };\n    for (var r in e) t[r] = e[r];\n    if (t.minTimeout > t.maxTimeout) throw new Error(\"minTimeout is greater than maxTimeout\");\n    for (var n = [], o = 0; o < t.retries; o++) n.push(this.createTimeout(o, t));\n    return e && e.forever && !n.length && n.push(this.createTimeout(o, t)), n.sort(function (e, t) {\n      return e - t;\n    }), n;\n  }, e.createTimeout = function (e, t) {\n    var r = t.randomize ? Math.random() + 1 : 1,\n      n = Math.round(r * Math.max(t.minTimeout, 1) * Math.pow(t.factor, e));\n    return n = Math.min(n, t.maxTimeout);\n  }, e.wrap = function (t, r, n) {\n    if (r instanceof Array && (n = r, r = null), !n) for (var o in n = [], t) \"function\" == typeof t[o] && n.push(o);\n    for (var i = 0; i < n.length; i++) {\n      var s = n[i],\n        a = t[s];\n      t[s] = function (n) {\n        var o = e.operation(r),\n          i = Array.prototype.slice.call(arguments, 1),\n          s = i.pop();\n        i.push(function (e) {\n          o.retry(e) || (e && (arguments[0] = o.mainError()), s.apply(this, arguments));\n        }), o.attempt(function () {\n          n.apply(t, i);\n        });\n      }.bind(t, a), t[s].options = r;\n    }\n  };\n}(retry$2);\nvar retry$1 = retry$2;\nconst retry = retry$1,\n  networkErrorMsgs = [\"Failed to fetch\", \"NetworkError when attempting to fetch resource.\", \"The Internet connection appears to be offline.\", \"Network request failed\"];\nclass AbortError extends Error {\n  constructor(e) {\n    super(), e instanceof Error ? (this.originalError = e, ({\n      message: e\n    } = e)) : (this.originalError = new Error(e), this.originalError.stack = this.stack), this.name = \"AbortError\", this.message = e;\n  }\n}\nconst decorateErrorWithCounts = (e, t, r) => {\n    const n = r.retries - (t - 1);\n    return e.attemptNumber = t, e.retriesLeft = n, e;\n  },\n  isNetworkError = e => networkErrorMsgs.includes(e),\n  pRetry = (e, t) => new Promise((r, n) => {\n    t = {\n      onFailedAttempt: () => {},\n      retries: 10,\n      ...t\n    };\n    const o = retry.operation(t);\n    o.attempt(async i => {\n      try {\n        r(await e(i));\n      } catch (e) {\n        if (!(e instanceof Error)) return void n(new TypeError(`Non-error was thrown: \"${e}\". You should only throw errors.`));\n        if (e instanceof AbortError) o.stop(), n(e.originalError);else if (e instanceof TypeError && !isNetworkError(e.message)) o.stop(), n(e);else {\n          decorateErrorWithCounts(e, i, t);\n          try {\n            await t.onFailedAttempt(e);\n          } catch (e) {\n            return void n(e);\n          }\n          o.retry(e) || n(o.mainError());\n        }\n      }\n    });\n  });\npRetry$2.exports = pRetry, pRetry$2.exports.default = pRetry;\nvar AbortError_1 = pRetry$2.exports.AbortError = AbortError,\n  pRetry$1 = pRetry$2.exports,\n  encode_1$1 = encode$a,\n  MSB$3 = 128,\n  REST$3 = 127,\n  MSBALL$1 = ~REST$3,\n  INT$1 = Math.pow(2, 31);\nfunction encode$a(e, t, r) {\n  if (Number.MAX_SAFE_INTEGER && e > Number.MAX_SAFE_INTEGER) throw encode$a.bytes = 0, new RangeError(\"Could not encode varint\");\n  t = t || [];\n  for (var n = r = r || 0; e >= INT$1;) t[r++] = 255 & e | MSB$3, e /= 128;\n  for (; e & MSBALL$1;) t[r++] = 255 & e | MSB$3, e >>>= 7;\n  return t[r] = 0 | e, encode$a.bytes = r - n + 1, t;\n}\nvar decode$b = read$1,\n  MSB$2 = 128,\n  REST$2 = 127;\nfunction read$1(e, t) {\n  var r,\n    n = 0,\n    o = 0,\n    i = t = t || 0,\n    s = e.length;\n  do {\n    if (i >= s || o > 49) throw read$1.bytes = 0, new RangeError(\"Could not decode varint\");\n    r = e[i++], n += o < 28 ? (r & REST$2) << o : (r & REST$2) * Math.pow(2, o), o += 7;\n  } while (r >= MSB$2);\n  return read$1.bytes = i - t, n;\n}\nvar N1$1 = Math.pow(2, 7),\n  N2$1 = Math.pow(2, 14),\n  N3$1 = Math.pow(2, 21),\n  N4$1 = Math.pow(2, 28),\n  N5$1 = Math.pow(2, 35),\n  N6$1 = Math.pow(2, 42),\n  N7$1 = Math.pow(2, 49),\n  N8$1 = Math.pow(2, 56),\n  N9$1 = Math.pow(2, 63),\n  length$1 = function (e) {\n    return e < N1$1 ? 1 : e < N2$1 ? 2 : e < N3$1 ? 3 : e < N4$1 ? 4 : e < N5$1 ? 5 : e < N6$1 ? 6 : e < N7$1 ? 7 : e < N8$1 ? 8 : e < N9$1 ? 9 : 10;\n  },\n  varint$1 = {\n    encode: encode_1$1,\n    decode: decode$b,\n    encodingLength: length$1\n  },\n  encode_1 = encode$9,\n  MSB = 128,\n  REST = 127,\n  MSBALL = ~REST,\n  INT = Math.pow(2, 31);\nfunction encode$9(e, t, r) {\n  t = t || [];\n  for (var n = r = r || 0; e >= INT;) t[r++] = 255 & e | MSB, e /= 128;\n  for (; e & MSBALL;) t[r++] = 255 & e | MSB, e >>>= 7;\n  return t[r] = 0 | e, encode$9.bytes = r - n + 1, t;\n}\nvar decode$a = read,\n  MSB$1 = 128,\n  REST$1 = 127;\nfunction read(e, t) {\n  var r,\n    n = 0,\n    o = 0,\n    i = t = t || 0,\n    s = e.length;\n  do {\n    if (i >= s) throw read.bytes = 0, new RangeError(\"Could not decode varint\");\n    r = e[i++], n += o < 28 ? (r & REST$1) << o : (r & REST$1) * Math.pow(2, o), o += 7;\n  } while (r >= MSB$1);\n  return read.bytes = i - t, n;\n}\nvar N1 = Math.pow(2, 7),\n  N2 = Math.pow(2, 14),\n  N3 = Math.pow(2, 21),\n  N4 = Math.pow(2, 28),\n  N5 = Math.pow(2, 35),\n  N6 = Math.pow(2, 42),\n  N7 = Math.pow(2, 49),\n  N8 = Math.pow(2, 56),\n  N9 = Math.pow(2, 63),\n  length = function (e) {\n    return e < N1 ? 1 : e < N2 ? 2 : e < N3 ? 3 : e < N4 ? 4 : e < N5 ? 5 : e < N6 ? 6 : e < N7 ? 7 : e < N8 ? 8 : e < N9 ? 9 : 10;\n  },\n  varint = {\n    encode: encode_1,\n    decode: decode$a,\n    encodingLength: length\n  },\n  _brrp_varint = varint;\nconst decode$9 = e => [_brrp_varint.decode(e), _brrp_varint.decode.bytes],\n  encodeTo = function (e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    return _brrp_varint.encode(e, t, r), t;\n  },\n  encodingLength = e => _brrp_varint.encodingLength(e),\n  empty = new Uint8Array(0),\n  fromHex = e => {\n    const t = e.match(/../g);\n    return t ? new Uint8Array(t.map(e => parseInt(e, 16))) : empty;\n  },\n  equals$1 = (e, t) => {\n    if (e === t) return !0;\n    if (e.byteLength !== t.byteLength) return !1;\n    for (let r = 0; r < e.byteLength; r++) if (e[r] !== t[r]) return !1;\n    return !0;\n  },\n  coerce = e => {\n    if (e instanceof Uint8Array && \"Uint8Array\" === e.constructor.name) return e;\n    if (e instanceof ArrayBuffer) return new Uint8Array(e);\n    if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n    throw new Error(\"Unknown type, must be binary type\");\n  },\n  fromString$3 = e => new TextEncoder().encode(e),\n  toString$1 = e => new TextDecoder().decode(e),\n  create$4 = (e, t) => {\n    const r = t.byteLength,\n      n = encodingLength(e),\n      o = n + encodingLength(r),\n      i = new Uint8Array(o + r);\n    return encodeTo(e, i, 0), encodeTo(r, i, n), i.set(t, o), new Digest(e, r, t, i);\n  },\n  decode$8 = e => {\n    const t = coerce(e),\n      [r, n] = decode$9(t),\n      [o, i] = decode$9(t.subarray(n)),\n      s = t.subarray(n + i);\n    if (s.byteLength !== o) throw new Error(\"Incorrect length\");\n    return new Digest(r, o, s, t);\n  },\n  equals = (e, t) => e === t || e.code === t.code && e.size === t.size && equals$1(e.bytes, t.bytes);\nclass Digest {\n  constructor(e, t, r, n) {\n    this.code = e, this.size = t, this.digest = r, this.bytes = n;\n  }\n}\nfunction base(e, t) {\n  if (e.length >= 255) throw new TypeError(\"Alphabet too long\");\n  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;\n  for (var o = 0; o < e.length; o++) {\n    var i = e.charAt(o),\n      s = i.charCodeAt(0);\n    if (255 !== r[s]) throw new TypeError(i + \" is ambiguous\");\n    r[s] = o;\n  }\n  var a = e.length,\n    c = e.charAt(0),\n    u = Math.log(a) / Math.log(256),\n    f = Math.log(256) / Math.log(a);\n  function l(e) {\n    if (\"string\" != typeof e) throw new TypeError(\"Expected String\");\n    if (0 === e.length) return new Uint8Array();\n    var t = 0;\n    if (\" \" !== e[t]) {\n      for (var n = 0, o = 0; e[t] === c;) n++, t++;\n      for (var i = (e.length - t) * u + 1 >>> 0, s = new Uint8Array(i); e[t];) {\n        var f = r[e.charCodeAt(t)];\n        if (255 === f) return;\n        for (var l = 0, h = i - 1; (0 !== f || l < o) && -1 !== h; h--, l++) f += a * s[h] >>> 0, s[h] = f % 256 >>> 0, f = f / 256 >>> 0;\n        if (0 !== f) throw new Error(\"Non-zero carry\");\n        o = l, t++;\n      }\n      if (\" \" !== e[t]) {\n        for (var d = i - o; d !== i && 0 === s[d];) d++;\n        for (var p = new Uint8Array(n + (i - d)), y = n; d !== i;) p[y++] = s[d++];\n        return p;\n      }\n    }\n  }\n  return {\n    encode: function (t) {\n      if (t instanceof Uint8Array || (ArrayBuffer.isView(t) ? t = new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : Array.isArray(t) && (t = Uint8Array.from(t))), !(t instanceof Uint8Array)) throw new TypeError(\"Expected Uint8Array\");\n      if (0 === t.length) return \"\";\n      for (var r = 0, n = 0, o = 0, i = t.length; o !== i && 0 === t[o];) o++, r++;\n      for (var s = (i - o) * f + 1 >>> 0, u = new Uint8Array(s); o !== i;) {\n        for (var l = t[o], h = 0, d = s - 1; (0 !== l || h < n) && -1 !== d; d--, h++) l += 256 * u[d] >>> 0, u[d] = l % a >>> 0, l = l / a >>> 0;\n        if (0 !== l) throw new Error(\"Non-zero carry\");\n        n = h, o++;\n      }\n      for (var p = s - n; p !== s && 0 === u[p];) p++;\n      for (var y = c.repeat(r); p < s; ++p) y += e.charAt(u[p]);\n      return y;\n    },\n    decodeUnsafe: l,\n    decode: function (e) {\n      var r = l(e);\n      if (r) return r;\n      throw new Error(`Non-${t} character`);\n    }\n  };\n}\nvar src$2 = base,\n  _brrp__multiformats_scope_baseX = src$2;\nclass Encoder {\n  constructor(e, t, r) {\n    this.name = e, this.prefix = t, this.baseEncode = r;\n  }\n  encode(e) {\n    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nclass Decoder {\n  constructor(e, t, r) {\n    if (this.name = e, this.prefix = t, void 0 === t.codePointAt(0)) throw new Error(\"Invalid prefix character\");\n    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = r;\n  }\n  decode(e) {\n    if (\"string\" == typeof e) {\n      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      return this.baseDecode(e.slice(this.prefix.length));\n    }\n    throw Error(\"Can only multibase decode strings\");\n  }\n  or(e) {\n    return or(this, e);\n  }\n}\nclass ComposedDecoder {\n  constructor(e) {\n    this.decoders = e;\n  }\n  or(e) {\n    return or(this, e);\n  }\n  decode(e) {\n    const t = e[0],\n      r = this.decoders[t];\n    if (r) return r.decode(e);\n    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n  }\n}\nconst or = (e, t) => new ComposedDecoder({\n  ...(e.decoders || {\n    [e.prefix]: e\n  }),\n  ...(t.decoders || {\n    [t.prefix]: t\n  })\n});\nclass Codec {\n  constructor(e, t, r, n) {\n    this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = n, this.encoder = new Encoder(e, t, r), this.decoder = new Decoder(e, t, n);\n  }\n  encode(e) {\n    return this.encoder.encode(e);\n  }\n  decode(e) {\n    return this.decoder.decode(e);\n  }\n}\nconst from$1 = _ref => {\n    let {\n      name: e,\n      prefix: t,\n      encode: r,\n      decode: n\n    } = _ref;\n    return new Codec(e, t, r, n);\n  },\n  baseX = _ref2 => {\n    let {\n      prefix: e,\n      name: t,\n      alphabet: r\n    } = _ref2;\n    const {\n      encode: n,\n      decode: o\n    } = _brrp__multiformats_scope_baseX(r, t);\n    return from$1({\n      prefix: e,\n      name: t,\n      encode: n,\n      decode: e => coerce(o(e))\n    });\n  },\n  decode$7 = (e, t, r, n) => {\n    const o = {};\n    for (let e = 0; e < t.length; ++e) o[t[e]] = e;\n    let i = e.length;\n    for (; \"=\" === e[i - 1];) --i;\n    const s = new Uint8Array(i * r / 8 | 0);\n    let a = 0,\n      c = 0,\n      u = 0;\n    for (let t = 0; t < i; ++t) {\n      const i = o[e[t]];\n      if (void 0 === i) throw new SyntaxError(`Non-${n} character`);\n      c = c << r | i, a += r, a >= 8 && (a -= 8, s[u++] = 255 & c >> a);\n    }\n    if (a >= r || 255 & c << 8 - a) throw new SyntaxError(\"Unexpected end of data\");\n    return s;\n  },\n  encode$8 = (e, t, r) => {\n    const n = \"=\" === t[t.length - 1],\n      o = (1 << r) - 1;\n    let i = \"\",\n      s = 0,\n      a = 0;\n    for (let n = 0; n < e.length; ++n) for (a = a << 8 | e[n], s += 8; s > r;) s -= r, i += t[o & a >> s];\n    if (s && (i += t[o & a << r - s]), n) for (; i.length * r & 7;) i += \"=\";\n    return i;\n  },\n  rfc4648 = _ref3 => {\n    let {\n      name: e,\n      prefix: t,\n      bitsPerChar: r,\n      alphabet: n\n    } = _ref3;\n    return from$1({\n      prefix: t,\n      name: e,\n      encode: e => encode$8(e, n, r),\n      decode: t => decode$7(t, n, r, e)\n    });\n  },\n  base58btc = baseX({\n    name: \"base58btc\",\n    prefix: \"z\",\n    alphabet: \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  }),\n  base58flickr = baseX({\n    name: \"base58flickr\",\n    prefix: \"Z\",\n    alphabet: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n  });\nvar base58 = Object.freeze({\n  __proto__: null,\n  base58btc: base58btc,\n  base58flickr: base58flickr\n});\nconst base32 = rfc4648({\n    prefix: \"b\",\n    name: \"base32\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567\",\n    bitsPerChar: 5\n  }),\n  base32upper = rfc4648({\n    prefix: \"B\",\n    name: \"base32upper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n    bitsPerChar: 5\n  }),\n  base32pad = rfc4648({\n    prefix: \"c\",\n    name: \"base32pad\",\n    alphabet: \"abcdefghijklmnopqrstuvwxyz234567=\",\n    bitsPerChar: 5\n  }),\n  base32padupper = rfc4648({\n    prefix: \"C\",\n    name: \"base32padupper\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=\",\n    bitsPerChar: 5\n  }),\n  base32hex = rfc4648({\n    prefix: \"v\",\n    name: \"base32hex\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv\",\n    bitsPerChar: 5\n  }),\n  base32hexupper = rfc4648({\n    prefix: \"V\",\n    name: \"base32hexupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n    bitsPerChar: 5\n  }),\n  base32hexpad = rfc4648({\n    prefix: \"t\",\n    name: \"base32hexpad\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuv=\",\n    bitsPerChar: 5\n  }),\n  base32hexpadupper = rfc4648({\n    prefix: \"T\",\n    name: \"base32hexpadupper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV=\",\n    bitsPerChar: 5\n  }),\n  base32z = rfc4648({\n    prefix: \"h\",\n    name: \"base32z\",\n    alphabet: \"ybndrfg8ejkmcpqxot1uwisza345h769\",\n    bitsPerChar: 5\n  });\nvar base32$1 = Object.freeze({\n  __proto__: null,\n  base32: base32,\n  base32upper: base32upper,\n  base32pad: base32pad,\n  base32padupper: base32padupper,\n  base32hex: base32hex,\n  base32hexupper: base32hexupper,\n  base32hexpad: base32hexpad,\n  base32hexpadupper: base32hexpadupper,\n  base32z: base32z\n});\nclass CID {\n  constructor(e, t, r, n) {\n    this.code = t, this.version = e, this.multihash = r, this.bytes = n, this.byteOffset = n.byteOffset, this.byteLength = n.byteLength, this.asCID = this, this._baseCache = new Map(), Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly$1,\n      version: readonly$1,\n      multihash: readonly$1,\n      bytes: readonly$1,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    if (0 === this.version) return this;\n    {\n      const {\n        code: e,\n        multihash: t\n      } = this;\n      if (e !== DAG_PB_CODE) throw new Error(\"Cannot convert a non dag-pb CID to CIDv0\");\n      if (t.code !== SHA_256_CODE) throw new Error(\"Cannot convert non sha2-256 multihash CID to CIDv0\");\n      return CID.createV0(t);\n    }\n  }\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n              code: e,\n              digest: t\n            } = this.multihash,\n            r = create$4(e, t);\n          return CID.createV1(this.code, r);\n        }\n      case 1:\n        return this;\n      default:\n        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n    }\n  }\n  equals(e) {\n    return e && this.code === e.code && this.version === e.version && equals(this.multihash, e.multihash);\n  }\n  toString(e) {\n    const {\n      bytes: t,\n      version: r,\n      _baseCache: n\n    } = this;\n    return 0 === r ? toStringV0(t, n, e || base58btc.encoder) : toStringV1(t, n, e || base32.encoder);\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return \"CID\";\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return \"CID(\" + this.toString() + \")\";\n  }\n  static isCID(e) {\n    return deprecate(/^0\\.0/, IS_CID_DEPRECATION), !(!e || !e[cidSymbol] && e.asCID !== e);\n  }\n  get toBaseEncodedString() {\n    throw new Error(\"Deprecated, use .toString()\");\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error(\"Deprecated .buffer property, use .bytes to get Uint8Array instead\");\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(e) {\n    if (e instanceof CID) return e;\n    if (null != e && e.asCID === e) {\n      const {\n        version: t,\n        code: r,\n        multihash: n,\n        bytes: o\n      } = e;\n      return new CID(t, r, n, o || encodeCID(t, r, n.bytes));\n    }\n    if (null != e && !0 === e[cidSymbol]) {\n      const {\n          version: t,\n          multihash: r,\n          code: n\n        } = e,\n        o = decode$8(r);\n      return CID.create(t, n, o);\n    }\n    return null;\n  }\n  static create(e, t, r) {\n    if (\"number\" != typeof t) throw new Error(\"String codecs are no longer supported\");\n    switch (e) {\n      case 0:\n        if (t !== DAG_PB_CODE) throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n        return new CID(e, t, r, r.bytes);\n      case 1:\n        {\n          const n = encodeCID(e, t, r.bytes);\n          return new CID(e, t, r, n);\n        }\n      default:\n        throw new Error(\"Invalid version\");\n    }\n  }\n  static createV0(e) {\n    return CID.create(0, DAG_PB_CODE, e);\n  }\n  static createV1(e, t) {\n    return CID.create(1, e, t);\n  }\n  static decode(e) {\n    const [t, r] = CID.decodeFirst(e);\n    if (r.length) throw new Error(\"Incorrect length\");\n    return t;\n  }\n  static decodeFirst(e) {\n    const t = CID.inspectBytes(e),\n      r = t.size - t.multihashSize,\n      n = coerce(e.subarray(r, r + t.multihashSize));\n    if (n.byteLength !== t.multihashSize) throw new Error(\"Incorrect length\");\n    const o = n.subarray(t.multihashSize - t.digestSize),\n      i = new Digest(t.multihashCode, t.digestSize, o, n);\n    return [0 === t.version ? CID.createV0(i) : CID.createV1(t.codec, i), e.subarray(t.size)];\n  }\n  static inspectBytes(e) {\n    let t = 0;\n    const r = () => {\n      const [r, n] = decode$9(e.subarray(t));\n      return t += n, r;\n    };\n    let n = r(),\n      o = DAG_PB_CODE;\n    if (18 === n ? (n = 0, t = 0) : 1 === n && (o = r()), 0 !== n && 1 !== n) throw new RangeError(`Invalid CID version ${n}`);\n    const i = t,\n      s = r(),\n      a = r(),\n      c = t + a;\n    return {\n      version: n,\n      codec: o,\n      multihashCode: s,\n      digestSize: a,\n      multihashSize: c - i,\n      size: c\n    };\n  }\n  static parse(e, t) {\n    const [r, n] = parseCIDtoBytes(e, t),\n      o = CID.decode(n);\n    return o._baseCache.set(r, e), o;\n  }\n}\nconst parseCIDtoBytes = (e, t) => {\n    switch (e[0]) {\n      case \"Q\":\n        {\n          const r = t || base58btc;\n          return [base58btc.prefix, r.decode(`${base58btc.prefix}${e}`)];\n        }\n      case base58btc.prefix:\n        {\n          const r = t || base58btc;\n          return [base58btc.prefix, r.decode(e)];\n        }\n      case base32.prefix:\n        {\n          const r = t || base32;\n          return [base32.prefix, r.decode(e)];\n        }\n      default:\n        if (null == t) throw Error(\"To parse non base32 or base58btc encoded CID multibase decoder must be provided\");\n        return [e[0], t.decode(e)];\n    }\n  },\n  toStringV0 = (e, t, r) => {\n    const {\n      prefix: n\n    } = r;\n    if (n !== base58btc.prefix) throw Error(`Cannot string encode V0 in ${r.name} encoding`);\n    const o = t.get(n);\n    if (null == o) {\n      const o = r.encode(e).slice(1);\n      return t.set(n, o), o;\n    }\n    return o;\n  },\n  toStringV1 = (e, t, r) => {\n    const {\n        prefix: n\n      } = r,\n      o = t.get(n);\n    if (null == o) {\n      const o = r.encode(e);\n      return t.set(n, o), o;\n    }\n    return o;\n  },\n  DAG_PB_CODE = 112,\n  SHA_256_CODE = 18,\n  encodeCID = (e, t, r) => {\n    const n = encodingLength(e),\n      o = n + encodingLength(t),\n      i = new Uint8Array(o + r.byteLength);\n    return encodeTo(e, i, 0), encodeTo(t, i, n), i.set(r, o), i;\n  },\n  cidSymbol = Symbol.for(\"@ipld/js-cid/CID\"),\n  readonly$1 = {\n    writable: !1,\n    configurable: !1,\n    enumerable: !0\n  },\n  hidden = {\n    writable: !1,\n    enumerable: !1,\n    configurable: !1\n  },\n  version = \"0.0.0-dev\",\n  deprecate = (e, t) => {\n    if (!e.test(version)) throw new Error(t);\n    console.warn(t);\n  },\n  IS_CID_DEPRECATION = \"CID.isCID(v) is deprecated and will be removed in the next major release.\\nFollowing code pattern:\\n\\nif (CID.isCID(value)) {\\n  doSomethingWithCID(value)\\n}\\n\\nIs replaced with:\\n\\nconst cid = CID.asCID(value)\\nif (cid) {\\n  // Make sure to use cid instead of value\\n  doSomethingWithCID(cid)\\n}\\n\",\n  typeofs = [\"string\", \"number\", \"bigint\", \"symbol\"],\n  objectTypeNames = [\"Function\", \"Generator\", \"AsyncGenerator\", \"GeneratorFunction\", \"AsyncGeneratorFunction\", \"AsyncFunction\", \"Observable\", \"Array\", \"Buffer\", \"Object\", \"RegExp\", \"Date\", \"Error\", \"Map\", \"Set\", \"WeakMap\", \"WeakSet\", \"ArrayBuffer\", \"SharedArrayBuffer\", \"DataView\", \"Promise\", \"URL\", \"HTMLElement\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\", \"BigInt64Array\", \"BigUint64Array\"];\nfunction is(e) {\n  if (null === e) return \"null\";\n  if (void 0 === e) return \"undefined\";\n  if (!0 === e || !1 === e) return \"boolean\";\n  const t = typeof e;\n  if (typeofs.includes(t)) return t;\n  if (\"function\" === t) return \"Function\";\n  if (Array.isArray(e)) return \"Array\";\n  if (isBuffer$1(e)) return \"Buffer\";\n  const r = getObjectType(e);\n  return r || \"Object\";\n}\nfunction isBuffer$1(e) {\n  return e && e.constructor && e.constructor.isBuffer && e.constructor.isBuffer.call(null, e);\n}\nfunction getObjectType(e) {\n  const t = Object.prototype.toString.call(e).slice(8, -1);\n  if (objectTypeNames.includes(t)) return t;\n}\nclass Type {\n  constructor(e, t, r) {\n    this.major = e, this.majorEncoded = e << 5, this.name = t, this.terminal = r;\n  }\n  toString() {\n    return `Type[${this.major}].${this.name}`;\n  }\n  compare(e) {\n    return this.major < e.major ? -1 : this.major > e.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, \"uint\", !0), Type.negint = new Type(1, \"negint\", !0), Type.bytes = new Type(2, \"bytes\", !0), Type.string = new Type(3, \"string\", !0), Type.array = new Type(4, \"array\", !1), Type.map = new Type(5, \"map\", !1), Type.tag = new Type(6, \"tag\", !1), Type.float = new Type(7, \"float\", !0), Type.false = new Type(7, \"false\", !0), Type.true = new Type(7, \"true\", !0), Type.null = new Type(7, \"null\", !0), Type.undefined = new Type(7, \"undefined\", !0), Type.break = new Type(7, \"break\", !0);\nclass Token$1 {\n  constructor(e, t, r) {\n    this.type = e, this.value = t, this.encodedLength = r, this.encodedBytes = void 0, this.byteValue = void 0;\n  }\n  toString() {\n    return `Token[${this.type}].${this.value}`;\n  }\n}\nconst useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && \"function\" == typeof globalThis.Buffer.isBuffer,\n  textDecoder$1 = new TextDecoder(),\n  textEncoder$2 = new TextEncoder();\nfunction isBuffer(e) {\n  return useBuffer && globalThis.Buffer.isBuffer(e);\n}\nfunction asU8A(e) {\n  return e instanceof Uint8Array ? isBuffer(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e : Uint8Array.from(e);\n}\nconst toString = useBuffer ? (e, t, r) => r - t > 64 ? globalThis.Buffer.from(e.subarray(t, r)).toString(\"utf8\") : utf8Slice(e, t, r) : (e, t, r) => r - t > 64 ? textDecoder$1.decode(e.subarray(t, r)) : utf8Slice(e, t, r),\n  fromString$2 = useBuffer ? e => e.length > 64 ? globalThis.Buffer.from(e) : utf8ToBytes(e) : e => e.length > 64 ? textEncoder$2.encode(e) : utf8ToBytes(e),\n  fromArray = e => Uint8Array.from(e),\n  slice = useBuffer ? (e, t, r) => isBuffer(e) ? new Uint8Array(e.subarray(t, r)) : e.slice(t, r) : (e, t, r) => e.slice(t, r),\n  concat$2 = useBuffer ? (e, t) => (e = e.map(e => e instanceof Uint8Array ? e : globalThis.Buffer.from(e)), asU8A(globalThis.Buffer.concat(e, t))) : (e, t) => {\n    const r = new Uint8Array(t);\n    let n = 0;\n    for (let t of e) n + t.length > r.length && (t = t.subarray(0, r.length - n)), r.set(t, n), n += t.length;\n    return r;\n  },\n  alloc = useBuffer ? e => globalThis.Buffer.allocUnsafe(e) : e => new Uint8Array(e);\nfunction compare(e, t) {\n  if (isBuffer(e) && isBuffer(t)) return e.compare(t);\n  for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return e[r] < t[r] ? -1 : 1;\n  return 0;\n}\nfunction utf8ToBytes(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1 / 0;\n  let r;\n  const n = e.length;\n  let o = null;\n  const i = [];\n  for (let s = 0; s < n; ++s) {\n    if (r = e.charCodeAt(s), r > 55295 && r < 57344) {\n      if (!o) {\n        if (r > 56319) {\n          (t -= 3) > -1 && i.push(239, 191, 189);\n          continue;\n        }\n        if (s + 1 === n) {\n          (t -= 3) > -1 && i.push(239, 191, 189);\n          continue;\n        }\n        o = r;\n        continue;\n      }\n      if (r < 56320) {\n        (t -= 3) > -1 && i.push(239, 191, 189), o = r;\n        continue;\n      }\n      r = 65536 + (o - 55296 << 10 | r - 56320);\n    } else o && (t -= 3) > -1 && i.push(239, 191, 189);\n    if (o = null, r < 128) {\n      if ((t -= 1) < 0) break;\n      i.push(r);\n    } else if (r < 2048) {\n      if ((t -= 2) < 0) break;\n      i.push(r >> 6 | 192, 63 & r | 128);\n    } else if (r < 65536) {\n      if ((t -= 3) < 0) break;\n      i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);\n    } else {\n      if (!(r < 1114112)) throw new Error(\"Invalid code point\");\n      if ((t -= 4) < 0) break;\n      i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);\n    }\n  }\n  return i;\n}\nfunction utf8Slice(e, t, r) {\n  const n = [];\n  for (; t < r;) {\n    const o = e[t];\n    let i = null,\n      s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;\n    if (t + s <= r) {\n      let r, n, a, c;\n      switch (s) {\n        case 1:\n          o < 128 && (i = o);\n          break;\n        case 2:\n          r = e[t + 1], 128 == (192 & r) && (c = (31 & o) << 6 | 63 & r, c > 127 && (i = c));\n          break;\n        case 3:\n          r = e[t + 1], n = e[t + 2], 128 == (192 & r) && 128 == (192 & n) && (c = (15 & o) << 12 | (63 & r) << 6 | 63 & n, c > 2047 && (c < 55296 || c > 57343) && (i = c));\n          break;\n        case 4:\n          r = e[t + 1], n = e[t + 2], a = e[t + 3], 128 == (192 & r) && 128 == (192 & n) && 128 == (192 & a) && (c = (15 & o) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a, c > 65535 && c < 1114112 && (i = c));\n      }\n    }\n    null === i ? (i = 65533, s = 1) : i > 65535 && (i -= 65536, n.push(i >>> 10 & 1023 | 55296), i = 56320 | 1023 & i), n.push(i), t += s;\n  }\n  return decodeCodePointsArray(n);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nfunction decodeCodePointsArray(e) {\n  const t = e.length;\n  if (t <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, e);\n  let r = \"\",\n    n = 0;\n  for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += MAX_ARGUMENTS_LENGTH));\n  return r;\n}\nconst defaultChunkSize = 256;\nclass Bl {\n  constructor() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultChunkSize;\n    this.chunkSize = e, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), null !== this._initReuseChunk && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);\n  }\n  push(e) {\n    let t = this.chunks[this.chunks.length - 1];\n    if (this.cursor + e.length <= this.maxCursor + 1) {\n      const r = t.length - (this.maxCursor - this.cursor) - 1;\n      t.set(e, r);\n    } else {\n      if (t) {\n        const e = t.length - (this.maxCursor - this.cursor) - 1;\n        e < t.length && (this.chunks[this.chunks.length - 1] = t.subarray(0, e), this.maxCursor = this.cursor - 1);\n      }\n      e.length < 64 && e.length < this.chunkSize ? (t = alloc(this.chunkSize), this.chunks.push(t), this.maxCursor += t.length, null === this._initReuseChunk && (this._initReuseChunk = t), t.set(e, 0)) : (this.chunks.push(e), this.maxCursor += e.length);\n    }\n    this.cursor += e.length;\n  }\n  toBytes() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;\n    let t;\n    if (1 === this.chunks.length) {\n      const r = this.chunks[0];\n      e && this.cursor > r.length / 2 ? (t = this.cursor === r.length ? r : r.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : t = slice(r, 0, this.cursor);\n    } else t = concat$2(this.chunks, this.cursor);\n    return e && this.reset(), t;\n  }\n}\nconst decodeErrPrefix = \"CBOR decode error:\",\n  encodeErrPrefix = \"CBOR encode error:\";\nfunction assertEnoughData(e, t, r) {\n  if (e.length - t < r) throw new Error(`${decodeErrPrefix} not enough data for type`);\n}\nconst uintBoundaries = [24, 256, 65536, 4294967296, BigInt(\"18446744073709551616\")];\nfunction readUint8(e, t, r) {\n  assertEnoughData(e, t, 1);\n  const n = e[t];\n  if (!0 === r.strict && n < uintBoundaries[0]) throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  return n;\n}\nfunction readUint16(e, t, r) {\n  assertEnoughData(e, t, 2);\n  const n = e[t] << 8 | e[t + 1];\n  if (!0 === r.strict && n < uintBoundaries[1]) throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  return n;\n}\nfunction readUint32(e, t, r) {\n  assertEnoughData(e, t, 4);\n  const n = 16777216 * e[t] + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3];\n  if (!0 === r.strict && n < uintBoundaries[2]) throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  return n;\n}\nfunction readUint64(e, t, r) {\n  assertEnoughData(e, t, 8);\n  const n = 16777216 * e[t] + (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3],\n    o = 16777216 * e[t + 4] + (e[t + 5] << 16) + (e[t + 6] << 8) + e[t + 7],\n    i = (BigInt(n) << BigInt(32)) + BigInt(o);\n  if (!0 === r.strict && i < uintBoundaries[3]) throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);\n  if (i <= Number.MAX_SAFE_INTEGER) return Number(i);\n  if (!0 === r.allowBigInt) return i;\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);\n}\nfunction decodeUint8(e, t, r, n) {\n  return new Token$1(Type.uint, readUint8(e, t + 1, n), 2);\n}\nfunction decodeUint16(e, t, r, n) {\n  return new Token$1(Type.uint, readUint16(e, t + 1, n), 3);\n}\nfunction decodeUint32(e, t, r, n) {\n  return new Token$1(Type.uint, readUint32(e, t + 1, n), 5);\n}\nfunction decodeUint64(e, t, r, n) {\n  return new Token$1(Type.uint, readUint64(e, t + 1, n), 9);\n}\nfunction encodeUint(e, t) {\n  return encodeUintValue(e, 0, t.value);\n}\nfunction encodeUintValue(e, t, r) {\n  if (r < uintBoundaries[0]) {\n    const n = Number(r);\n    e.push([t | n]);\n  } else if (r < uintBoundaries[1]) {\n    const n = Number(r);\n    e.push([24 | t, n]);\n  } else if (r < uintBoundaries[2]) {\n    const n = Number(r);\n    e.push([25 | t, n >>> 8, 255 & n]);\n  } else if (r < uintBoundaries[3]) {\n    const n = Number(r);\n    e.push([26 | t, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n]);\n  } else {\n    const n = BigInt(r);\n    if (!(n < uintBoundaries[4])) throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);\n    {\n      const r = [27 | t, 0, 0, 0, 0, 0, 0, 0];\n      let o = Number(n & BigInt(4294967295)),\n        i = Number(n >> BigInt(32) & BigInt(4294967295));\n      r[8] = 255 & o, o >>= 8, r[7] = 255 & o, o >>= 8, r[6] = 255 & o, o >>= 8, r[5] = 255 & o, r[4] = 255 & i, i >>= 8, r[3] = 255 & i, i >>= 8, r[2] = 255 & i, i >>= 8, r[1] = 255 & i, e.push(r);\n    }\n  }\n}\nfunction decodeNegint8(e, t, r, n) {\n  return new Token$1(Type.negint, -1 - readUint8(e, t + 1, n), 2);\n}\nfunction decodeNegint16(e, t, r, n) {\n  return new Token$1(Type.negint, -1 - readUint16(e, t + 1, n), 3);\n}\nfunction decodeNegint32(e, t, r, n) {\n  return new Token$1(Type.negint, -1 - readUint32(e, t + 1, n), 5);\n}\nencodeUint.encodedSize = function (e) {\n  return encodeUintValue.encodedSize(e.value);\n}, encodeUintValue.encodedSize = function (e) {\n  return e < uintBoundaries[0] ? 1 : e < uintBoundaries[1] ? 2 : e < uintBoundaries[2] ? 3 : e < uintBoundaries[3] ? 5 : 9;\n}, encodeUint.compareTokens = function (e, t) {\n  return e.value < t.value ? -1 : e.value > t.value ? 1 : 0;\n};\nconst neg1b = BigInt(-1),\n  pos1b = BigInt(1);\nfunction decodeNegint64(e, t, r, n) {\n  const o = readUint64(e, t + 1, n);\n  if (\"bigint\" != typeof o) {\n    const e = -1 - o;\n    if (e >= Number.MIN_SAFE_INTEGER) return new Token$1(Type.negint, e, 9);\n  }\n  if (!0 !== n.allowBigInt) throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);\n  return new Token$1(Type.negint, neg1b - BigInt(o), 9);\n}\nfunction encodeNegint(e, t) {\n  const r = t.value,\n    n = \"bigint\" == typeof r ? r * neg1b - pos1b : -1 * r - 1;\n  encodeUintValue(e, t.type.majorEncoded, n);\n}\nfunction toToken$3(e, t, r, n) {\n  assertEnoughData(e, t, r + n);\n  const o = slice(e, t + r, t + r + n);\n  return new Token$1(Type.bytes, o, r + n);\n}\nfunction decodeBytesCompact(e, t, r, n) {\n  return toToken$3(e, t, 1, r);\n}\nfunction decodeBytes8(e, t, r, n) {\n  return toToken$3(e, t, 2, readUint8(e, t + 1, n));\n}\nfunction decodeBytes16(e, t, r, n) {\n  return toToken$3(e, t, 3, readUint16(e, t + 1, n));\n}\nfunction decodeBytes32(e, t, r, n) {\n  return toToken$3(e, t, 5, readUint32(e, t + 1, n));\n}\nfunction decodeBytes64(e, t, r, n) {\n  const o = readUint64(e, t + 1, n);\n  if (\"bigint\" == typeof o) throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);\n  return toToken$3(e, t, 9, o);\n}\nfunction tokenBytes(e) {\n  return void 0 === e.encodedBytes && (e.encodedBytes = e.type === Type.string ? fromString$2(e.value) : e.value), e.encodedBytes;\n}\nfunction encodeBytes(e, t) {\n  const r = tokenBytes(t);\n  encodeUintValue(e, t.type.majorEncoded, r.length), e.push(r);\n}\nfunction compareBytes(e, t) {\n  return e.length < t.length ? -1 : e.length > t.length ? 1 : compare(e, t);\n}\nfunction toToken$2(e, t, r, n, o) {\n  const i = r + n;\n  assertEnoughData(e, t, i);\n  const s = new Token$1(Type.string, toString(e, t + r, t + i), i);\n  return !0 === o.retainStringBytes && (s.byteValue = slice(e, t + r, t + i)), s;\n}\nfunction decodeStringCompact(e, t, r, n) {\n  return toToken$2(e, t, 1, r, n);\n}\nfunction decodeString8(e, t, r, n) {\n  return toToken$2(e, t, 2, readUint8(e, t + 1, n), n);\n}\nfunction decodeString16(e, t, r, n) {\n  return toToken$2(e, t, 3, readUint16(e, t + 1, n), n);\n}\nfunction decodeString32(e, t, r, n) {\n  return toToken$2(e, t, 5, readUint32(e, t + 1, n), n);\n}\nfunction decodeString64(e, t, r, n) {\n  const o = readUint64(e, t + 1, n);\n  if (\"bigint\" == typeof o) throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);\n  return toToken$2(e, t, 9, o, n);\n}\nencodeNegint.encodedSize = function (e) {\n  const t = e.value,\n    r = \"bigint\" == typeof t ? t * neg1b - pos1b : -1 * t - 1;\n  return r < uintBoundaries[0] ? 1 : r < uintBoundaries[1] ? 2 : r < uintBoundaries[2] ? 3 : r < uintBoundaries[3] ? 5 : 9;\n}, encodeNegint.compareTokens = function (e, t) {\n  return e.value < t.value ? 1 : e.value > t.value ? -1 : 0;\n}, encodeBytes.encodedSize = function (e) {\n  const t = tokenBytes(e);\n  return encodeUintValue.encodedSize(t.length) + t.length;\n}, encodeBytes.compareTokens = function (e, t) {\n  return compareBytes(tokenBytes(e), tokenBytes(t));\n};\nconst encodeString = encodeBytes;\nfunction toToken$1(e, t, r, n) {\n  return new Token$1(Type.array, n, r);\n}\nfunction decodeArrayCompact(e, t, r, n) {\n  return toToken$1(e, t, 1, r);\n}\nfunction decodeArray8(e, t, r, n) {\n  return toToken$1(e, t, 2, readUint8(e, t + 1, n));\n}\nfunction decodeArray16(e, t, r, n) {\n  return toToken$1(e, t, 3, readUint16(e, t + 1, n));\n}\nfunction decodeArray32(e, t, r, n) {\n  return toToken$1(e, t, 5, readUint32(e, t + 1, n));\n}\nfunction decodeArray64(e, t, r, n) {\n  const o = readUint64(e, t + 1, n);\n  if (\"bigint\" == typeof o) throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);\n  return toToken$1(e, t, 9, o);\n}\nfunction decodeArrayIndefinite(e, t, r, n) {\n  if (!1 === n.allowIndefinite) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  return toToken$1(e, t, 1, 1 / 0);\n}\nfunction encodeArray(e, t) {\n  encodeUintValue(e, Type.array.majorEncoded, t.value);\n}\nfunction toToken(e, t, r, n) {\n  return new Token$1(Type.map, n, r);\n}\nfunction decodeMapCompact(e, t, r, n) {\n  return toToken(e, t, 1, r);\n}\nfunction decodeMap8(e, t, r, n) {\n  return toToken(e, t, 2, readUint8(e, t + 1, n));\n}\nfunction decodeMap16(e, t, r, n) {\n  return toToken(e, t, 3, readUint16(e, t + 1, n));\n}\nfunction decodeMap32(e, t, r, n) {\n  return toToken(e, t, 5, readUint32(e, t + 1, n));\n}\nfunction decodeMap64(e, t, r, n) {\n  const o = readUint64(e, t + 1, n);\n  if (\"bigint\" == typeof o) throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);\n  return toToken(e, t, 9, o);\n}\nfunction decodeMapIndefinite(e, t, r, n) {\n  if (!1 === n.allowIndefinite) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  return toToken(e, t, 1, 1 / 0);\n}\nfunction encodeMap(e, t) {\n  encodeUintValue(e, Type.map.majorEncoded, t.value);\n}\nfunction decodeTagCompact(e, t, r, n) {\n  return new Token$1(Type.tag, r, 1);\n}\nfunction decodeTag8(e, t, r, n) {\n  return new Token$1(Type.tag, readUint8(e, t + 1, n), 2);\n}\nfunction decodeTag16(e, t, r, n) {\n  return new Token$1(Type.tag, readUint16(e, t + 1, n), 3);\n}\nfunction decodeTag32(e, t, r, n) {\n  return new Token$1(Type.tag, readUint32(e, t + 1, n), 5);\n}\nfunction decodeTag64(e, t, r, n) {\n  return new Token$1(Type.tag, readUint64(e, t + 1, n), 9);\n}\nfunction encodeTag(e, t) {\n  encodeUintValue(e, Type.tag.majorEncoded, t.value);\n}\nencodeArray.compareTokens = encodeUint.compareTokens, encodeArray.encodedSize = function (e) {\n  return encodeUintValue.encodedSize(e.value);\n}, encodeMap.compareTokens = encodeUint.compareTokens, encodeMap.encodedSize = function (e) {\n  return encodeUintValue.encodedSize(e.value);\n}, encodeTag.compareTokens = encodeUint.compareTokens, encodeTag.encodedSize = function (e) {\n  return encodeUintValue.encodedSize(e.value);\n};\nconst MINOR_FALSE = 20,\n  MINOR_TRUE = 21,\n  MINOR_NULL = 22,\n  MINOR_UNDEFINED = 23;\nfunction decodeUndefined(e, t, r, n) {\n  if (!1 === n.allowUndefined) throw new Error(`${decodeErrPrefix} undefined values are not supported`);\n  return !0 === n.coerceUndefinedToNull ? new Token$1(Type.null, null, 1) : new Token$1(Type.undefined, void 0, 1);\n}\nfunction decodeBreak(e, t, r, n) {\n  if (!1 === n.allowIndefinite) throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);\n  return new Token$1(Type.break, void 0, 1);\n}\nfunction createToken(e, t, r) {\n  if (r) {\n    if (!1 === r.allowNaN && Number.isNaN(e)) throw new Error(`${decodeErrPrefix} NaN values are not supported`);\n    if (!1 === r.allowInfinity && (e === 1 / 0 || e === -1 / 0)) throw new Error(`${decodeErrPrefix} Infinity values are not supported`);\n  }\n  return new Token$1(Type.float, e, t);\n}\nfunction decodeFloat16(e, t, r, n) {\n  return createToken(readFloat16(e, t + 1), 3, n);\n}\nfunction decodeFloat32(e, t, r, n) {\n  return createToken(readFloat32(e, t + 1), 5, n);\n}\nfunction decodeFloat64(e, t, r, n) {\n  return createToken(readFloat64(e, t + 1), 9, n);\n}\nfunction encodeFloat(e, t, r) {\n  const n = t.value;\n  if (!1 === n) e.push([Type.float.majorEncoded | MINOR_FALSE]);else if (!0 === n) e.push([Type.float.majorEncoded | MINOR_TRUE]);else if (null === n) e.push([Type.float.majorEncoded | MINOR_NULL]);else if (void 0 === n) e.push([Type.float.majorEncoded | MINOR_UNDEFINED]);else {\n    let t,\n      o = !1;\n    r && !0 === r.float64 || (encodeFloat16(n), t = readFloat16(ui8a, 1), n === t || Number.isNaN(n) ? (ui8a[0] = 249, e.push(ui8a.slice(0, 3)), o = !0) : (encodeFloat32(n), t = readFloat32(ui8a, 1), n === t && (ui8a[0] = 250, e.push(ui8a.slice(0, 5)), o = !0))), o || (encodeFloat64(n), t = readFloat64(ui8a, 1), ui8a[0] = 251, e.push(ui8a.slice(0, 9)));\n  }\n}\nencodeFloat.encodedSize = function (e, t) {\n  const r = e.value;\n  if (!1 === r || !0 === r || null == r) return 1;\n  if (!t || !0 !== t.float64) {\n    encodeFloat16(r);\n    let e = readFloat16(ui8a, 1);\n    if (r === e || Number.isNaN(r)) return 3;\n    if (encodeFloat32(r), e = readFloat32(ui8a, 1), r === e) return 5;\n  }\n  return 9;\n};\nconst buffer$1 = new ArrayBuffer(9),\n  dataView = new DataView(buffer$1, 1),\n  ui8a = new Uint8Array(buffer$1, 0);\nfunction encodeFloat16(e) {\n  if (e === 1 / 0) dataView.setUint16(0, 31744, !1);else if (e === -1 / 0) dataView.setUint16(0, 64512, !1);else if (Number.isNaN(e)) dataView.setUint16(0, 32256, !1);else {\n    dataView.setFloat32(0, e);\n    const t = dataView.getUint32(0),\n      r = (2139095040 & t) >> 23,\n      n = 8388607 & t;\n    if (255 === r) dataView.setUint16(0, 31744, !1);else if (0 === r) dataView.setUint16(0, (2147483648 & e) >> 16 | n >> 13, !1);else {\n      const e = r - 127;\n      e < -24 ? dataView.setUint16(0, 0) : e < -14 ? dataView.setUint16(0, (2147483648 & t) >> 16 | 1 << 24 + e, !1) : dataView.setUint16(0, (2147483648 & t) >> 16 | e + 15 << 10 | n >> 13, !1);\n    }\n  }\n}\nfunction readFloat16(e, t) {\n  if (e.length - t < 2) throw new Error(`${decodeErrPrefix} not enough data for float16`);\n  const r = (e[t] << 8) + e[t + 1];\n  if (31744 === r) return 1 / 0;\n  if (64512 === r) return -1 / 0;\n  if (32256 === r) return NaN;\n  const n = r >> 10 & 31,\n    o = 1023 & r;\n  let i;\n  return i = 0 === n ? o * 2 ** -24 : 31 !== n ? (o + 1024) * 2 ** (n - 25) : 0 === o ? 1 / 0 : NaN, 32768 & r ? -i : i;\n}\nfunction encodeFloat32(e) {\n  dataView.setFloat32(0, e, !1);\n}\nfunction readFloat32(e, t) {\n  if (e.length - t < 4) throw new Error(`${decodeErrPrefix} not enough data for float32`);\n  const r = (e.byteOffset || 0) + t;\n  return new DataView(e.buffer, r, 4).getFloat32(0, !1);\n}\nfunction encodeFloat64(e) {\n  dataView.setFloat64(0, e, !1);\n}\nfunction readFloat64(e, t) {\n  if (e.length - t < 8) throw new Error(`${decodeErrPrefix} not enough data for float64`);\n  const r = (e.byteOffset || 0) + t;\n  return new DataView(e.buffer, r, 8).getFloat64(0, !1);\n}\nfunction invalidMinor(e, t, r) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${r}) for major ${e[t] >>> 5}`);\n}\nfunction errorer(e) {\n  return () => {\n    throw new Error(`${decodeErrPrefix} ${e}`);\n  };\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;\nconst jump = [];\nfor (let e = 0; e <= 23; e++) jump[e] = invalidMinor;\njump[24] = decodeUint8, jump[25] = decodeUint16, jump[26] = decodeUint32, jump[27] = decodeUint64, jump[28] = invalidMinor, jump[29] = invalidMinor, jump[30] = invalidMinor, jump[31] = invalidMinor;\nfor (let e = 32; e <= 55; e++) jump[e] = invalidMinor;\njump[56] = decodeNegint8, jump[57] = decodeNegint16, jump[58] = decodeNegint32, jump[59] = decodeNegint64, jump[60] = invalidMinor, jump[61] = invalidMinor, jump[62] = invalidMinor, jump[63] = invalidMinor;\nfor (let e = 64; e <= 87; e++) jump[e] = decodeBytesCompact;\njump[88] = decodeBytes8, jump[89] = decodeBytes16, jump[90] = decodeBytes32, jump[91] = decodeBytes64, jump[92] = invalidMinor, jump[93] = invalidMinor, jump[94] = invalidMinor, jump[95] = errorer(\"indefinite length bytes/strings are not supported\");\nfor (let e = 96; e <= 119; e++) jump[e] = decodeStringCompact;\njump[120] = decodeString8, jump[121] = decodeString16, jump[122] = decodeString32, jump[123] = decodeString64, jump[124] = invalidMinor, jump[125] = invalidMinor, jump[126] = invalidMinor, jump[127] = errorer(\"indefinite length bytes/strings are not supported\");\nfor (let e = 128; e <= 151; e++) jump[e] = decodeArrayCompact;\njump[152] = decodeArray8, jump[153] = decodeArray16, jump[154] = decodeArray32, jump[155] = decodeArray64, jump[156] = invalidMinor, jump[157] = invalidMinor, jump[158] = invalidMinor, jump[159] = decodeArrayIndefinite;\nfor (let e = 160; e <= 183; e++) jump[e] = decodeMapCompact;\njump[184] = decodeMap8, jump[185] = decodeMap16, jump[186] = decodeMap32, jump[187] = decodeMap64, jump[188] = invalidMinor, jump[189] = invalidMinor, jump[190] = invalidMinor, jump[191] = decodeMapIndefinite;\nfor (let e = 192; e <= 215; e++) jump[e] = decodeTagCompact;\njump[216] = decodeTag8, jump[217] = decodeTag16, jump[218] = decodeTag32, jump[219] = decodeTag64, jump[220] = invalidMinor, jump[221] = invalidMinor, jump[222] = invalidMinor, jump[223] = invalidMinor;\nfor (let e = 224; e <= 243; e++) jump[e] = errorer(\"simple values are not supported\");\njump[244] = invalidMinor, jump[245] = invalidMinor, jump[246] = invalidMinor, jump[247] = decodeUndefined, jump[248] = errorer(\"simple values are not supported\"), jump[249] = decodeFloat16, jump[250] = decodeFloat32, jump[251] = decodeFloat64, jump[252] = invalidMinor, jump[253] = invalidMinor, jump[254] = invalidMinor, jump[255] = decodeBreak;\nconst quick = [];\nfor (let e = 0; e < 24; e++) quick[e] = new Token$1(Type.uint, e, 1);\nfor (let e = -1; e >= -24; e--) quick[31 - e] = new Token$1(Type.negint, e, 1);\nfunction quickEncodeToken(e) {\n  switch (e.type) {\n    case Type.false:\n      return fromArray([244]);\n    case Type.true:\n      return fromArray([245]);\n    case Type.null:\n      return fromArray([246]);\n    case Type.bytes:\n      return e.value.length ? void 0 : fromArray([64]);\n    case Type.string:\n      return \"\" === e.value ? fromArray([96]) : void 0;\n    case Type.array:\n      return 0 === e.value ? fromArray([128]) : void 0;\n    case Type.map:\n      return 0 === e.value ? fromArray([160]) : void 0;\n    case Type.uint:\n      return e.value < 24 ? fromArray([Number(e.value)]) : void 0;\n    case Type.negint:\n      if (e.value >= -24) return fromArray([31 - Number(e.value)]);\n  }\n}\nquick[64] = new Token$1(Type.bytes, new Uint8Array(0), 1), quick[96] = new Token$1(Type.string, \"\", 1), quick[128] = new Token$1(Type.array, 0, 1), quick[160] = new Token$1(Type.map, 0, 1), quick[244] = new Token$1(Type.false, !1, 1), quick[245] = new Token$1(Type.true, !0, 1), quick[246] = new Token$1(Type.null, null, 1);\nconst defaultEncodeOptions = {\n  float64: !1,\n  mapSorter: mapSorter,\n  quickEncodeToken: quickEncodeToken\n};\nfunction makeCborEncoders() {\n  const e = [];\n  return e[Type.uint.major] = encodeUint, e[Type.negint.major] = encodeNegint, e[Type.bytes.major] = encodeBytes, e[Type.string.major] = encodeString, e[Type.array.major] = encodeArray, e[Type.map.major] = encodeMap, e[Type.tag.major] = encodeTag, e[Type.float.major] = encodeFloat, e;\n}\nconst cborEncoders = makeCborEncoders(),\n  buf = new Bl();\nclass Ref {\n  constructor(e, t) {\n    this.obj = e, this.parent = t;\n  }\n  includes(e) {\n    let t = this;\n    do {\n      if (t.obj === e) return !0;\n    } while (t = t.parent);\n    return !1;\n  }\n  static createCheck(e, t) {\n    if (e && e.includes(t)) throw new Error(`${encodeErrPrefix} object contains circular references`);\n    return new Ref(t, e);\n  }\n}\nconst simpleTokens = {\n    null: new Token$1(Type.null, null),\n    undefined: new Token$1(Type.undefined, void 0),\n    true: new Token$1(Type.true, !0),\n    false: new Token$1(Type.false, !1),\n    emptyArray: new Token$1(Type.array, 0),\n    emptyMap: new Token$1(Type.map, 0)\n  },\n  typeEncoders = {\n    number: (e, t, r, n) => Number.isInteger(e) && Number.isSafeInteger(e) ? new Token$1(e >= 0 ? Type.uint : Type.negint, e) : new Token$1(Type.float, e),\n    bigint: (e, t, r, n) => e >= BigInt(0) ? new Token$1(Type.uint, e) : new Token$1(Type.negint, e),\n    Uint8Array: (e, t, r, n) => new Token$1(Type.bytes, e),\n    string: (e, t, r, n) => new Token$1(Type.string, e),\n    boolean: (e, t, r, n) => e ? simpleTokens.true : simpleTokens.false,\n    null: (e, t, r, n) => simpleTokens.null,\n    undefined: (e, t, r, n) => simpleTokens.undefined,\n    ArrayBuffer: (e, t, r, n) => new Token$1(Type.bytes, new Uint8Array(e)),\n    DataView: (e, t, r, n) => new Token$1(Type.bytes, new Uint8Array(e.buffer, e.byteOffset, e.byteLength)),\n    Array(e, t, r, n) {\n      if (!e.length) return !0 === r.addBreakTokens ? [simpleTokens.emptyArray, new Token$1(Type.break)] : simpleTokens.emptyArray;\n      n = Ref.createCheck(n, e);\n      const o = [];\n      let i = 0;\n      for (const t of e) o[i++] = objectToTokens(t, r, n);\n      return r.addBreakTokens ? [new Token$1(Type.array, e.length), o, new Token$1(Type.break)] : [new Token$1(Type.array, e.length), o];\n    },\n    Object(e, t, r, n) {\n      const o = \"Object\" !== t,\n        i = o ? e.keys() : Object.keys(e),\n        s = o ? e.size : i.length;\n      if (!s) return !0 === r.addBreakTokens ? [simpleTokens.emptyMap, new Token$1(Type.break)] : simpleTokens.emptyMap;\n      n = Ref.createCheck(n, e);\n      const a = [];\n      let c = 0;\n      for (const t of i) a[c++] = [objectToTokens(t, r, n), objectToTokens(o ? e.get(t) : e[t], r, n)];\n      return sortMapEntries(a, r), r.addBreakTokens ? [new Token$1(Type.map, s), a, new Token$1(Type.break)] : [new Token$1(Type.map, s), a];\n    }\n  };\ntypeEncoders.Map = typeEncoders.Object, typeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const e of \"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64\".split(\" \")) typeEncoders[`${e}Array`] = typeEncoders.DataView;\nfunction objectToTokens(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let r = arguments.length > 2 ? arguments[2] : undefined;\n  const n = is(e),\n    o = t && t.typeEncoders && t.typeEncoders[n] || typeEncoders[n];\n  if (\"function\" == typeof o) {\n    const i = o(e, n, t, r);\n    if (null != i) return i;\n  }\n  const i = typeEncoders[n];\n  if (!i) throw new Error(`${encodeErrPrefix} unsupported type: ${n}`);\n  return i(e, n, t, r);\n}\nfunction sortMapEntries(e, t) {\n  t.mapSorter && e.sort(t.mapSorter);\n}\nfunction mapSorter(e, t) {\n  const r = Array.isArray(e[0]) ? e[0][0] : e[0],\n    n = Array.isArray(t[0]) ? t[0][0] : t[0];\n  if (r.type !== n.type) return r.type.compare(n.type);\n  const o = r.type.major,\n    i = cborEncoders[o].compareTokens(r, n);\n  return 0 === i && console.warn(\"WARNING: complex key types used, CBOR key sorting guarantees are gone\"), i;\n}\nfunction tokensToEncoded(e, t, r, n) {\n  if (Array.isArray(t)) for (const o of t) tokensToEncoded(e, o, r, n);else r[t.type.major](e, t, n);\n}\nfunction encodeCustom(e, t, r) {\n  const n = objectToTokens(e, r);\n  if (!Array.isArray(n) && r.quickEncodeToken) {\n    const e = r.quickEncodeToken(n);\n    if (e) return e;\n    const o = t[n.type.major];\n    if (o.encodedSize) {\n      const e = o.encodedSize(n, r),\n        t = new Bl(e);\n      if (o(t, n, r), 1 !== t.chunks.length) throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);\n      return asU8A(t.chunks[0]);\n    }\n  }\n  return buf.reset(), tokensToEncoded(buf, n, t, r), buf.toBytes(!0);\n}\nfunction encode$7(e, t) {\n  return t = Object.assign({}, defaultEncodeOptions, t), encodeCustom(e, cborEncoders, t);\n}\nconst defaultDecodeOptions = {\n  strict: !1,\n  allowIndefinite: !0,\n  allowUndefined: !0,\n  allowBigInt: !0\n};\nclass Tokeniser {\n  constructor(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.pos = 0, this.data = e, this.options = t;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const e = this.data[this.pos];\n    let t = quick[e];\n    if (void 0 === t) {\n      const r = jump[e];\n      if (!r) throw new Error(`${decodeErrPrefix} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, \"0\")})`);\n      const n = 31 & e;\n      t = r(this.data, this.pos, n, this.options);\n    }\n    return this.pos += t.encodedLength, t;\n  }\n}\nconst DONE = Symbol.for(\"DONE\"),\n  BREAK = Symbol.for(\"BREAK\");\nfunction tokenToArray(e, t, r) {\n  const n = [];\n  for (let o = 0; o < e.value; o++) {\n    const i = tokensToObject(t, r);\n    if (i === BREAK) {\n      if (e.value === 1 / 0) break;\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);\n    }\n    if (i === DONE) throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${e.value})`);\n    n[o] = i;\n  }\n  return n;\n}\nfunction tokenToMap(e, t, r) {\n  const n = !0 === r.useMaps,\n    o = n ? void 0 : {},\n    i = n ? new Map() : void 0;\n  for (let s = 0; s < e.value; s++) {\n    const a = tokensToObject(t, r);\n    if (a === BREAK) {\n      if (e.value === 1 / 0) break;\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);\n    }\n    if (a === DONE) throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no key], expected ${e.value})`);\n    if (!0 !== n && \"string\" != typeof a) throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof a})`);\n    const c = tokensToObject(t, r);\n    if (c === DONE) throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no value], expected ${e.value})`);\n    n ? i.set(a, c) : o[a] = c;\n  }\n  return n ? i : o;\n}\nfunction tokensToObject(e, t) {\n  if (e.done()) return DONE;\n  const r = e.next();\n  if (r.type === Type.break) return BREAK;\n  if (r.type.terminal) return r.value;\n  if (r.type === Type.array) return tokenToArray(r, e, t);\n  if (r.type === Type.map) return tokenToMap(r, e, t);\n  if (r.type === Type.tag) {\n    if (t.tags && \"function\" == typeof t.tags[r.value]) {\n      const n = tokensToObject(e, t);\n      return t.tags[r.value](n);\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${r.value})`);\n  }\n  throw new Error(\"unsupported\");\n}\nfunction decode$6(e, t) {\n  if (!(e instanceof Uint8Array)) throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);\n  const r = (t = Object.assign({}, defaultDecodeOptions, t)).tokenizer || new Tokeniser(e, t),\n    n = tokensToObject(r, t);\n  if (n === DONE) throw new Error(`${decodeErrPrefix} did not find any content to decode`);\n  if (n === BREAK) throw new Error(`${decodeErrPrefix} got unexpected break`);\n  if (!r.done()) throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);\n  return n;\n}\nconst CID_CBOR_TAG$1 = 42;\nfunction cidEncoder$1(e) {\n  if (e.asCID !== e) return null;\n  const t = CID.asCID(e);\n  if (!t) return null;\n  const r = new Uint8Array(t.bytes.byteLength + 1);\n  return r.set(t.bytes, 1), [new Token$1(Type.tag, CID_CBOR_TAG$1), new Token$1(Type.bytes, r)];\n}\nfunction undefinedEncoder$1() {\n  throw new Error(\"`undefined` is not supported by the IPLD Data Model and cannot be encoded\");\n}\nfunction numberEncoder$1(e) {\n  if (Number.isNaN(e)) throw new Error(\"`NaN` is not supported by the IPLD Data Model and cannot be encoded\");\n  if (e === 1 / 0 || e === -1 / 0) throw new Error(\"`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded\");\n  return null;\n}\nconst encodeOptions$1 = {\n  float64: !0,\n  typeEncoders: {\n    Object: cidEncoder$1,\n    undefined: undefinedEncoder$1,\n    number: numberEncoder$1\n  }\n};\nfunction cidDecoder$1(e) {\n  if (0 !== e[0]) throw new Error(\"Invalid CID for CBOR tag 42; expected leading 0x00\");\n  return CID.decode(e.subarray(1));\n}\nconst decodeOptions$1 = {\n  allowIndefinite: !1,\n  coerceUndefinedToNull: !0,\n  allowNaN: !1,\n  allowInfinity: !1,\n  allowBigInt: !0,\n  strict: !0,\n  useMaps: !1,\n  tags: []\n};\ndecodeOptions$1.tags[CID_CBOR_TAG$1] = cidDecoder$1;\nconst encode$6 = e => encode$7(e, encodeOptions$1),\n  decode$5 = e => decode$6(e, decodeOptions$1),\n  CIDV0_BYTES = {\n    SHA2_256: 18,\n    LENGTH: 32,\n    DAG_PB: 112\n  };\nasync function readVarint(e) {\n  const t = await e.upTo(8),\n    r = varint$1.decode(t);\n  return e.seek(varint$1.decode.bytes), r;\n}\nasync function readHeader(e) {\n  const t = await readVarint(e);\n  if (0 === t) throw new Error(\"Invalid CAR header (zero length)\");\n  const r = await e.exactly(t);\n  e.seek(t);\n  const n = decode$5(r);\n  if (null == n || Array.isArray(n) || \"object\" != typeof n) throw new Error(\"Invalid CAR header format\");\n  if (1 !== n.version) {\n    if (\"string\" == typeof n.version) throw new Error(`Invalid CAR version: \"${n.version}\"`);\n    throw new Error(`Invalid CAR version: ${n.version}`);\n  }\n  if (!Array.isArray(n.roots)) throw new Error(\"Invalid CAR header format\");\n  if (Object.keys(n).filter(e => \"roots\" !== e && \"version\" !== e).length) throw new Error(\"Invalid CAR header format\");\n  return n;\n}\nasync function readMultihash(e) {\n  const t = await e.upTo(8);\n  varint$1.decode(t);\n  const r = varint$1.decode.bytes,\n    n = varint$1.decode(t.subarray(varint$1.decode.bytes)),\n    o = r + varint$1.decode.bytes + n,\n    i = await e.exactly(o);\n  return e.seek(o), i;\n}\nasync function readCid(e) {\n  const t = await e.exactly(2);\n  if (t[0] === CIDV0_BYTES.SHA2_256 && t[1] === CIDV0_BYTES.LENGTH) {\n    const t = await e.exactly(34);\n    e.seek(34);\n    const r = decode$8(t);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, r);\n  }\n  const r = await readVarint(e);\n  if (1 !== r) throw new Error(`Unexpected CID version (${r})`);\n  const n = await readVarint(e),\n    o = await readMultihash(e),\n    i = decode$8(o);\n  return CID.create(r, n, i);\n}\nasync function readBlockHead(e) {\n  const t = e.pos;\n  let r = await readVarint(e);\n  if (0 === r) throw new Error(\"Invalid CAR section (zero length)\");\n  r += e.pos - t;\n  return {\n    cid: await readCid(e),\n    length: r,\n    blockLength: r - (e.pos - t)\n  };\n}\nasync function readBlock(e) {\n  const {\n      cid: t,\n      blockLength: r\n    } = await readBlockHead(e),\n    n = await e.exactly(r);\n  return e.seek(r), {\n    bytes: n,\n    cid: t\n  };\n}\nasync function readBlockIndex(e) {\n  const t = e.pos,\n    {\n      cid: r,\n      length: n,\n      blockLength: o\n    } = await readBlockHead(e),\n    i = {\n      cid: r,\n      length: n,\n      blockLength: o,\n      offset: t,\n      blockOffset: e.pos\n    };\n  return e.seek(i.blockLength), i;\n}\nfunction createDecoder(e) {\n  const t = readHeader(e);\n  return {\n    header: () => t,\n    async *blocks() {\n      for (await t; (await e.upTo(8)).length > 0;) yield await readBlock(e);\n    },\n    async *blocksIndex() {\n      for (await t; (await e.upTo(8)).length > 0;) yield await readBlockIndex(e);\n    }\n  };\n}\nfunction bytesReader(e) {\n  let t = 0;\n  return {\n    upTo: async r => e.subarray(t, t + Math.min(r, e.length - t)),\n    async exactly(r) {\n      if (r > e.length - t) throw new Error(\"Unexpected end of data\");\n      return e.subarray(t, t + r);\n    },\n    seek(e) {\n      t += e;\n    },\n    get pos() {\n      return t;\n    }\n  };\n}\nfunction chunkReader(e) {\n  let t = 0,\n    r = 0,\n    n = 0,\n    o = new Uint8Array(0);\n  const i = async t => {\n    r = o.length - n;\n    const i = [o.subarray(n)];\n    for (; r < t;) {\n      const t = await e();\n      if (null == t) break;\n      r < 0 ? t.length > r && i.push(t.subarray(-r)) : i.push(t), r += t.length;\n    }\n    o = new Uint8Array(i.reduce((e, t) => e + t.length, 0));\n    let s = 0;\n    for (const e of i) o.set(e, s), s += e.length;\n    n = 0;\n  };\n  return {\n    upTo: async e => (o.length - n < e && (await i(e)), o.subarray(n, n + Math.min(o.length - n, e))),\n    async exactly(e) {\n      if (o.length - n < e && (await i(e)), o.length - n < e) throw new Error(\"Unexpected end of data\");\n      return o.subarray(n, n + e);\n    },\n    seek(e) {\n      t += e, n += e;\n    },\n    get pos() {\n      return t;\n    }\n  };\n}\nfunction asyncIterableReader(e) {\n  const t = e[Symbol.asyncIterator]();\n  return chunkReader(async function () {\n    const e = await t.next();\n    return e.done ? null : e.value;\n  });\n}\nclass CarReader {\n  constructor(e, t, r) {\n    this._version = e, this._roots = t, this._blocks = r, this._keys = r.map(e => e.cid.toString());\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  async has(e) {\n    return this._keys.indexOf(e.toString()) > -1;\n  }\n  async get(e) {\n    const t = this._keys.indexOf(e.toString());\n    return t > -1 ? this._blocks[t] : void 0;\n  }\n  async *blocks() {\n    for (const e of this._blocks) yield e;\n  }\n  async *cids() {\n    for (const e of this._blocks) yield e.cid;\n  }\n  static async fromBytes(e) {\n    if (!(e instanceof Uint8Array)) throw new TypeError(\"fromBytes() requires a Uint8Array\");\n    return decodeReaderComplete(bytesReader(e));\n  }\n  static async fromIterable(e) {\n    if (!e || \"function\" != typeof e[Symbol.asyncIterator]) throw new TypeError(\"fromIterable() requires an async iterable\");\n    return decodeReaderComplete(asyncIterableReader(e));\n  }\n}\nasync function decodeReaderComplete(e) {\n  const t = createDecoder(e),\n    {\n      version: r,\n      roots: n\n    } = await t.header(),\n    o = [];\n  for await (const e of t.blocks()) o.push(e);\n  return new CarReader(r, n, o);\n}\nfunction createHeader(e) {\n  const t = encode$6({\n      version: 1,\n      roots: e\n    }),\n    r = varint$1.encode(t.length),\n    n = new Uint8Array(r.length + t.length);\n  return n.set(r, 0), n.set(t, r.length), n;\n}\nfunction createEncoder(e) {\n  return {\n    async setRoots(t) {\n      const r = createHeader(t);\n      await e.write(r);\n    },\n    async writeBlock(t) {\n      const {\n        cid: r,\n        bytes: n\n      } = t;\n      await e.write(new Uint8Array(varint$1.encode(r.bytes.length + n.length))), await e.write(r.bytes), n.length && (await e.write(n));\n    },\n    close: async () => e.end()\n  };\n}\nfunction noop$1() {}\nfunction create$3() {\n  const e = [];\n  let t = null,\n    r = noop$1,\n    n = !1,\n    o = null,\n    i = noop$1;\n  const s = () => (t || (t = new Promise(e => {\n      r = () => {\n        t = null, r = noop$1, e();\n      };\n    })), t),\n    a = {\n      write(t) {\n        e.push(t);\n        const r = s();\n        return i(), r;\n      },\n      async end() {\n        n = !0;\n        const e = s();\n        return i(), e;\n      }\n    },\n    c = {\n      async next() {\n        const t = e.shift();\n        return t ? (0 === e.length && r(), {\n          done: !1,\n          value: t\n        }) : n ? (r(), {\n          done: !0,\n          value: void 0\n        }) : (o || (o = new Promise(e => {\n          i = () => (o = null, i = noop$1, e(c.next()));\n        })), o);\n      }\n    };\n  return {\n    writer: a,\n    iterator: c\n  };\n}\nclass CarWriter {\n  constructor(e, t) {\n    this._encoder = t, this._mutex = t.setRoots(e), this._ended = !1;\n  }\n  async put(e) {\n    if (!(e.bytes instanceof Uint8Array && e.cid)) throw new TypeError(\"Can only write {cid, bytes} objects\");\n    if (this._ended) throw new Error(\"Already closed\");\n    const t = CID.asCID(e.cid);\n    if (!t) throw new TypeError(\"Can only write {cid, bytes} objects\");\n    return this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid: t,\n      bytes: e.bytes\n    })), this._mutex;\n  }\n  async close() {\n    if (this._ended) throw new Error(\"Already closed\");\n    return await this._mutex, this._ended = !0, this._encoder.close();\n  }\n  static create(e) {\n    e = toRoots(e);\n    const {\n      encoder: t,\n      iterator: r\n    } = encodeWriter();\n    return {\n      writer: new CarWriter(e, t),\n      out: new CarWriterOut(r)\n    };\n  }\n  static createAppender() {\n    const {\n      encoder: e,\n      iterator: t\n    } = encodeWriter();\n    e.setRoots = () => Promise.resolve();\n    return {\n      writer: new CarWriter([], e),\n      out: new CarWriterOut(t)\n    };\n  }\n  static async updateRootsInBytes(e, t) {\n    const r = bytesReader(e);\n    await readHeader(r);\n    const n = createHeader(t);\n    if (r.pos !== n.length) throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${r.pos} bytes, new header is ${n.length} bytes)`);\n    return e.set(n, 0), e;\n  }\n}\nclass CarWriterOut {\n  constructor(e) {\n    this._iterator = e;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) throw new Error(\"Multiple iterator not supported\");\n    return this._iterating = !0, this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const e = create$3(),\n    {\n      writer: t,\n      iterator: r\n    } = e;\n  return {\n    encoder: createEncoder(t),\n    iterator: r\n  };\n}\nfunction toRoots(e) {\n  if (void 0 === e) return [];\n  if (!Array.isArray(e)) {\n    const t = CID.asCID(e);\n    if (!t) throw new TypeError(\"roots must be a single CID or an array of CIDs\");\n    return [t];\n  }\n  const t = [];\n  for (const r of e) {\n    const e = CID.asCID(r);\n    if (!e) throw new TypeError(\"roots must be a single CID or an array of CIDs\");\n    t.push(e);\n  }\n  return t;\n}\nconst from = _ref4 => {\n  let {\n    name: e,\n    code: t,\n    encode: r\n  } = _ref4;\n  return new Hasher(e, t, r);\n};\nclass Hasher {\n  constructor(e, t, r) {\n    this.name = e, this.code = t, this.encode = r;\n  }\n  digest(e) {\n    if (e instanceof Uint8Array) {\n      const t = this.encode(e);\n      return t instanceof Uint8Array ? create$4(this.code, t) : t.then(e => create$4(this.code, e));\n    }\n    throw Error(\"Unknown type, must be binary type\");\n  }\n}\nconst readonly = function () {\n    let {\n      enumerable: e = !0,\n      configurable: t = !1\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return {\n      enumerable: e,\n      configurable: t,\n      writable: !1\n    };\n  },\n  links = function* (e, t) {\n    if (null != e && !(e instanceof Uint8Array)) for (const [r, n] of Object.entries(e)) {\n      const e = [...t, r];\n      if (null != n && \"object\" == typeof n) if (Array.isArray(n)) for (const [t, r] of n.entries()) {\n        const n = [...e, t],\n          o = CID.asCID(r);\n        o ? yield [n.join(\"/\"), o] : \"object\" == typeof r && (yield* links(r, n));\n      } else {\n        const t = CID.asCID(n);\n        t ? yield [e.join(\"/\"), t] : yield* links(n, e);\n      }\n    }\n  },\n  tree = function* (e, t) {\n    if (null != e) for (const [r, n] of Object.entries(e)) {\n      const e = [...t, r];\n      if (yield e.join(\"/\"), !(null == n || n instanceof Uint8Array || \"object\" != typeof n || CID.asCID(n))) if (Array.isArray(n)) for (const [t, r] of n.entries()) {\n        const n = [...e, t];\n        yield n.join(\"/\"), \"object\" != typeof r || CID.asCID(r) || (yield* tree(r, n));\n      } else yield* tree(n, e);\n    }\n  },\n  get = (e, t) => {\n    let r = e;\n    for (const [e, n] of t.entries()) {\n      if (r = r[n], null == r) throw new Error(`Object has no property at ${t.slice(0, e + 1).map(e => `[${JSON.stringify(e)}]`).join(\"\")}`);\n      const o = CID.asCID(r);\n      if (o) return {\n        value: o,\n        remaining: t.slice(e + 1).join(\"/\")\n      };\n    }\n    return {\n      value: r\n    };\n  };\nclass Block {\n  constructor(_ref5) {\n    let {\n      cid: e,\n      bytes: t,\n      value: r\n    } = _ref5;\n    if (!e || !t || void 0 === r) throw new Error(\"Missing required argument\");\n    this.cid = e, this.bytes = t, this.value = r, this.asBlock = this, Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n  links() {\n    return links(this.value, []);\n  }\n  tree() {\n    return tree(this.value, []);\n  }\n  get() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n    return get(this.value, e.split(\"/\").filter(Boolean));\n  }\n}\nconst encode$5 = async _ref6 => {\n    let {\n      value: e,\n      codec: t,\n      hasher: r\n    } = _ref6;\n    if (void 0 === e) throw new Error('Missing required argument \"value\"');\n    if (!t || !r) throw new Error(\"Missing required argument: codec or hasher\");\n    const n = t.encode(e),\n      o = await r.digest(n),\n      i = CID.create(1, t.code, o);\n    return new Block({\n      value: e,\n      bytes: n,\n      cid: i\n    });\n  },\n  name$2 = \"raw\",\n  code$3 = 85,\n  encode$4 = e => coerce(e),\n  decode$4 = e => coerce(e);\nvar raw = Object.freeze({\n  __proto__: null,\n  name: name$2,\n  code: code$3,\n  encode: encode$4,\n  decode: decode$4\n});\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(e) {\n  if (e.asCID !== e) return null;\n  const t = CID.asCID(e);\n  if (!t) return null;\n  const r = new Uint8Array(t.bytes.byteLength + 1);\n  return r.set(t.bytes, 1), [new Token$1(Type.tag, CID_CBOR_TAG), new Token$1(Type.bytes, r)];\n}\nfunction undefinedEncoder() {\n  throw new Error(\"`undefined` is not supported by the IPLD Data Model and cannot be encoded\");\n}\nfunction numberEncoder(e) {\n  if (Number.isNaN(e)) throw new Error(\"`NaN` is not supported by the IPLD Data Model and cannot be encoded\");\n  if (e === 1 / 0 || e === -1 / 0) throw new Error(\"`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded\");\n  return null;\n}\nconst encodeOptions = {\n  float64: !0,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(e) {\n  if (0 !== e[0]) throw new Error(\"Invalid CID for CBOR tag 42; expected leading 0x00\");\n  return CID.decode(e.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: !1,\n  allowUndefined: !1,\n  allowNaN: !1,\n  allowInfinity: !1,\n  allowBigInt: !0,\n  strict: !0,\n  useMaps: !1,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nconst name$1 = \"dag-cbor\",\n  code$2 = 113,\n  encode$3 = e => encode$7(e, encodeOptions),\n  decode$3 = e => decode$6(e, decodeOptions);\nvar dagCbor = Object.freeze({\n  __proto__: null,\n  name: name$1,\n  code: code$2,\n  encode: encode$3,\n  decode: decode$3\n});\nconst textDecoder = new TextDecoder();\nfunction decodeVarint(e, t) {\n  let r = 0;\n  for (let n = 0;; n += 7) {\n    if (n >= 64) throw new Error(\"protobuf: varint overflow\");\n    if (t >= e.length) throw new Error(\"protobuf: unexpected end of data\");\n    const o = e[t++];\n    if (r += n < 28 ? (127 & o) << n : (127 & o) * 2 ** n, o < 128) break;\n  }\n  return [r, t];\n}\nfunction decodeBytes(e, t) {\n  let r;\n  [r, t] = decodeVarint(e, t);\n  const n = t + r;\n  if (r < 0 || n < 0) throw new Error(\"protobuf: invalid length\");\n  if (n > e.length) throw new Error(\"protobuf: unexpected end of data\");\n  return [e.subarray(t, n), n];\n}\nfunction decodeKey(e, t) {\n  let r;\n  return [r, t] = decodeVarint(e, t), [7 & r, r >> 3, t];\n}\nfunction decodeLink(e) {\n  const t = {},\n    r = e.length;\n  let n = 0;\n  for (; n < r;) {\n    let r, o;\n    if ([r, o, n] = decodeKey(e, n), 1 === o) {\n      if (t.Hash) throw new Error(\"protobuf: (PBLink) duplicate Hash section\");\n      if (2 !== r) throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Hash`);\n      if (void 0 !== t.Name) throw new Error(\"protobuf: (PBLink) invalid order, found Name before Hash\");\n      if (void 0 !== t.Tsize) throw new Error(\"protobuf: (PBLink) invalid order, found Tsize before Hash\");\n      [t.Hash, n] = decodeBytes(e, n);\n    } else if (2 === o) {\n      if (void 0 !== t.Name) throw new Error(\"protobuf: (PBLink) duplicate Name section\");\n      if (2 !== r) throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Name`);\n      if (void 0 !== t.Tsize) throw new Error(\"protobuf: (PBLink) invalid order, found Tsize before Name\");\n      let o;\n      [o, n] = decodeBytes(e, n), t.Name = textDecoder.decode(o);\n    } else {\n      if (3 !== o) throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`);\n      if (void 0 !== t.Tsize) throw new Error(\"protobuf: (PBLink) duplicate Tsize section\");\n      if (0 !== r) throw new Error(`protobuf: (PBLink) wrong wireType (${r}) for Tsize`);\n      [t.Tsize, n] = decodeVarint(e, n);\n    }\n  }\n  if (n > r) throw new Error(\"protobuf: (PBLink) unexpected end of data\");\n  return t;\n}\nfunction decodeNode(e) {\n  const t = e.length;\n  let r,\n    n,\n    o = 0,\n    i = !1;\n  for (; o < t;) {\n    let t, s;\n    if ([t, s, o] = decodeKey(e, o), 2 !== t) throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${t}`);\n    if (1 === s) {\n      if (n) throw new Error(\"protobuf: (PBNode) duplicate Data section\");\n      [n, o] = decodeBytes(e, o), r && (i = !0);\n    } else {\n      if (2 !== s) throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${s}`);\n      {\n        if (i) throw new Error(\"protobuf: (PBNode) duplicate Links section\");\n        let t;\n        r || (r = []), [t, o] = decodeBytes(e, o), r.push(decodeLink(t));\n      }\n    }\n  }\n  if (o > t) throw new Error(\"protobuf: (PBNode) unexpected end of data\");\n  const s = {};\n  return n && (s.Data = n), s.Links = r || [], s;\n}\nconst textEncoder$1 = new TextEncoder(),\n  maxInt32 = 2 ** 32,\n  maxUInt32 = 2 ** 31;\nfunction encodeLink(e, t) {\n  let r = t.length;\n  if (\"number\" == typeof e.Tsize) {\n    if (e.Tsize < 0) throw new Error(\"Tsize cannot be negative\");\n    if (!Number.isSafeInteger(e.Tsize)) throw new Error(\"Tsize too large for encoding\");\n    r = encodeVarint(t, r, e.Tsize) - 1, t[r] = 24;\n  }\n  if (\"string\" == typeof e.Name) {\n    const n = textEncoder$1.encode(e.Name);\n    r -= n.length, t.set(n, r), r = encodeVarint(t, r, n.length) - 1, t[r] = 18;\n  }\n  return e.Hash && (r -= e.Hash.length, t.set(e.Hash, r), r = encodeVarint(t, r, e.Hash.length) - 1, t[r] = 10), t.length - r;\n}\nfunction encodeNode(e) {\n  const t = sizeNode(e),\n    r = new Uint8Array(t);\n  let n = t;\n  if (e.Data && (n -= e.Data.length, r.set(e.Data, n), n = encodeVarint(r, n, e.Data.length) - 1, r[n] = 10), e.Links) for (let t = e.Links.length - 1; t >= 0; t--) {\n    const o = encodeLink(e.Links[t], r.subarray(0, n));\n    n -= o, n = encodeVarint(r, n, o) - 1, r[n] = 18;\n  }\n  return r;\n}\nfunction sizeLink(e) {\n  let t = 0;\n  if (e.Hash) {\n    const r = e.Hash.length;\n    t += 1 + r + sov(r);\n  }\n  if (\"string\" == typeof e.Name) {\n    const r = textEncoder$1.encode(e.Name).length;\n    t += 1 + r + sov(r);\n  }\n  return \"number\" == typeof e.Tsize && (t += 1 + sov(e.Tsize)), t;\n}\nfunction sizeNode(e) {\n  let t = 0;\n  if (e.Data) {\n    const r = e.Data.length;\n    t += 1 + r + sov(r);\n  }\n  if (e.Links) for (const r of e.Links) {\n    const e = sizeLink(r);\n    t += 1 + e + sov(e);\n  }\n  return t;\n}\nfunction encodeVarint(e, t, r) {\n  const n = t -= sov(r);\n  for (; r >= maxUInt32;) e[t++] = 127 & r | 128, r /= 128;\n  for (; r >= 128;) e[t++] = 127 & r | 128, r >>>= 7;\n  return e[t] = r, n;\n}\nfunction sov(e) {\n  return e % 2 == 0 && e++, Math.floor((len64(e) + 6) / 7);\n}\nfunction len64(e) {\n  let t = 0;\n  return e >= maxInt32 && (e = Math.floor(e / maxInt32), t = 32), e >= 65536 && (e >>>= 16, t += 16), e >= 256 && (e >>>= 8, t += 8), t + len8tab[e];\n}\nconst len8tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8],\n  pbNodeProperties = [\"Data\", \"Links\"],\n  pbLinkProperties = [\"Hash\", \"Name\", \"Tsize\"],\n  textEncoder = new TextEncoder();\nfunction linkComparator(e, t) {\n  if (e === t) return 0;\n  const r = e.Name ? textEncoder.encode(e.Name) : [],\n    n = t.Name ? textEncoder.encode(t.Name) : [];\n  let o = r.length,\n    i = n.length;\n  for (let e = 0, t = Math.min(o, i); e < t; ++e) if (r[e] !== n[e]) {\n    o = r[e], i = n[e];\n    break;\n  }\n  return o < i ? -1 : i < o ? 1 : 0;\n}\nfunction hasOnlyProperties(e, t) {\n  return !Object.keys(e).some(e => !t.includes(e));\n}\nfunction asLink(e) {\n  if (\"object\" == typeof e.asCID) {\n    const t = CID.asCID(e);\n    if (!t) throw new TypeError(\"Invalid DAG-PB form\");\n    return {\n      Hash: t\n    };\n  }\n  if (\"object\" != typeof e || Array.isArray(e)) throw new TypeError(\"Invalid DAG-PB form\");\n  const t = {};\n  if (e.Hash) {\n    let r = CID.asCID(e.Hash);\n    try {\n      r || (\"string\" == typeof e.Hash ? r = CID.parse(e.Hash) : e.Hash instanceof Uint8Array && (r = CID.decode(e.Hash)));\n    } catch (e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);\n    }\n    r && (t.Hash = r);\n  }\n  if (!t.Hash) throw new TypeError(\"Invalid DAG-PB form\");\n  return \"string\" == typeof e.Name && (t.Name = e.Name), \"number\" == typeof e.Tsize && (t.Tsize = e.Tsize), t;\n}\nfunction prepare(e) {\n  if ((e instanceof Uint8Array || \"string\" == typeof e) && (e = {\n    Data: e\n  }), \"object\" != typeof e || Array.isArray(e)) throw new TypeError(\"Invalid DAG-PB form\");\n  const t = {};\n  if (void 0 !== e.Data) if (\"string\" == typeof e.Data) t.Data = textEncoder.encode(e.Data);else {\n    if (!(e.Data instanceof Uint8Array)) throw new TypeError(\"Invalid DAG-PB form\");\n    t.Data = e.Data;\n  }\n  if (void 0 !== e.Links) {\n    if (!Array.isArray(e.Links)) throw new TypeError(\"Invalid DAG-PB form\");\n    t.Links = e.Links.map(asLink), t.Links.sort(linkComparator);\n  } else t.Links = [];\n  return t;\n}\nfunction validate(e) {\n  if (!e || \"object\" != typeof e || Array.isArray(e)) throw new TypeError(\"Invalid DAG-PB form\");\n  if (!hasOnlyProperties(e, pbNodeProperties)) throw new TypeError(\"Invalid DAG-PB form (extraneous properties)\");\n  if (void 0 !== e.Data && !(e.Data instanceof Uint8Array)) throw new TypeError(\"Invalid DAG-PB form (Data must be a Uint8Array)\");\n  if (!Array.isArray(e.Links)) throw new TypeError(\"Invalid DAG-PB form (Links must be an array)\");\n  for (let t = 0; t < e.Links.length; t++) {\n    const r = e.Links[t];\n    if (!r || \"object\" != typeof r || Array.isArray(r)) throw new TypeError(\"Invalid DAG-PB form (bad link object)\");\n    if (!hasOnlyProperties(r, pbLinkProperties)) throw new TypeError(\"Invalid DAG-PB form (extraneous properties on link object)\");\n    if (!r.Hash) throw new TypeError(\"Invalid DAG-PB form (link must have a Hash)\");\n    if (r.Hash.asCID !== r.Hash) throw new TypeError(\"Invalid DAG-PB form (link Hash must be a CID)\");\n    if (void 0 !== r.Name && \"string\" != typeof r.Name) throw new TypeError(\"Invalid DAG-PB form (link Name must be a string)\");\n    if (void 0 !== r.Tsize && (\"number\" != typeof r.Tsize || r.Tsize % 1 != 0)) throw new TypeError(\"Invalid DAG-PB form (link Tsize must be an integer)\");\n    if (t > 0 && -1 === linkComparator(r, e.Links[t - 1])) throw new TypeError(\"Invalid DAG-PB form (links must be sorted by Name bytes)\");\n  }\n}\nfunction createNode(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return prepare({\n    Data: e,\n    Links: t\n  });\n}\nfunction createLink(e, t, r) {\n  return asLink({\n    Hash: r,\n    Name: e,\n    Tsize: t\n  });\n}\nconst name = \"dag-pb\",\n  code$1 = 112;\nfunction encode$2(e) {\n  validate(e);\n  const t = {};\n  return e.Links && (t.Links = e.Links.map(e => {\n    const t = {};\n    return e.Hash && (t.Hash = e.Hash.bytes), void 0 !== e.Name && (t.Name = e.Name), void 0 !== e.Tsize && (t.Tsize = e.Tsize), t;\n  })), e.Data && (t.Data = e.Data), encodeNode(t);\n}\nfunction decode$2(e) {\n  const t = decodeNode(e),\n    r = {};\n  return t.Data && (r.Data = t.Data), t.Links && (r.Links = t.Links.map(e => {\n    const t = {};\n    try {\n      t.Hash = CID.decode(e.Hash);\n    } catch (e) {}\n    if (!t.Hash) throw new Error(\"Invalid Hash field found in link, expected CID\");\n    return void 0 !== e.Name && (t.Name = e.Name), void 0 !== e.Tsize && (t.Tsize = e.Tsize), t;\n  })), r;\n}\nvar dagPb = Object.freeze({\n  __proto__: null,\n  name: name,\n  code: code$1,\n  encode: encode$2,\n  decode: decode$2,\n  prepare: prepare,\n  validate: validate,\n  createNode: createNode,\n  createLink: createLink\n});\nclass TreewalkCarSplitter {\n  constructor(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (\"number\" != typeof t || t <= 0) throw new Error(\"invalid target chunk size\");\n    this._reader = e, this._targetSize = t, this._decoders = [dagPb, raw, dagCbor, ...(r.decoders || [])];\n  }\n  async *cars() {\n    const e = await this._reader.getRoots();\n    if (1 !== e.length) throw new Error(`unexpected number of roots: ${e.length}`);\n    let t;\n    for await (const r of this._cars(e[0])) t = r.channel, r.out && (yield r.out);\n    if (!t) throw new Error(\"missing CAR writer channel\");\n    t.writer.close(), yield t.out;\n  }\n  async _get(e) {\n    const t = await this._reader.get(e);\n    if (!t) throw new Error(`missing block for ${e}`);\n    const {\n        bytes: r\n      } = t,\n      n = this._decoders.find(t => t.code === e.code);\n    if (!n) throw new Error(`missing decoder for ${e.code}`);\n    return new Block({\n      cid: e,\n      bytes: r,\n      value: n.decode(r)\n    });\n  }\n  async *_cars(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let r = arguments.length > 2 ? arguments[2] : undefined;\n    const n = await this._get(e);\n    if ((r = r || Object.assign(CarWriter.create(e), {\n      size: 0\n    })).size > 0 && r.size + n.bytes.byteLength >= this._targetSize) {\n      r.writer.close();\n      const {\n        out: e\n      } = r;\n      r = newCar(t), yield {\n        channel: r,\n        out: e\n      };\n    }\n    t = t.concat(n), r.size += n.bytes.byteLength, r.writer.put(n);\n    for (const [, e] of n.links()) for await (const n of this._cars(e, t, r)) r = n.channel, yield n;\n    if (!r) throw new Error(\"missing CAR writer channel\");\n    yield {\n      channel: r\n    };\n  }\n  static async fromIterable(e, t, r) {\n    const n = await CarReader.fromIterable(e);\n    return new TreewalkCarSplitter(n, t, r);\n  }\n  static async fromBlob(e, t, r) {\n    const n = await e.arrayBuffer(),\n      o = await CarReader.fromBytes(new Uint8Array(n));\n    return new TreewalkCarSplitter(o, t, r);\n  }\n}\nfunction newCar(e) {\n  const t = Object.assign(CarWriter.create(e[0].cid), {\n    size: e.reduce((e, t) => e + t.bytes.byteLength, 0)\n  });\n  for (const r of e) t.writer.put(r);\n  return t;\n}\nconst last = async e => {\n  let t;\n  for await (const r of e) t = r;\n  return t;\n};\nvar itLast = last,\n  itPipe = {\n    exports: {}\n  };\nconst rawPipe = function () {\n    let t;\n    for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {\n      e[_key] = arguments[_key];\n    }\n    for (; e.length;) t = e.shift()(t);\n    return t;\n  },\n  isIterable$1 = e => e && (\"function\" == typeof e[Symbol.asyncIterator] || \"function\" == typeof e[Symbol.iterator] || \"function\" == typeof e.next),\n  isDuplex = e => e && \"function\" == typeof e.sink && isIterable$1(e.source),\n  duplexPipelineFn = e => t => (e.sink(t), e.source),\n  pipe = function () {\n    for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      e[_key2] = arguments[_key2];\n    }\n    if (isDuplex(e[0])) {\n      const t = e[0];\n      e[0] = () => t.source;\n    } else if (isIterable$1(e[0])) {\n      const t = e[0];\n      e[0] = () => t;\n    }\n    if (e.length > 1 && isDuplex(e[e.length - 1]) && (e[e.length - 1] = e[e.length - 1].sink), e.length > 2) for (let t = 1; t < e.length - 1; t++) isDuplex(e[t]) && (e[t] = duplexPipelineFn(e[t]));\n    return rawPipe(...e);\n  };\nitPipe.exports = pipe, itPipe.exports.pipe = pipe, itPipe.exports.rawPipe = rawPipe, itPipe.exports.isIterable = isIterable$1, itPipe.exports.isDuplex = isDuplex;\nvar pipe$1 = itPipe.exports;\nasync function* batch$1(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let r = [];\n  t < 1 && (t = 1);\n  for await (const n of e) for (r.push(n); r.length >= t;) yield r.slice(0, t), r = r.slice(t);\n  for (; r.length;) yield r.slice(0, t), r = r.slice(t);\n}\nvar itBatch = batch$1;\nconst batch = itBatch;\nasync function* parallelBatch(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  for await (const r of batch(e, t)) {\n    const e = r.map(e => e().then(e => ({\n      ok: !0,\n      value: e\n    }), e => ({\n      ok: !1,\n      err: e\n    })));\n    for (let t = 0; t < e.length; t++) {\n      const r = await e[t];\n      if (!r.ok) throw r.err;\n      yield r.value;\n    }\n  }\n}\nvar itParallelBatch = parallelBatch,\n  isPlainObj = e => {\n    if (\"[object Object]\" !== Object.prototype.toString.call(e)) return !1;\n    const t = Object.getPrototypeOf(e);\n    return null === t || t === Object.prototype;\n  };\nconst isOptionObject = isPlainObj,\n  {\n    hasOwnProperty: hasOwnProperty\n  } = Object.prototype,\n  {\n    propertyIsEnumerable: propertyIsEnumerable\n  } = Object,\n  defineProperty = (e, t, r) => Object.defineProperty(e, t, {\n    value: r,\n    writable: !0,\n    enumerable: !0,\n    configurable: !0\n  }),\n  globalThis$1 = commonjsGlobal,\n  defaultMergeOptions = {\n    concatArrays: !1,\n    ignoreUndefined: !1\n  },\n  getEnumerableOwnPropertyKeys = e => {\n    const t = [];\n    for (const r in e) hasOwnProperty.call(e, r) && t.push(r);\n    if (Object.getOwnPropertySymbols) {\n      const r = Object.getOwnPropertySymbols(e);\n      for (const n of r) propertyIsEnumerable.call(e, n) && t.push(n);\n    }\n    return t;\n  };\nfunction clone(e) {\n  return Array.isArray(e) ? cloneArray(e) : isOptionObject(e) ? cloneOptionObject(e) : e;\n}\nfunction cloneArray(e) {\n  const t = e.slice(0, 0);\n  return getEnumerableOwnPropertyKeys(e).forEach(r => {\n    defineProperty(t, r, clone(e[r]));\n  }), t;\n}\nfunction cloneOptionObject(e) {\n  const t = null === Object.getPrototypeOf(e) ? Object.create(null) : {};\n  return getEnumerableOwnPropertyKeys(e).forEach(r => {\n    defineProperty(t, r, clone(e[r]));\n  }), t;\n}\nconst mergeKeys = (e, t, r, n) => (r.forEach(r => {\n    void 0 === t[r] && n.ignoreUndefined || (r in e && e[r] !== Object.getPrototypeOf(e) ? defineProperty(e, r, merge(e[r], t[r], n)) : defineProperty(e, r, clone(t[r])));\n  }), e),\n  concatArrays = (e, t, r) => {\n    let n = e.slice(0, 0),\n      o = 0;\n    return [e, t].forEach(t => {\n      const i = [];\n      for (let r = 0; r < t.length; r++) hasOwnProperty.call(t, r) && (i.push(String(r)), defineProperty(n, o++, t === e ? t[r] : clone(t[r])));\n      n = mergeKeys(n, t, getEnumerableOwnPropertyKeys(t).filter(e => !i.includes(e)), r);\n    }), n;\n  };\nfunction merge(e, t, r) {\n  return r.concatArrays && Array.isArray(e) && Array.isArray(t) ? concatArrays(e, t, r) : isOptionObject(t) && isOptionObject(e) ? mergeKeys(e, t, getEnumerableOwnPropertyKeys(t), r) : clone(t);\n}\nvar mergeOptions = function () {\n  const t = merge(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);\n  let r = {\n    _: {}\n  };\n  for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    e[_key3] = arguments[_key3];\n  }\n  for (const n of e) if (void 0 !== n) {\n    if (!isOptionObject(n)) throw new TypeError(\"`\" + n + \"` is not an Option Object\");\n    r = merge(r, {\n      _: n\n    }, t);\n  }\n  return r._;\n};\nconst sha = e => async t => new Uint8Array(await crypto.subtle.digest(e, t)),\n  sha256 = from({\n    name: \"sha2-256\",\n    code: 18,\n    encode: sha(\"SHA-256\")\n  });\nfrom({\n  name: \"sha2-512\",\n  code: 19,\n  encode: sha(\"SHA-512\")\n});\nvar murmurHash3js = {\n    exports: {}\n  },\n  module,\n  exports;\nmodule = murmurHash3js, exports = murmurHash3js.exports, function (e, t) {\n  var r = {\n    version: \"3.0.0\",\n    x86: {},\n    x64: {},\n    inputValidation: !0\n  };\n  function n(e) {\n    if (!Array.isArray(e) && !ArrayBuffer.isView(e)) return !1;\n    for (var t = 0; t < e.length; t++) if (!Number.isInteger(e[t]) || e[t] < 0 || e[t] > 255) return !1;\n    return !0;\n  }\n  function o(e, t) {\n    return (65535 & e) * t + (((e >>> 16) * t & 65535) << 16);\n  }\n  function i(e, t) {\n    return e << t | e >>> 32 - t;\n  }\n  function s(e) {\n    return e = o(e ^= e >>> 16, 2246822507), e = o(e ^= e >>> 13, 3266489909), e ^= e >>> 16;\n  }\n  function a(e, t) {\n    e = [e[0] >>> 16, 65535 & e[0], e[1] >>> 16, 65535 & e[1]], t = [t[0] >>> 16, 65535 & t[0], t[1] >>> 16, 65535 & t[1]];\n    var r = [0, 0, 0, 0];\n    return r[3] += e[3] + t[3], r[2] += r[3] >>> 16, r[3] &= 65535, r[2] += e[2] + t[2], r[1] += r[2] >>> 16, r[2] &= 65535, r[1] += e[1] + t[1], r[0] += r[1] >>> 16, r[1] &= 65535, r[0] += e[0] + t[0], r[0] &= 65535, [r[0] << 16 | r[1], r[2] << 16 | r[3]];\n  }\n  function c(e, t) {\n    e = [e[0] >>> 16, 65535 & e[0], e[1] >>> 16, 65535 & e[1]], t = [t[0] >>> 16, 65535 & t[0], t[1] >>> 16, 65535 & t[1]];\n    var r = [0, 0, 0, 0];\n    return r[3] += e[3] * t[3], r[2] += r[3] >>> 16, r[3] &= 65535, r[2] += e[2] * t[3], r[1] += r[2] >>> 16, r[2] &= 65535, r[2] += e[3] * t[2], r[1] += r[2] >>> 16, r[2] &= 65535, r[1] += e[1] * t[3], r[0] += r[1] >>> 16, r[1] &= 65535, r[1] += e[2] * t[2], r[0] += r[1] >>> 16, r[1] &= 65535, r[1] += e[3] * t[1], r[0] += r[1] >>> 16, r[1] &= 65535, r[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0], r[0] &= 65535, [r[0] << 16 | r[1], r[2] << 16 | r[3]];\n  }\n  function u(e, t) {\n    return 32 == (t %= 64) ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32, [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t]);\n  }\n  function f(e, t) {\n    return 0 == (t %= 64) ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0];\n  }\n  function l(e, t) {\n    return [e[0] ^ t[0], e[1] ^ t[1]];\n  }\n  function h(e) {\n    return e = l(e, [0, e[0] >>> 1]), e = l(e = c(e, [4283543511, 3981806797]), [0, e[0] >>> 1]), e = l(e = c(e, [3301882366, 444984403]), [0, e[0] >>> 1]);\n  }\n  r.x86.hash32 = function (e, a) {\n    if (r.inputValidation && !n(e)) return t;\n    a = a || 0;\n    for (var c = e.length % 4, u = e.length - c, f = a, l = 0, h = 3432918353, d = 461845907, p = 0; p < u; p += 4) l = o(l = e[p] | e[p + 1] << 8 | e[p + 2] << 16 | e[p + 3] << 24, h), l = o(l = i(l, 15), d), f = o(f = i(f ^= l, 13), 5) + 3864292196;\n    switch (l = 0, c) {\n      case 3:\n        l ^= e[p + 2] << 16;\n      case 2:\n        l ^= e[p + 1] << 8;\n      case 1:\n        l = o(l ^= e[p], h), f ^= l = o(l = i(l, 15), d);\n    }\n    return (f = s(f ^= e.length)) >>> 0;\n  }, r.x86.hash128 = function (e, a) {\n    if (r.inputValidation && !n(e)) return t;\n    a = a || 0;\n    for (var c = e.length % 16, u = e.length - c, f = a, l = a, h = a, d = a, p = 0, y = 0, g = 0, b = 0, m = 597399067, w = 2869860233, _ = 951274213, T = 2716044179, E = 0; E < u; E += 16) p = e[E] | e[E + 1] << 8 | e[E + 2] << 16 | e[E + 3] << 24, y = e[E + 4] | e[E + 5] << 8 | e[E + 6] << 16 | e[E + 7] << 24, g = e[E + 8] | e[E + 9] << 8 | e[E + 10] << 16 | e[E + 11] << 24, b = e[E + 12] | e[E + 13] << 8 | e[E + 14] << 16 | e[E + 15] << 24, p = i(p = o(p, m), 15), f = i(f ^= p = o(p, w), 19), f = o(f += l, 5) + 1444728091, y = i(y = o(y, w), 16), l = i(l ^= y = o(y, _), 17), l = o(l += h, 5) + 197830471, g = i(g = o(g, _), 17), h = i(h ^= g = o(g, T), 15), h = o(h += d, 5) + 2530024501, b = i(b = o(b, T), 18), d = i(d ^= b = o(b, m), 13), d = o(d += f, 5) + 850148119;\n    switch (p = 0, y = 0, g = 0, b = 0, c) {\n      case 15:\n        b ^= e[E + 14] << 16;\n      case 14:\n        b ^= e[E + 13] << 8;\n      case 13:\n        b = o(b ^= e[E + 12], T), d ^= b = o(b = i(b, 18), m);\n      case 12:\n        g ^= e[E + 11] << 24;\n      case 11:\n        g ^= e[E + 10] << 16;\n      case 10:\n        g ^= e[E + 9] << 8;\n      case 9:\n        g = o(g ^= e[E + 8], _), h ^= g = o(g = i(g, 17), T);\n      case 8:\n        y ^= e[E + 7] << 24;\n      case 7:\n        y ^= e[E + 6] << 16;\n      case 6:\n        y ^= e[E + 5] << 8;\n      case 5:\n        y = o(y ^= e[E + 4], w), l ^= y = o(y = i(y, 16), _);\n      case 4:\n        p ^= e[E + 3] << 24;\n      case 3:\n        p ^= e[E + 2] << 16;\n      case 2:\n        p ^= e[E + 1] << 8;\n      case 1:\n        p = o(p ^= e[E], m), f ^= p = o(p = i(p, 15), w);\n    }\n    return f ^= e.length, f += l ^= e.length, f += h ^= e.length, l += f += d ^= e.length, h += f, d += f, f = s(f), f += l = s(l), f += h = s(h), l += f += d = s(d), h += f, d += f, (\"00000000\" + (f >>> 0).toString(16)).slice(-8) + (\"00000000\" + (l >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h >>> 0).toString(16)).slice(-8) + (\"00000000\" + (d >>> 0).toString(16)).slice(-8);\n  }, r.x64.hash128 = function (e, o) {\n    if (r.inputValidation && !n(e)) return t;\n    o = o || 0;\n    for (var i = e.length % 16, s = e.length - i, d = [0, o], p = [0, o], y = [0, 0], g = [0, 0], b = [2277735313, 289559509], m = [1291169091, 658871167], w = 0; w < s; w += 16) y = [e[w + 4] | e[w + 5] << 8 | e[w + 6] << 16 | e[w + 7] << 24, e[w] | e[w + 1] << 8 | e[w + 2] << 16 | e[w + 3] << 24], g = [e[w + 12] | e[w + 13] << 8 | e[w + 14] << 16 | e[w + 15] << 24, e[w + 8] | e[w + 9] << 8 | e[w + 10] << 16 | e[w + 11] << 24], y = u(y = c(y, b), 31), d = a(d = u(d = l(d, y = c(y, m)), 27), p), d = a(c(d, [0, 5]), [0, 1390208809]), g = u(g = c(g, m), 33), p = a(p = u(p = l(p, g = c(g, b)), 31), d), p = a(c(p, [0, 5]), [0, 944331445]);\n    switch (y = [0, 0], g = [0, 0], i) {\n      case 15:\n        g = l(g, f([0, e[w + 14]], 48));\n      case 14:\n        g = l(g, f([0, e[w + 13]], 40));\n      case 13:\n        g = l(g, f([0, e[w + 12]], 32));\n      case 12:\n        g = l(g, f([0, e[w + 11]], 24));\n      case 11:\n        g = l(g, f([0, e[w + 10]], 16));\n      case 10:\n        g = l(g, f([0, e[w + 9]], 8));\n      case 9:\n        g = c(g = l(g, [0, e[w + 8]]), m), p = l(p, g = c(g = u(g, 33), b));\n      case 8:\n        y = l(y, f([0, e[w + 7]], 56));\n      case 7:\n        y = l(y, f([0, e[w + 6]], 48));\n      case 6:\n        y = l(y, f([0, e[w + 5]], 40));\n      case 5:\n        y = l(y, f([0, e[w + 4]], 32));\n      case 4:\n        y = l(y, f([0, e[w + 3]], 24));\n      case 3:\n        y = l(y, f([0, e[w + 2]], 16));\n      case 2:\n        y = l(y, f([0, e[w + 1]], 8));\n      case 1:\n        y = c(y = l(y, [0, e[w]]), b), d = l(d, y = c(y = u(y, 31), m));\n    }\n    return d = a(d = l(d, [0, e.length]), p = l(p, [0, e.length])), p = a(p, d), d = a(d = h(d), p = h(p)), p = a(p, d), (\"00000000\" + (d[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (d[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (p[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (p[1] >>> 0).toString(16)).slice(-8);\n  }, module.exports && (exports = module.exports = r), exports.murmurHash3 = r;\n}();\nvar murmurhash3jsRevisited = murmurHash3js.exports;\nfunction fromNumberTo32BitBuf(e) {\n  const t = new Array(4);\n  for (let r = 0; r < 4; r++) t[r] = 255 & e, e >>= 8;\n  return new Uint8Array(t);\n}\nfrom({\n  name: \"murmur3-32\",\n  code: 35,\n  encode: e => fromNumberTo32BitBuf(murmurhash3jsRevisited.x86.hash32(e))\n});\nconst murmur3128 = from({\n  name: \"murmur3-128\",\n  code: 34,\n  encode: e => fromHex(murmurhash3jsRevisited.x64.hash128(e))\n});\nasync function hamtHashFn(e) {\n  return (await murmur3128.encode(e)).slice(0, 8).reverse();\n}\nconst defaultOptions = {\n  chunker: \"fixed\",\n  strategy: \"balanced\",\n  rawLeaves: !1,\n  onlyHash: !1,\n  reduceSingleLeafToSelf: !0,\n  hasher: sha256,\n  leafType: \"file\",\n  cidVersion: 0,\n  progress: () => () => {},\n  shardSplitThreshold: 1e3,\n  fileImportConcurrency: 50,\n  blockWriteConcurrency: 10,\n  minChunkSize: 262144,\n  maxChunkSize: 262144,\n  avgChunkSize: 262144,\n  window: 16,\n  polynomial: 0x3df305dfb2a804,\n  maxChildrenPerNode: 174,\n  layerRepeat: 4,\n  wrapWithDirectory: !1,\n  recursive: !1,\n  hidden: !1,\n  timeout: void 0,\n  hamtHashFn: hamtHashFn,\n  hamtHashCode: 34,\n  hamtBucketBits: 8\n};\nvar defaultOptions$1 = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return mergeOptions.bind({\n    ignoreUndefined: !0\n  })(defaultOptions, e);\n};\nfunction assign(e, t) {\n  for (const r in t) Object.defineProperty(e, r, {\n    value: t[r],\n    enumerable: !0,\n    configurable: !0\n  });\n  return e;\n}\nfunction createError(e, t, r) {\n  if (!e || \"string\" == typeof e) throw new TypeError(\"Please pass an Error to err-code\");\n  r || (r = {}), \"object\" == typeof t && (r = t, t = \"\"), t && (r.code = t);\n  try {\n    return assign(e, r);\n  } catch (t) {\n    r.message = e.message, r.stack = e.stack;\n    const n = function () {};\n    n.prototype = Object.create(Object.getPrototypeOf(e));\n    return assign(new n(), r);\n  }\n}\nvar errCode = createError,\n  indexMinimal = {},\n  minimal$1 = {},\n  aspromise = asPromise;\nfunction asPromise(e, t) {\n  for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) r[n++] = arguments[o++];\n  return new Promise(function (o, s) {\n    r[n] = function (e) {\n      if (i) if (i = !1, e) s(e);else {\n        for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) t[r++] = arguments[r];\n        o.apply(null, t);\n      }\n    };\n    try {\n      e.apply(t || null, r);\n    } catch (e) {\n      i && (i = !1, s(e));\n    }\n  });\n}\nvar base64$3 = {};\n!function (e) {\n  var t = base64$3;\n  t.length = function (e) {\n    var t = e.length;\n    if (!t) return 0;\n    for (var r = 0; --t % 4 > 1 && \"=\" === e.charAt(t);) ++r;\n    return Math.ceil(3 * e.length) / 4 - r;\n  };\n  for (var r = new Array(64), n = new Array(123), o = 0; o < 64;) n[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;\n  t.encode = function (e, t, n) {\n    for (var o, i = null, s = [], a = 0, c = 0; t < n;) {\n      var u = e[t++];\n      switch (c) {\n        case 0:\n          s[a++] = r[u >> 2], o = (3 & u) << 4, c = 1;\n          break;\n        case 1:\n          s[a++] = r[o | u >> 4], o = (15 & u) << 2, c = 2;\n          break;\n        case 2:\n          s[a++] = r[o | u >> 6], s[a++] = r[63 & u], c = 0;\n      }\n      a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);\n    }\n    return c && (s[a++] = r[o], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join(\"\")) : String.fromCharCode.apply(String, s.slice(0, a));\n  };\n  var i = \"invalid encoding\";\n  t.decode = function (e, t, r) {\n    for (var o, s = r, a = 0, c = 0; c < e.length;) {\n      var u = e.charCodeAt(c++);\n      if (61 === u && a > 1) break;\n      if (void 0 === (u = n[u])) throw Error(i);\n      switch (a) {\n        case 0:\n          o = u, a = 1;\n          break;\n        case 1:\n          t[r++] = o << 2 | (48 & u) >> 4, o = u, a = 2;\n          break;\n        case 2:\n          t[r++] = (15 & o) << 4 | (60 & u) >> 2, o = u, a = 3;\n          break;\n        case 3:\n          t[r++] = (3 & o) << 6 | u, a = 0;\n      }\n    }\n    if (1 === a) throw Error(i);\n    return r - s;\n  }, t.test = function (e) {\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);\n  };\n}();\nvar eventemitter = EventEmitter;\nfunction EventEmitter() {\n  this._listeners = {};\n}\nEventEmitter.prototype.on = function (e, t, r) {\n  return (this._listeners[e] || (this._listeners[e] = [])).push({\n    fn: t,\n    ctx: r || this\n  }), this;\n}, EventEmitter.prototype.off = function (e, t) {\n  if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) r[n].fn === t ? r.splice(n, 1) : ++n;\n  return this;\n}, EventEmitter.prototype.emit = function (e) {\n  var t = this._listeners[e];\n  if (t) {\n    for (var r = [], n = 1; n < arguments.length;) r.push(arguments[n++]);\n    for (n = 0; n < t.length;) t[n].fn.apply(t[n++].ctx, r);\n  }\n  return this;\n};\nvar float = factory(factory);\nfunction factory(e) {\n  return \"undefined\" != typeof Float32Array ? function () {\n    var t = new Float32Array([-0]),\n      r = new Uint8Array(t.buffer),\n      n = 128 === r[3];\n    function o(e, n, o) {\n      t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];\n    }\n    function i(e, n, o) {\n      t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];\n    }\n    function s(e, n) {\n      return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];\n    }\n    function a(e, n) {\n      return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];\n    }\n    e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;\n  }() : function () {\n    function t(e, t, r, n) {\n      var o = t < 0 ? 1 : 0;\n      if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {\n        var i = Math.floor(Math.log(t) / Math.LN2);\n        e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);\n      }\n    }\n    function r(e, t, r) {\n      var n = e(t, r),\n        o = 2 * (n >> 31) + 1,\n        i = n >>> 23 & 255,\n        s = 8388607 & n;\n      return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);\n    }\n    e.writeFloatLE = t.bind(null, writeUintLE), e.writeFloatBE = t.bind(null, writeUintBE), e.readFloatLE = r.bind(null, readUintLE), e.readFloatBE = r.bind(null, readUintBE);\n  }(), \"undefined\" != typeof Float64Array ? function () {\n    var t = new Float64Array([-0]),\n      r = new Uint8Array(t.buffer),\n      n = 128 === r[7];\n    function o(e, n, o) {\n      t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];\n    }\n    function i(e, n, o) {\n      t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];\n    }\n    function s(e, n) {\n      return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];\n    }\n    function a(e, n) {\n      return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];\n    }\n    e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;\n  }() : function () {\n    function t(e, t, r, n, o, i) {\n      var s = n < 0 ? 1 : 0;\n      if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {\n        var a;\n        if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {\n          var c = Math.floor(Math.log(n) / Math.LN2);\n          1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);\n        }\n      }\n    }\n    function r(e, t, r, n, o) {\n      var i = e(n, o + t),\n        s = e(n, o + r),\n        a = 2 * (s >> 31) + 1,\n        c = s >>> 20 & 2047,\n        u = 4294967296 * (1048575 & s) + i;\n      return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);\n    }\n    e.writeDoubleLE = t.bind(null, writeUintLE, 0, 4), e.writeDoubleBE = t.bind(null, writeUintBE, 4, 0), e.readDoubleLE = r.bind(null, readUintLE, 0, 4), e.readDoubleBE = r.bind(null, readUintBE, 4, 0);\n  }(), e;\n}\nfunction writeUintLE(e, t, r) {\n  t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;\n}\nfunction writeUintBE(e, t, r) {\n  t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;\n}\nfunction readUintLE(e, t) {\n  return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;\n}\nfunction readUintBE(e, t) {\n  return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;\n}\nvar inquire_1 = inquire;\nfunction inquire(moduleName) {\n  try {\n    var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n    if (mod && (mod.length || Object.keys(mod).length)) return mod;\n  } catch (e) {}\n  return null;\n}\nvar utf8$2 = {};\n!function (e) {\n  var t = utf8$2;\n  t.length = function (e) {\n    for (var t = 0, r = 0, n = 0; n < e.length; ++n) (r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;\n    return t;\n  }, t.read = function (e, t, r) {\n    if (r - t < 1) return \"\";\n    for (var n, o = null, i = [], s = 0; t < r;) (n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);\n    return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join(\"\")) : String.fromCharCode.apply(String, i.slice(0, s));\n  }, t.write = function (e, t, r) {\n    for (var n, o, i = r, s = 0; s < e.length; ++s) (n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);\n    return r - i;\n  };\n}();\nvar pool_1 = pool;\nfunction pool(e, t, r) {\n  var n = r || 8192,\n    o = n >>> 1,\n    i = null,\n    s = n;\n  return function (r) {\n    if (r < 1 || r > o) return e(r);\n    s + r > n && (i = e(n), s = 0);\n    var a = t.call(i, s, s += r);\n    return 7 & s && (s = 1 + (7 | s)), a;\n  };\n}\nvar longbits = LongBits$2,\n  util$5 = minimal$1;\nfunction LongBits$2(e, t) {\n  this.lo = e >>> 0, this.hi = t >>> 0;\n}\nvar zero = LongBits$2.zero = new LongBits$2(0, 0);\nzero.toNumber = function () {\n  return 0;\n}, zero.zzEncode = zero.zzDecode = function () {\n  return this;\n}, zero.length = function () {\n  return 1;\n};\nvar zeroHash = LongBits$2.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\nLongBits$2.fromNumber = function (e) {\n  if (0 === e) return zero;\n  var t = e < 0;\n  t && (e = -e);\n  var r = e >>> 0,\n    n = (e - r) / 4294967296 >>> 0;\n  return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new LongBits$2(r, n);\n}, LongBits$2.from = function (e) {\n  if (\"number\" == typeof e) return LongBits$2.fromNumber(e);\n  if (util$5.isString(e)) {\n    if (!util$5.Long) return LongBits$2.fromNumber(parseInt(e, 10));\n    e = util$5.Long.fromString(e);\n  }\n  return e.low || e.high ? new LongBits$2(e.low >>> 0, e.high >>> 0) : zero;\n}, LongBits$2.prototype.toNumber = function (e) {\n  if (!e && this.hi >>> 31) {\n    var t = 1 + ~this.lo >>> 0,\n      r = ~this.hi >>> 0;\n    return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);\n  }\n  return this.lo + 4294967296 * this.hi;\n}, LongBits$2.prototype.toLong = function (e) {\n  return util$5.Long ? new util$5.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : {\n    low: 0 | this.lo,\n    high: 0 | this.hi,\n    unsigned: Boolean(e)\n  };\n};\nvar charCodeAt = String.prototype.charCodeAt;\nLongBits$2.fromHash = function (e) {\n  return e === zeroHash ? zero : new LongBits$2((charCodeAt.call(e, 0) | charCodeAt.call(e, 1) << 8 | charCodeAt.call(e, 2) << 16 | charCodeAt.call(e, 3) << 24) >>> 0, (charCodeAt.call(e, 4) | charCodeAt.call(e, 5) << 8 | charCodeAt.call(e, 6) << 16 | charCodeAt.call(e, 7) << 24) >>> 0);\n}, LongBits$2.prototype.toHash = function () {\n  return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n}, LongBits$2.prototype.zzEncode = function () {\n  var e = this.hi >> 31;\n  return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;\n}, LongBits$2.prototype.zzDecode = function () {\n  var e = -(1 & this.lo);\n  return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;\n}, LongBits$2.prototype.length = function () {\n  var e = this.lo,\n    t = (this.lo >>> 28 | this.hi << 4) >>> 0,\n    r = this.hi >>> 24;\n  return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;\n}, function (e) {\n  var t = minimal$1;\n  function r(e, t, r) {\n    for (var n = Object.keys(t), o = 0; o < n.length; ++o) void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);\n    return e;\n  }\n  function n(e) {\n    function t(e, n) {\n      if (!(this instanceof t)) return new t(e, n);\n      Object.defineProperty(this, \"message\", {\n        get: function () {\n          return e;\n        }\n      }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, \"stack\", {\n        value: new Error().stack || \"\"\n      }), n && r(this, n);\n    }\n    return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, \"name\", {\n      get: function () {\n        return e;\n      }\n    }), t.prototype.toString = function () {\n      return this.name + \": \" + this.message;\n    }, t;\n  }\n  t.asPromise = aspromise, t.base64 = base64$3, t.EventEmitter = eventemitter, t.float = float, t.inquire = inquire_1, t.utf8 = utf8$2, t.pool = pool_1, t.LongBits = longbits, t.isNode = Boolean(void 0 !== commonjsGlobal && commonjsGlobal && commonjsGlobal.process && commonjsGlobal.process.versions && commonjsGlobal.process.versions.node), t.global = t.isNode && commonjsGlobal || \"undefined\" != typeof window && window || \"undefined\" != typeof self && self || commonjsGlobal, t.emptyArray = Object.freeze ? Object.freeze([]) : [], t.emptyObject = Object.freeze ? Object.freeze({}) : {}, t.isInteger = Number.isInteger || function (e) {\n    return \"number\" == typeof e && isFinite(e) && Math.floor(e) === e;\n  }, t.isString = function (e) {\n    return \"string\" == typeof e || e instanceof String;\n  }, t.isObject = function (e) {\n    return e && \"object\" == typeof e;\n  }, t.isset = t.isSet = function (e, t) {\n    var r = e[t];\n    return !(null == r || !e.hasOwnProperty(t)) && (\"object\" != typeof r || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);\n  }, t.Buffer = function () {\n    try {\n      var e = t.inquire(\"buffer\").Buffer;\n      return e.prototype.utf8Write ? e : null;\n    } catch (e) {\n      return null;\n    }\n  }(), t._Buffer_from = null, t._Buffer_allocUnsafe = null, t.newBuffer = function (e) {\n    return \"number\" == typeof e ? t.Buffer ? t._Buffer_allocUnsafe(e) : new t.Array(e) : t.Buffer ? t._Buffer_from(e) : \"undefined\" == typeof Uint8Array ? e : new Uint8Array(e);\n  }, t.Array = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, t.Long = t.global.dcodeIO && t.global.dcodeIO.Long || t.global.Long || t.inquire(\"long\"), t.key2Re = /^true|false|0|1$/, t.key32Re = /^-?(?:0|[1-9][0-9]*)$/, t.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, t.longToHash = function (e) {\n    return e ? t.LongBits.from(e).toHash() : t.LongBits.zeroHash;\n  }, t.longFromHash = function (e, r) {\n    var n = t.LongBits.fromHash(e);\n    return t.Long ? t.Long.fromBits(n.lo, n.hi, r) : n.toNumber(Boolean(r));\n  }, t.merge = r, t.lcFirst = function (e) {\n    return e.charAt(0).toLowerCase() + e.substring(1);\n  }, t.newError = n, t.ProtocolError = n(\"ProtocolError\"), t.oneOfGetter = function (e) {\n    for (var t = {}, r = 0; r < e.length; ++r) t[e[r]] = 1;\n    return function () {\n      for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];\n    };\n  }, t.oneOfSetter = function (e) {\n    return function (t) {\n      for (var r = 0; r < e.length; ++r) e[r] !== t && delete this[e[r]];\n    };\n  }, t.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: !0\n  }, t._configure = function () {\n    var e = t.Buffer;\n    e ? (t._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {\n      return new e(t, r);\n    }, t._Buffer_allocUnsafe = e.allocUnsafe || function (t) {\n      return new e(t);\n    }) : t._Buffer_from = t._Buffer_allocUnsafe = null;\n  };\n}();\nvar writer = Writer$1,\n  util$4 = minimal$1,\n  BufferWriter$1,\n  LongBits$1 = util$4.LongBits,\n  base64$2 = util$4.base64,\n  utf8$1 = util$4.utf8;\nfunction Op(e, t, r) {\n  this.fn = e, this.len = t, this.next = void 0, this.val = r;\n}\nfunction noop() {}\nfunction State(e) {\n  this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;\n}\nfunction Writer$1() {\n  this.len = 0, this.head = new Op(noop, 0, 0), this.tail = this.head, this.states = null;\n}\nvar create$2 = function () {\n  return util$4.Buffer ? function () {\n    return (Writer$1.create = function () {\n      return new BufferWriter$1();\n    })();\n  } : function () {\n    return new Writer$1();\n  };\n};\nfunction writeByte(e, t, r) {\n  t[r] = 255 & e;\n}\nfunction writeVarint32(e, t, r) {\n  for (; e > 127;) t[r++] = 127 & e | 128, e >>>= 7;\n  t[r] = e;\n}\nfunction VarintOp(e, t) {\n  this.len = e, this.next = void 0, this.val = t;\n}\nfunction writeVarint64(e, t, r) {\n  for (; e.hi;) t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;\n  for (; e.lo > 127;) t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;\n  t[r++] = e.lo;\n}\nfunction writeFixed32(e, t, r) {\n  t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;\n}\nWriter$1.create = create$2(), Writer$1.alloc = function (e) {\n  return new util$4.Array(e);\n}, util$4.Array !== Array && (Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray)), Writer$1.prototype._push = function (e, t, r) {\n  return this.tail = this.tail.next = new Op(e, t, r), this.len += t, this;\n}, VarintOp.prototype = Object.create(Op.prototype), VarintOp.prototype.fn = writeVarint32, Writer$1.prototype.uint32 = function (e) {\n  return this.len += (this.tail = this.tail.next = new VarintOp((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;\n}, Writer$1.prototype.int32 = function (e) {\n  return e < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(e)) : this.uint32(e);\n}, Writer$1.prototype.sint32 = function (e) {\n  return this.uint32((e << 1 ^ e >> 31) >>> 0);\n}, Writer$1.prototype.uint64 = function (e) {\n  var t = LongBits$1.from(e);\n  return this._push(writeVarint64, t.length(), t);\n}, Writer$1.prototype.int64 = Writer$1.prototype.uint64, Writer$1.prototype.sint64 = function (e) {\n  var t = LongBits$1.from(e).zzEncode();\n  return this._push(writeVarint64, t.length(), t);\n}, Writer$1.prototype.bool = function (e) {\n  return this._push(writeByte, 1, e ? 1 : 0);\n}, Writer$1.prototype.fixed32 = function (e) {\n  return this._push(writeFixed32, 4, e >>> 0);\n}, Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32, Writer$1.prototype.fixed64 = function (e) {\n  var t = LongBits$1.from(e);\n  return this._push(writeFixed32, 4, t.lo)._push(writeFixed32, 4, t.hi);\n}, Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64, Writer$1.prototype.float = function (e) {\n  return this._push(util$4.float.writeFloatLE, 4, e);\n}, Writer$1.prototype.double = function (e) {\n  return this._push(util$4.float.writeDoubleLE, 8, e);\n};\nvar writeBytes = util$4.Array.prototype.set ? function (e, t, r) {\n  t.set(e, r);\n} : function (e, t, r) {\n  for (var n = 0; n < e.length; ++n) t[r + n] = e[n];\n};\nWriter$1.prototype.bytes = function (e) {\n  var t = e.length >>> 0;\n  if (!t) return this._push(writeByte, 1, 0);\n  if (util$4.isString(e)) {\n    var r = Writer$1.alloc(t = base64$2.length(e));\n    base64$2.decode(e, r, 0), e = r;\n  }\n  return this.uint32(t)._push(writeBytes, t, e);\n}, Writer$1.prototype.string = function (e) {\n  var t = utf8$1.length(e);\n  return t ? this.uint32(t)._push(utf8$1.write, t, e) : this._push(writeByte, 1, 0);\n}, Writer$1.prototype.fork = function () {\n  return this.states = new State(this), this.head = this.tail = new Op(noop, 0, 0), this.len = 0, this;\n}, Writer$1.prototype.reset = function () {\n  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop, 0, 0), this.len = 0), this;\n}, Writer$1.prototype.ldelim = function () {\n  var e = this.head,\n    t = this.tail,\n    r = this.len;\n  return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;\n}, Writer$1.prototype.finish = function () {\n  for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) e.fn(e.val, t, r), r += e.len, e = e.next;\n  return t;\n}, Writer$1._configure = function (e) {\n  BufferWriter$1 = e, Writer$1.create = create$2(), BufferWriter$1._configure();\n};\nvar writer_buffer = BufferWriter,\n  Writer = writer;\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util$3 = minimal$1;\nfunction BufferWriter() {\n  Writer.call(this);\n}\nfunction writeStringBuffer(e, t, r) {\n  e.length < 40 ? util$3.utf8.write(e, t, r) : t.utf8Write ? t.utf8Write(e, r) : t.write(e, r);\n}\nBufferWriter._configure = function () {\n  BufferWriter.alloc = util$3._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && \"set\" === util$3.Buffer.prototype.set.name ? function (e, t, r) {\n    t.set(e, r);\n  } : function (e, t, r) {\n    if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) t[r++] = e[n++];\n  };\n}, BufferWriter.prototype.bytes = function (e) {\n  util$3.isString(e) && (e = util$3._Buffer_from(e, \"base64\"));\n  var t = e.length >>> 0;\n  return this.uint32(t), t && this._push(BufferWriter.writeBytesBuffer, t, e), this;\n}, BufferWriter.prototype.string = function (e) {\n  var t = util$3.Buffer.byteLength(e);\n  return this.uint32(t), t && this._push(writeStringBuffer, t, e), this;\n}, BufferWriter._configure();\nvar reader = Reader$1,\n  util$2 = minimal$1,\n  BufferReader$1,\n  LongBits = util$2.LongBits,\n  utf8 = util$2.utf8;\nfunction indexOutOfRange(e, t) {\n  return RangeError(\"index out of range: \" + e.pos + \" + \" + (t || 1) + \" > \" + e.len);\n}\nfunction Reader$1(e) {\n  this.buf = e, this.pos = 0, this.len = e.length;\n}\nvar create_array = \"undefined\" != typeof Uint8Array ? function (e) {\n    if (e instanceof Uint8Array || Array.isArray(e)) return new Reader$1(e);\n    throw Error(\"illegal buffer\");\n  } : function (e) {\n    if (Array.isArray(e)) return new Reader$1(e);\n    throw Error(\"illegal buffer\");\n  },\n  create$1 = function () {\n    return util$2.Buffer ? function (e) {\n      return (Reader$1.create = function (e) {\n        return util$2.Buffer.isBuffer(e) ? new BufferReader$1(e) : create_array(e);\n      })(e);\n    } : create_array;\n  },\n  value;\nfunction readLongVarint() {\n  var e = new LongBits(0, 0),\n    t = 0;\n  if (!(this.len - this.pos > 4)) {\n    for (; t < 3; ++t) {\n      if (this.pos >= this.len) throw indexOutOfRange(this);\n      if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;\n    }\n    return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;\n  }\n  for (; t < 4; ++t) if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;\n  if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;\n  if (t = 0, this.len - this.pos > 4) {\n    for (; t < 5; ++t) if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n  } else for (; t < 5; ++t) {\n    if (this.pos >= this.len) throw indexOutOfRange(this);\n    if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;\n  }\n  throw Error(\"invalid varint encoding\");\n}\nfunction readFixed32_end(e, t) {\n  return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;\n}\nfunction readFixed64() {\n  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\nReader$1.create = create$1(), Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice, Reader$1.prototype.uint32 = (value = 4294967295, function () {\n  if (value = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return value;\n  if (value = (value | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return value;\n  if (value = (value | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return value;\n  if (value = (value | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return value;\n  if (value = (value | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return value;\n  if ((this.pos += 5) > this.len) throw this.pos = this.len, indexOutOfRange(this, 10);\n  return value;\n}), Reader$1.prototype.int32 = function () {\n  return 0 | this.uint32();\n}, Reader$1.prototype.sint32 = function () {\n  var e = this.uint32();\n  return e >>> 1 ^ -(1 & e) | 0;\n}, Reader$1.prototype.bool = function () {\n  return 0 !== this.uint32();\n}, Reader$1.prototype.fixed32 = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n  return readFixed32_end(this.buf, this.pos += 4);\n}, Reader$1.prototype.sfixed32 = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n  return 0 | readFixed32_end(this.buf, this.pos += 4);\n}, Reader$1.prototype.float = function () {\n  if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n  var e = util$2.float.readFloatLE(this.buf, this.pos);\n  return this.pos += 4, e;\n}, Reader$1.prototype.double = function () {\n  if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n  var e = util$2.float.readDoubleLE(this.buf, this.pos);\n  return this.pos += 8, e;\n}, Reader$1.prototype.bytes = function () {\n  var e = this.uint32(),\n    t = this.pos,\n    r = this.pos + e;\n  if (r > this.len) throw indexOutOfRange(this, e);\n  return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);\n}, Reader$1.prototype.string = function () {\n  var e = this.bytes();\n  return utf8.read(e, 0, e.length);\n}, Reader$1.prototype.skip = function (e) {\n  if (\"number\" == typeof e) {\n    if (this.pos + e > this.len) throw indexOutOfRange(this, e);\n    this.pos += e;\n  } else do {\n    if (this.pos >= this.len) throw indexOutOfRange(this);\n  } while (128 & this.buf[this.pos++]);\n  return this;\n}, Reader$1.prototype.skipType = function (e) {\n  switch (e) {\n    case 0:\n      this.skip();\n      break;\n    case 1:\n      this.skip(8);\n      break;\n    case 2:\n      this.skip(this.uint32());\n      break;\n    case 3:\n      for (; 4 != (e = 7 & this.uint32());) this.skipType(e);\n      break;\n    case 5:\n      this.skip(4);\n      break;\n    default:\n      throw Error(\"invalid wire type \" + e + \" at offset \" + this.pos);\n  }\n  return this;\n}, Reader$1._configure = function (e) {\n  BufferReader$1 = e, Reader$1.create = create$1(), BufferReader$1._configure();\n  var t = util$2.Long ? \"toLong\" : \"toNumber\";\n  util$2.merge(Reader$1.prototype, {\n    int64: function () {\n      return readLongVarint.call(this)[t](!1);\n    },\n    uint64: function () {\n      return readLongVarint.call(this)[t](!0);\n    },\n    sint64: function () {\n      return readLongVarint.call(this).zzDecode()[t](!1);\n    },\n    fixed64: function () {\n      return readFixed64.call(this)[t](!0);\n    },\n    sfixed64: function () {\n      return readFixed64.call(this)[t](!1);\n    }\n  });\n};\nvar reader_buffer = BufferReader,\n  Reader = reader;\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util$1 = minimal$1;\nfunction BufferReader(e) {\n  Reader.call(this, e);\n}\nBufferReader._configure = function () {\n  util$1.Buffer && (BufferReader.prototype._slice = util$1.Buffer.prototype.slice);\n}, BufferReader.prototype.string = function () {\n  var e = this.uint32();\n  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + e, this.len));\n}, BufferReader._configure();\nvar rpc = {},\n  service = Service,\n  util = minimal$1;\nfunction Service(e, t, r) {\n  if (\"function\" != typeof e) throw TypeError(\"rpcImpl must be a function\");\n  util.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);\n}\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service, Service.prototype.rpcCall = function e(t, r, n, o, i) {\n  if (!o) throw TypeError(\"request must be specified\");\n  var s = this;\n  if (!i) return util.asPromise(e, s, t, r, n, o);\n  if (s.rpcImpl) try {\n    return s.rpcImpl(t, r[s.requestDelimited ? \"encodeDelimited\" : \"encode\"](o).finish(), function (e, r) {\n      if (e) return s.emit(\"error\", e, t), i(e);\n      if (null !== r) {\n        if (!(r instanceof n)) try {\n          r = n[s.responseDelimited ? \"decodeDelimited\" : \"decode\"](r);\n        } catch (e) {\n          return s.emit(\"error\", e, t), i(e);\n        }\n        return s.emit(\"data\", r, t), i(null, r);\n      }\n      s.end(!0);\n    });\n  } catch (e) {\n    return s.emit(\"error\", e, t), void setTimeout(function () {\n      i(e);\n    }, 0);\n  } else setTimeout(function () {\n    i(Error(\"already ended\"));\n  }, 0);\n}, Service.prototype.end = function (e) {\n  return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit(\"end\").off()), this;\n}, function (e) {\n  e.Service = service;\n}(rpc);\nvar roots = {};\n!function (e) {\n  var t = indexMinimal;\n  function r() {\n    t.util._configure(), t.Writer._configure(t.BufferWriter), t.Reader._configure(t.BufferReader);\n  }\n  t.build = \"minimal\", t.Writer = writer, t.BufferWriter = writer_buffer, t.Reader = reader, t.BufferReader = reader_buffer, t.util = minimal$1, t.rpc = rpc, t.roots = roots, t.configure = r, r();\n}();\nvar minimal = indexMinimal;\nconst $Reader = minimal.Reader,\n  $Writer = minimal.Writer,\n  $util = minimal.util,\n  $root = minimal.roots[\"ipfs-unixfs\"] || (minimal.roots[\"ipfs-unixfs\"] = {}),\n  Data = $root.Data = (() => {\n    function e(e) {\n      if (this.blocksizes = [], e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) null != e[t[r]] && (this[t[r]] = e[t[r]]);\n    }\n    return e.prototype.Type = 0, e.prototype.Data = $util.newBuffer([]), e.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0, e.prototype.blocksizes = $util.emptyArray, e.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0, e.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, !0) : 0, e.prototype.mode = 0, e.prototype.mtime = null, e.encode = function (e, t) {\n      if (t || (t = $Writer.create()), t.uint32(8).int32(e.Type), null != e.Data && Object.hasOwnProperty.call(e, \"Data\") && t.uint32(18).bytes(e.Data), null != e.filesize && Object.hasOwnProperty.call(e, \"filesize\") && t.uint32(24).uint64(e.filesize), null != e.blocksizes && e.blocksizes.length) for (var r = 0; r < e.blocksizes.length; ++r) t.uint32(32).uint64(e.blocksizes[r]);\n      return null != e.hashType && Object.hasOwnProperty.call(e, \"hashType\") && t.uint32(40).uint64(e.hashType), null != e.fanout && Object.hasOwnProperty.call(e, \"fanout\") && t.uint32(48).uint64(e.fanout), null != e.mode && Object.hasOwnProperty.call(e, \"mode\") && t.uint32(56).uint32(e.mode), null != e.mtime && Object.hasOwnProperty.call(e, \"mtime\") && $root.UnixTime.encode(e.mtime, t.uint32(66).fork()).ldelim(), t;\n    }, e.decode = function (e, t) {\n      e instanceof $Reader || (e = $Reader.create(e));\n      for (var r = void 0 === t ? e.len : e.pos + t, n = new $root.Data(); e.pos < r;) {\n        var o = e.uint32();\n        switch (o >>> 3) {\n          case 1:\n            n.Type = e.int32();\n            break;\n          case 2:\n            n.Data = e.bytes();\n            break;\n          case 3:\n            n.filesize = e.uint64();\n            break;\n          case 4:\n            if (n.blocksizes && n.blocksizes.length || (n.blocksizes = []), 2 == (7 & o)) for (var i = e.uint32() + e.pos; e.pos < i;) n.blocksizes.push(e.uint64());else n.blocksizes.push(e.uint64());\n            break;\n          case 5:\n            n.hashType = e.uint64();\n            break;\n          case 6:\n            n.fanout = e.uint64();\n            break;\n          case 7:\n            n.mode = e.uint32();\n            break;\n          case 8:\n            n.mtime = $root.UnixTime.decode(e, e.uint32());\n            break;\n          default:\n            e.skipType(7 & o);\n        }\n      }\n      if (!n.hasOwnProperty(\"Type\")) throw $util.ProtocolError(\"missing required 'Type'\", {\n        instance: n\n      });\n      return n;\n    }, e.fromObject = function (e) {\n      if (e instanceof $root.Data) return e;\n      var t = new $root.Data();\n      switch (e.Type) {\n        case \"Raw\":\n        case 0:\n          t.Type = 0;\n          break;\n        case \"Directory\":\n        case 1:\n          t.Type = 1;\n          break;\n        case \"File\":\n        case 2:\n          t.Type = 2;\n          break;\n        case \"Metadata\":\n        case 3:\n          t.Type = 3;\n          break;\n        case \"Symlink\":\n        case 4:\n          t.Type = 4;\n          break;\n        case \"HAMTShard\":\n        case 5:\n          t.Type = 5;\n      }\n      if (null != e.Data && (\"string\" == typeof e.Data ? $util.base64.decode(e.Data, t.Data = $util.newBuffer($util.base64.length(e.Data)), 0) : e.Data.length && (t.Data = e.Data)), null != e.filesize && ($util.Long ? (t.filesize = $util.Long.fromValue(e.filesize)).unsigned = !0 : \"string\" == typeof e.filesize ? t.filesize = parseInt(e.filesize, 10) : \"number\" == typeof e.filesize ? t.filesize = e.filesize : \"object\" == typeof e.filesize && (t.filesize = new $util.LongBits(e.filesize.low >>> 0, e.filesize.high >>> 0).toNumber(!0))), e.blocksizes) {\n        if (!Array.isArray(e.blocksizes)) throw TypeError(\".Data.blocksizes: array expected\");\n        t.blocksizes = [];\n        for (var r = 0; r < e.blocksizes.length; ++r) $util.Long ? (t.blocksizes[r] = $util.Long.fromValue(e.blocksizes[r])).unsigned = !0 : \"string\" == typeof e.blocksizes[r] ? t.blocksizes[r] = parseInt(e.blocksizes[r], 10) : \"number\" == typeof e.blocksizes[r] ? t.blocksizes[r] = e.blocksizes[r] : \"object\" == typeof e.blocksizes[r] && (t.blocksizes[r] = new $util.LongBits(e.blocksizes[r].low >>> 0, e.blocksizes[r].high >>> 0).toNumber(!0));\n      }\n      if (null != e.hashType && ($util.Long ? (t.hashType = $util.Long.fromValue(e.hashType)).unsigned = !0 : \"string\" == typeof e.hashType ? t.hashType = parseInt(e.hashType, 10) : \"number\" == typeof e.hashType ? t.hashType = e.hashType : \"object\" == typeof e.hashType && (t.hashType = new $util.LongBits(e.hashType.low >>> 0, e.hashType.high >>> 0).toNumber(!0))), null != e.fanout && ($util.Long ? (t.fanout = $util.Long.fromValue(e.fanout)).unsigned = !0 : \"string\" == typeof e.fanout ? t.fanout = parseInt(e.fanout, 10) : \"number\" == typeof e.fanout ? t.fanout = e.fanout : \"object\" == typeof e.fanout && (t.fanout = new $util.LongBits(e.fanout.low >>> 0, e.fanout.high >>> 0).toNumber(!0))), null != e.mode && (t.mode = e.mode >>> 0), null != e.mtime) {\n        if (\"object\" != typeof e.mtime) throw TypeError(\".Data.mtime: object expected\");\n        t.mtime = $root.UnixTime.fromObject(e.mtime);\n      }\n      return t;\n    }, e.toObject = function (e, t) {\n      t || (t = {});\n      var r = {};\n      if ((t.arrays || t.defaults) && (r.blocksizes = []), t.defaults) {\n        if (r.Type = t.enums === String ? \"Raw\" : 0, t.bytes === String ? r.Data = \"\" : (r.Data = [], t.bytes !== Array && (r.Data = $util.newBuffer(r.Data))), $util.Long) {\n          var n = new $util.Long(0, 0, !0);\n          r.filesize = t.longs === String ? n.toString() : t.longs === Number ? n.toNumber() : n;\n        } else r.filesize = t.longs === String ? \"0\" : 0;\n        if ($util.Long) {\n          n = new $util.Long(0, 0, !0);\n          r.hashType = t.longs === String ? n.toString() : t.longs === Number ? n.toNumber() : n;\n        } else r.hashType = t.longs === String ? \"0\" : 0;\n        if ($util.Long) {\n          n = new $util.Long(0, 0, !0);\n          r.fanout = t.longs === String ? n.toString() : t.longs === Number ? n.toNumber() : n;\n        } else r.fanout = t.longs === String ? \"0\" : 0;\n        r.mode = 0, r.mtime = null;\n      }\n      if (null != e.Type && e.hasOwnProperty(\"Type\") && (r.Type = t.enums === String ? $root.Data.DataType[e.Type] : e.Type), null != e.Data && e.hasOwnProperty(\"Data\") && (r.Data = t.bytes === String ? $util.base64.encode(e.Data, 0, e.Data.length) : t.bytes === Array ? Array.prototype.slice.call(e.Data) : e.Data), null != e.filesize && e.hasOwnProperty(\"filesize\") && (\"number\" == typeof e.filesize ? r.filesize = t.longs === String ? String(e.filesize) : e.filesize : r.filesize = t.longs === String ? $util.Long.prototype.toString.call(e.filesize) : t.longs === Number ? new $util.LongBits(e.filesize.low >>> 0, e.filesize.high >>> 0).toNumber(!0) : e.filesize), e.blocksizes && e.blocksizes.length) {\n        r.blocksizes = [];\n        for (var o = 0; o < e.blocksizes.length; ++o) \"number\" == typeof e.blocksizes[o] ? r.blocksizes[o] = t.longs === String ? String(e.blocksizes[o]) : e.blocksizes[o] : r.blocksizes[o] = t.longs === String ? $util.Long.prototype.toString.call(e.blocksizes[o]) : t.longs === Number ? new $util.LongBits(e.blocksizes[o].low >>> 0, e.blocksizes[o].high >>> 0).toNumber(!0) : e.blocksizes[o];\n      }\n      return null != e.hashType && e.hasOwnProperty(\"hashType\") && (\"number\" == typeof e.hashType ? r.hashType = t.longs === String ? String(e.hashType) : e.hashType : r.hashType = t.longs === String ? $util.Long.prototype.toString.call(e.hashType) : t.longs === Number ? new $util.LongBits(e.hashType.low >>> 0, e.hashType.high >>> 0).toNumber(!0) : e.hashType), null != e.fanout && e.hasOwnProperty(\"fanout\") && (\"number\" == typeof e.fanout ? r.fanout = t.longs === String ? String(e.fanout) : e.fanout : r.fanout = t.longs === String ? $util.Long.prototype.toString.call(e.fanout) : t.longs === Number ? new $util.LongBits(e.fanout.low >>> 0, e.fanout.high >>> 0).toNumber(!0) : e.fanout), null != e.mode && e.hasOwnProperty(\"mode\") && (r.mode = e.mode), null != e.mtime && e.hasOwnProperty(\"mtime\") && (r.mtime = $root.UnixTime.toObject(e.mtime, t)), r;\n    }, e.prototype.toJSON = function () {\n      return this.constructor.toObject(this, minimal.util.toJSONOptions);\n    }, e.DataType = function () {\n      const e = {},\n        t = Object.create(e);\n      return t[e[0] = \"Raw\"] = 0, t[e[1] = \"Directory\"] = 1, t[e[2] = \"File\"] = 2, t[e[3] = \"Metadata\"] = 3, t[e[4] = \"Symlink\"] = 4, t[e[5] = \"HAMTShard\"] = 5, t;\n    }(), e;\n  })();\n$root.UnixTime = (() => {\n  function e(e) {\n    if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) null != e[t[r]] && (this[t[r]] = e[t[r]]);\n  }\n  return e.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, !1) : 0, e.prototype.FractionalNanoseconds = 0, e.encode = function (e, t) {\n    return t || (t = $Writer.create()), t.uint32(8).int64(e.Seconds), null != e.FractionalNanoseconds && Object.hasOwnProperty.call(e, \"FractionalNanoseconds\") && t.uint32(21).fixed32(e.FractionalNanoseconds), t;\n  }, e.decode = function (e, t) {\n    e instanceof $Reader || (e = $Reader.create(e));\n    for (var r = void 0 === t ? e.len : e.pos + t, n = new $root.UnixTime(); e.pos < r;) {\n      var o = e.uint32();\n      switch (o >>> 3) {\n        case 1:\n          n.Seconds = e.int64();\n          break;\n        case 2:\n          n.FractionalNanoseconds = e.fixed32();\n          break;\n        default:\n          e.skipType(7 & o);\n      }\n    }\n    if (!n.hasOwnProperty(\"Seconds\")) throw $util.ProtocolError(\"missing required 'Seconds'\", {\n      instance: n\n    });\n    return n;\n  }, e.fromObject = function (e) {\n    if (e instanceof $root.UnixTime) return e;\n    var t = new $root.UnixTime();\n    return null != e.Seconds && ($util.Long ? (t.Seconds = $util.Long.fromValue(e.Seconds)).unsigned = !1 : \"string\" == typeof e.Seconds ? t.Seconds = parseInt(e.Seconds, 10) : \"number\" == typeof e.Seconds ? t.Seconds = e.Seconds : \"object\" == typeof e.Seconds && (t.Seconds = new $util.LongBits(e.Seconds.low >>> 0, e.Seconds.high >>> 0).toNumber())), null != e.FractionalNanoseconds && (t.FractionalNanoseconds = e.FractionalNanoseconds >>> 0), t;\n  }, e.toObject = function (e, t) {\n    t || (t = {});\n    var r = {};\n    if (t.defaults) {\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, !1);\n        r.Seconds = t.longs === String ? n.toString() : t.longs === Number ? n.toNumber() : n;\n      } else r.Seconds = t.longs === String ? \"0\" : 0;\n      r.FractionalNanoseconds = 0;\n    }\n    return null != e.Seconds && e.hasOwnProperty(\"Seconds\") && (\"number\" == typeof e.Seconds ? r.Seconds = t.longs === String ? String(e.Seconds) : e.Seconds : r.Seconds = t.longs === String ? $util.Long.prototype.toString.call(e.Seconds) : t.longs === Number ? new $util.LongBits(e.Seconds.low >>> 0, e.Seconds.high >>> 0).toNumber() : e.Seconds), null != e.FractionalNanoseconds && e.hasOwnProperty(\"FractionalNanoseconds\") && (r.FractionalNanoseconds = e.FractionalNanoseconds), r;\n  }, e.prototype.toJSON = function () {\n    return this.constructor.toObject(this, minimal.util.toJSONOptions);\n  }, e;\n})(), $root.Metadata = (() => {\n  function e(e) {\n    if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) null != e[t[r]] && (this[t[r]] = e[t[r]]);\n  }\n  return e.prototype.MimeType = \"\", e.encode = function (e, t) {\n    return t || (t = $Writer.create()), null != e.MimeType && Object.hasOwnProperty.call(e, \"MimeType\") && t.uint32(10).string(e.MimeType), t;\n  }, e.decode = function (e, t) {\n    e instanceof $Reader || (e = $Reader.create(e));\n    for (var r = void 0 === t ? e.len : e.pos + t, n = new $root.Metadata(); e.pos < r;) {\n      var o = e.uint32();\n      if (o >>> 3 == 1) n.MimeType = e.string();else e.skipType(7 & o);\n    }\n    return n;\n  }, e.fromObject = function (e) {\n    if (e instanceof $root.Metadata) return e;\n    var t = new $root.Metadata();\n    return null != e.MimeType && (t.MimeType = String(e.MimeType)), t;\n  }, e.toObject = function (e, t) {\n    t || (t = {});\n    var r = {};\n    return t.defaults && (r.MimeType = \"\"), null != e.MimeType && e.hasOwnProperty(\"MimeType\") && (r.MimeType = e.MimeType), r;\n  }, e.prototype.toJSON = function () {\n    return this.constructor.toObject(this, minimal.util.toJSONOptions);\n  }, e;\n})();\nconst PBData = Data,\n  types = [\"raw\", \"directory\", \"file\", \"metadata\", \"symlink\", \"hamt-sharded-directory\"],\n  dirTypes = [\"directory\", \"hamt-sharded-directory\"],\n  DEFAULT_FILE_MODE = parseInt(\"0644\", 8),\n  DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8);\nfunction parseMode(e) {\n  if (null != e) return \"number\" == typeof e ? 4095 & e : \"0\" === (e = e.toString()).substring(0, 1) ? 4095 & parseInt(e, 8) : 4095 & parseInt(e, 10);\n}\nfunction parseMtime(e) {\n  if (null == e) return;\n  let t;\n  if (null != e.secs && (t = {\n    secs: e.secs,\n    nsecs: e.nsecs\n  }), null != e.Seconds && (t = {\n    secs: e.Seconds,\n    nsecs: e.FractionalNanoseconds\n  }), Array.isArray(e) && (t = {\n    secs: e[0],\n    nsecs: e[1]\n  }), e instanceof Date) {\n    const r = e.getTime(),\n      n = Math.floor(r / 1e3);\n    t = {\n      secs: n,\n      nsecs: 1e3 * (r - 1e3 * n)\n    };\n  }\n  if (Object.prototype.hasOwnProperty.call(t, \"secs\")) {\n    if (null != t && null != t.nsecs && (t.nsecs < 0 || t.nsecs > 999999999)) throw errCode(new Error(\"mtime-nsecs must be within the range [0,999999999]\"), \"ERR_INVALID_MTIME_NSECS\");\n    return t;\n  }\n}\nclass UnixFS {\n  static unmarshal(e) {\n    const t = PBData.decode(e),\n      r = PBData.toObject(t, {\n        defaults: !1,\n        arrays: !0,\n        longs: Number,\n        objects: !1\n      }),\n      n = new UnixFS({\n        type: types[r.Type],\n        data: r.Data,\n        blockSizes: r.blocksizes,\n        mode: r.mode,\n        mtime: r.mtime ? {\n          secs: r.mtime.Seconds,\n          nsecs: r.mtime.FractionalNanoseconds\n        } : void 0\n      });\n    return n._originalMode = r.mode || 0, n;\n  }\n  constructor() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      type: \"file\"\n    };\n    const {\n      type: t,\n      data: r,\n      blockSizes: n,\n      hashType: o,\n      fanout: i,\n      mtime: s,\n      mode: a\n    } = e;\n    if (t && !types.includes(t)) throw errCode(new Error(\"Type: \" + t + \" is not valid\"), \"ERR_INVALID_TYPE\");\n    this.type = t || \"file\", this.data = r, this.hashType = o, this.fanout = i, this.blockSizes = n || [], this._originalMode = 0, this.mode = parseMode(a), s && (this.mtime = parseMtime(s), this.mtime && !this.mtime.nsecs && (this.mtime.nsecs = 0));\n  }\n  set mode(e) {\n    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n    const t = parseMode(e);\n    void 0 !== t && (this._mode = t);\n  }\n  get mode() {\n    return this._mode;\n  }\n  isDirectory() {\n    return Boolean(this.type && dirTypes.includes(this.type));\n  }\n  addBlockSize(e) {\n    this.blockSizes.push(e);\n  }\n  removeBlockSize(e) {\n    this.blockSizes.splice(e, 1);\n  }\n  fileSize() {\n    if (this.isDirectory()) return 0;\n    let e = 0;\n    return this.blockSizes.forEach(t => {\n      e += t;\n    }), this.data && (e += this.data.length), e;\n  }\n  marshal() {\n    let e;\n    switch (this.type) {\n      case \"raw\":\n        e = PBData.DataType.Raw;\n        break;\n      case \"directory\":\n        e = PBData.DataType.Directory;\n        break;\n      case \"file\":\n        e = PBData.DataType.File;\n        break;\n      case \"metadata\":\n        e = PBData.DataType.Metadata;\n        break;\n      case \"symlink\":\n        e = PBData.DataType.Symlink;\n        break;\n      case \"hamt-sharded-directory\":\n        e = PBData.DataType.HAMTShard;\n        break;\n      default:\n        throw errCode(new Error(\"Type: \" + e + \" is not valid\"), \"ERR_INVALID_TYPE\");\n    }\n    let t,\n      r,\n      n = this.data;\n    if (this.data && this.data.length || (n = void 0), null != this.mode && (t = 4294963200 & this._originalMode | (parseMode(this.mode) || 0), t !== DEFAULT_FILE_MODE || this.isDirectory() || (t = void 0), t === DEFAULT_DIRECTORY_MODE && this.isDirectory() && (t = void 0)), null != this.mtime) {\n      const e = parseMtime(this.mtime);\n      e && (r = {\n        Seconds: e.secs,\n        FractionalNanoseconds: e.nsecs\n      }, 0 === r.FractionalNanoseconds && delete r.FractionalNanoseconds);\n    }\n    const o = {\n      Type: e,\n      Data: n,\n      filesize: this.isDirectory() ? void 0 : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode: t,\n      mtime: r\n    };\n    return PBData.encode(o).finish();\n  }\n}\nconst persist = async (e, t, r) => {\n    r.codec || (r.codec = dagPb), r.hasher || (r.hasher = sha256), void 0 === r.cidVersion && (r.cidVersion = 1), r.codec === dagPb && r.hasher !== sha256 && (r.cidVersion = 1);\n    const n = await r.hasher.digest(e),\n      o = CID.create(r.cidVersion, r.codec.code, n);\n    return r.onlyHash || (await t.put(o, e, {\n      signal: r.signal\n    })), o;\n  },\n  dirBuilder = async (e, t, r) => {\n    const n = new UnixFS({\n        type: \"directory\",\n        mtime: e.mtime,\n        mode: e.mode\n      }),\n      o = encode$2(prepare({\n        Data: n.marshal()\n      }));\n    return {\n      cid: await persist(o, t, r),\n      path: e.path,\n      unixfs: n,\n      size: o.length\n    };\n  },\n  all = async e => {\n    const t = [];\n    for await (const r of e) t.push(r);\n    return t;\n  };\nvar itAll = all;\nasync function flat(e, t) {\n  return t(await itAll(e));\n}\nfunction balanced(e, t, r) {\n  return reduceToParents(e, t, r);\n}\nasync function reduceToParents(e, t, r) {\n  const n = [];\n  for await (const o of itBatch(e, r.maxChildrenPerNode)) n.push(await t(o));\n  return n.length > 1 ? reduceToParents(n, t, r) : n[0];\n}\nasync function trickleStream(e, t, r) {\n  const n = new Root(r.layerRepeat);\n  let o = 0,\n    i = 1,\n    s = n;\n  for await (const a of itBatch(e, r.maxChildrenPerNode)) s.isFull() && (s !== n && n.addChild(await s.reduce(t)), o && o % r.layerRepeat == 0 && i++, s = new SubTree(i, r.layerRepeat, o), o++), s.append(a);\n  return s && s !== n && n.addChild(await s.reduce(t)), n.reduce(t);\n}\nclass SubTree {\n  constructor(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.maxDepth = e, this.layerRepeat = t, this.currentDepth = 1, this.iteration = r, this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth: e,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n  isFull() {\n    if (!this.root.data) return !1;\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) return this._addNextNodeToParent(this.node), !1;\n    const e = this._findParent(this.node, this.currentDepth);\n    return !e || (this._addNextNodeToParent(e), !1);\n  }\n  _addNextNodeToParent(e) {\n    this.parent = e;\n    const t = {\n      children: [],\n      depth: e.depth + 1,\n      parent: e,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(e.children.length / this.layerRepeat) * this.layerRepeat\n    };\n    e.children.push(t), this.currentDepth = t.depth, this.node = t;\n  }\n  append(e) {\n    this.node.data = e;\n  }\n  reduce(e) {\n    return this._reduce(this.root, e);\n  }\n  async _reduce(e, t) {\n    let r = [];\n    return e.children.length && (r = await Promise.all(e.children.filter(e => e.data).map(e => this._reduce(e, t)))), t((e.data || []).concat(r));\n  }\n  _findParent(e, t) {\n    const r = e.parent;\n    if (r && 0 !== r.depth) return r.children.length !== r.maxChildren && r.maxChildren ? r : this._findParent(r, t);\n  }\n}\nclass Root extends SubTree {\n  constructor(e) {\n    super(0, e), this.root.depth = 0, this.currentDepth = 1;\n  }\n  addChild(e) {\n    this.root.children.push(e);\n  }\n  reduce(e) {\n    return e((this.root.data || []).concat(this.root.children));\n  }\n}\nasync function* bufferImporter(e, t, r) {\n  for await (let n of e.content) yield async () => {\n    let o;\n    r.progress(n.length, e.path);\n    const i = {\n      codec: dagPb,\n      cidVersion: r.cidVersion,\n      hasher: r.hasher,\n      onlyHash: r.onlyHash\n    };\n    return r.rawLeaves ? (i.codec = raw, i.cidVersion = 1) : (o = new UnixFS({\n      type: r.leafType,\n      data: n\n    }), n = encode$2({\n      Data: o.marshal(),\n      Links: []\n    })), {\n      cid: await persist(n, t, i),\n      unixfs: o,\n      size: n.length\n    };\n  };\n}\nconst dagBuilders = {\n  flat: flat,\n  balanced: balanced,\n  trickle: trickleStream\n};\nasync function* buildFileBatch(e, t, r) {\n  let n,\n    o,\n    i = -1;\n  o = \"function\" == typeof r.bufferImporter ? r.bufferImporter : bufferImporter;\n  for await (const s of itParallelBatch(o(e, t, r), r.blockWriteConcurrency)) i++, 0 !== i ? (1 === i && n && (yield n, n = null), yield s) : n = s;\n  n && (n.single = !0, yield n);\n}\nconst reduce = (e, t, r) => async function (n) {\n  if (1 === n.length && n[0].single && r.reduceSingleLeafToSelf) {\n    const o = n[0];\n    if (void 0 !== e.mtime || void 0 !== e.mode) {\n      let n = await t.get(o.cid);\n      o.unixfs = new UnixFS({\n        type: \"file\",\n        mtime: e.mtime,\n        mode: e.mode,\n        data: n\n      }), n = encode$2(prepare({\n        Data: o.unixfs.marshal()\n      })), o.cid = await persist(n, t, {\n        ...r,\n        codec: dagPb,\n        hasher: r.hasher,\n        cidVersion: r.cidVersion\n      }), o.size = n.length;\n    }\n    return {\n      cid: o.cid,\n      path: e.path,\n      unixfs: o.unixfs,\n      size: o.size\n    };\n  }\n  const o = new UnixFS({\n      type: \"file\",\n      mtime: e.mtime,\n      mode: e.mode\n    }),\n    i = n.filter(e => !(e.cid.code !== code$3 || !e.size) || !(!e.unixfs || e.unixfs.data || !e.unixfs.fileSize()) || Boolean(e.unixfs && e.unixfs.data && e.unixfs.data.length)).map(e => e.cid.code === code$3 ? (o.addBlockSize(e.size), {\n      Name: \"\",\n      Tsize: e.size,\n      Hash: e.cid\n    }) : (e.unixfs && e.unixfs.data ? o.addBlockSize(e.unixfs.data.length) : o.addBlockSize(e.unixfs && e.unixfs.fileSize() || 0), {\n      Name: \"\",\n      Tsize: e.size,\n      Hash: e.cid\n    })),\n    s = {\n      Data: o.marshal(),\n      Links: i\n    },\n    a = encode$2(prepare(s));\n  return {\n    cid: await persist(a, t, r),\n    path: e.path,\n    unixfs: o,\n    size: a.length + s.Links.reduce((e, t) => e + t.Tsize, 0)\n  };\n};\nfunction fileBuilder(e, t, r) {\n  const n = dagBuilders[r.strategy];\n  if (!n) throw errCode(new Error(`Unknown importer build strategy name: ${r.strategy}`), \"ERR_BAD_STRATEGY\");\n  return n(buildFileBatch(e, t, r), reduce(e, t, r), r);\n}\nvar buffer = {},\n  base64Js = {};\nbase64Js.byteLength = byteLength, base64Js.toByteArray = toByteArray, base64Js.fromByteArray = fromByteArray;\nfor (var lookup = [], revLookup = [], Arr = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;\nfunction getLens(e) {\n  var t = e.length;\n  if (t % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  var r = e.indexOf(\"=\");\n  return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4];\n}\nfunction byteLength(e) {\n  var t = getLens(e),\n    r = t[0],\n    n = t[1];\n  return 3 * (r + n) / 4 - n;\n}\nfunction _byteLength(e, t, r) {\n  return 3 * (t + r) / 4 - r;\n}\nfunction toByteArray(e) {\n  var t,\n    r,\n    n = getLens(e),\n    o = n[0],\n    i = n[1],\n    s = new Arr(_byteLength(e, o, i)),\n    a = 0,\n    c = i > 0 ? o - 4 : o;\n  for (r = 0; r < c; r += 4) t = revLookup[e.charCodeAt(r)] << 18 | revLookup[e.charCodeAt(r + 1)] << 12 | revLookup[e.charCodeAt(r + 2)] << 6 | revLookup[e.charCodeAt(r + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = 255 & t;\n  return 2 === i && (t = revLookup[e.charCodeAt(r)] << 2 | revLookup[e.charCodeAt(r + 1)] >> 4, s[a++] = 255 & t), 1 === i && (t = revLookup[e.charCodeAt(r)] << 10 | revLookup[e.charCodeAt(r + 1)] << 4 | revLookup[e.charCodeAt(r + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = 255 & t), s;\n}\nfunction tripletToBase64(e) {\n  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[63 & e];\n}\nfunction encodeChunk(e, t, r) {\n  for (var n, o = [], i = t; i < r; i += 3) n = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (255 & e[i + 2]), o.push(tripletToBase64(n));\n  return o.join(\"\");\n}\nfunction fromByteArray(e) {\n  for (var t, r = e.length, n = r % 3, o = [], i = 16383, s = 0, a = r - n; s < a; s += i) o.push(encodeChunk(e, s, s + i > a ? a : s + i));\n  return 1 === n ? (t = e[r - 1], o.push(lookup[t >> 2] + lookup[t << 4 & 63] + \"==\")) : 2 === n && (t = (e[r - 2] << 8) + e[r - 1], o.push(lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + \"=\")), o.join(\"\");\n}\nrevLookup[\"-\".charCodeAt(0)] = 62, revLookup[\"_\".charCodeAt(0)] = 63;\nvar ieee754 = {\n  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n  read: function (e, t, r, n, o) {\n    var i,\n      s,\n      a = 8 * o - n - 1,\n      c = (1 << a) - 1,\n      u = c >> 1,\n      f = -7,\n      l = r ? o - 1 : 0,\n      h = r ? -1 : 1,\n      d = e[t + l];\n    for (l += h, i = d & (1 << -f) - 1, d >>= -f, f += a; f > 0; i = 256 * i + e[t + l], l += h, f -= 8);\n    for (s = i & (1 << -f) - 1, i >>= -f, f += n; f > 0; s = 256 * s + e[t + l], l += h, f -= 8);\n    if (0 === i) i = 1 - u;else {\n      if (i === c) return s ? NaN : 1 / 0 * (d ? -1 : 1);\n      s += Math.pow(2, n), i -= u;\n    }\n    return (d ? -1 : 1) * s * Math.pow(2, i - n);\n  },\n  write: function (e, t, r, n, o, i) {\n    var s,\n      a,\n      c,\n      u = 8 * i - o - 1,\n      f = (1 << u) - 1,\n      l = f >> 1,\n      h = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n      d = n ? 0 : i - 1,\n      p = n ? 1 : -1,\n      y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;\n    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = f) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + l >= 1 ? h / c : h * Math.pow(2, 1 - l)) * c >= 2 && (s++, c /= 2), s + l >= f ? (a = 0, s = f) : s + l >= 1 ? (a = (t * c - 1) * Math.pow(2, o), s += l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, o), s = 0)); o >= 8; e[r + d] = 255 & a, d += p, a /= 256, o -= 8);\n    for (s = s << o | a, u += o; u > 0; e[r + d] = 255 & s, d += p, s /= 256, u -= 8);\n    e[r + d - p] |= 128 * y;\n  }\n};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n!function (e) {\n  const t = base64Js,\n    r = ieee754,\n    n = \"function\" == typeof Symbol && \"function\" == typeof Symbol.for ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n  e.Buffer = s, e.SlowBuffer = function (e) {\n    +e != e && (e = 0);\n    return s.alloc(+e);\n  }, e.INSPECT_MAX_BYTES = 50;\n  const o = 2147483647;\n  function i(e) {\n    if (e > o) throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n    const t = new Uint8Array(e);\n    return Object.setPrototypeOf(t, s.prototype), t;\n  }\n  function s(e, t, r) {\n    if (\"number\" == typeof e) {\n      if (\"string\" == typeof t) throw new TypeError('The \"string\" argument must be of type string. Received type number');\n      return u(e);\n    }\n    return a(e, t, r);\n  }\n  function a(e, t, r) {\n    if (\"string\" == typeof e) return function (e, t) {\n      \"string\" == typeof t && \"\" !== t || (t = \"utf8\");\n      if (!s.isEncoding(t)) throw new TypeError(\"Unknown encoding: \" + t);\n      const r = 0 | d(e, t);\n      let n = i(r);\n      const o = n.write(e, t);\n      o !== r && (n = n.slice(0, o));\n      return n;\n    }(e, t);\n    if (ArrayBuffer.isView(e)) return function (e) {\n      if (Y(e, Uint8Array)) {\n        const t = new Uint8Array(e);\n        return l(t.buffer, t.byteOffset, t.byteLength);\n      }\n      return f(e);\n    }(e);\n    if (null == e) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n    if (Y(e, ArrayBuffer) || e && Y(e.buffer, ArrayBuffer)) return l(e, t, r);\n    if (\"undefined\" != typeof SharedArrayBuffer && (Y(e, SharedArrayBuffer) || e && Y(e.buffer, SharedArrayBuffer))) return l(e, t, r);\n    if (\"number\" == typeof e) throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const n = e.valueOf && e.valueOf();\n    if (null != n && n !== e) return s.from(n, t, r);\n    const o = function (e) {\n      if (s.isBuffer(e)) {\n        const t = 0 | h(e.length),\n          r = i(t);\n        return 0 === r.length || e.copy(r, 0, 0, t), r;\n      }\n      if (void 0 !== e.length) return \"number\" != typeof e.length || q(e.length) ? i(0) : f(e);\n      if (\"Buffer\" === e.type && Array.isArray(e.data)) return f(e.data);\n    }(e);\n    if (o) return o;\n    if (\"undefined\" != typeof Symbol && null != Symbol.toPrimitive && \"function\" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive](\"string\"), t, r);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n  }\n  function c(e) {\n    if (\"number\" != typeof e) throw new TypeError('\"size\" argument must be of type number');\n    if (e < 0) throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n  }\n  function u(e) {\n    return c(e), i(e < 0 ? 0 : 0 | h(e));\n  }\n  function f(e) {\n    const t = e.length < 0 ? 0 : 0 | h(e.length),\n      r = i(t);\n    for (let n = 0; n < t; n += 1) r[n] = 255 & e[n];\n    return r;\n  }\n  function l(e, t, r) {\n    if (t < 0 || e.byteLength < t) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (e.byteLength < t + (r || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let n;\n    return n = void 0 === t && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, t) : new Uint8Array(e, t, r), Object.setPrototypeOf(n, s.prototype), n;\n  }\n  function h(e) {\n    if (e >= o) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + o.toString(16) + \" bytes\");\n    return 0 | e;\n  }\n  function d(e, t) {\n    if (s.isBuffer(e)) return e.length;\n    if (ArrayBuffer.isView(e) || Y(e, ArrayBuffer)) return e.byteLength;\n    if (\"string\" != typeof e) throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);\n    const r = e.length,\n      n = arguments.length > 2 && !0 === arguments[2];\n    if (!n && 0 === r) return 0;\n    let o = !1;\n    for (;;) switch (t) {\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n        return r;\n      case \"utf8\":\n      case \"utf-8\":\n        return W(e).length;\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return 2 * r;\n      case \"hex\":\n        return r >>> 1;\n      case \"base64\":\n        return H(e).length;\n      default:\n        if (o) return n ? -1 : W(e).length;\n        t = (\"\" + t).toLowerCase(), o = !0;\n    }\n  }\n  function p(e, t, r) {\n    let n = !1;\n    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return \"\";\n    if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return \"\";\n    if ((r >>>= 0) <= (t >>>= 0)) return \"\";\n    for (e || (e = \"utf8\");;) switch (e) {\n      case \"hex\":\n        return S(this, t, r);\n      case \"utf8\":\n      case \"utf-8\":\n        return B(this, t, r);\n      case \"ascii\":\n        return k(this, t, r);\n      case \"latin1\":\n      case \"binary\":\n        return $(this, t, r);\n      case \"base64\":\n        return v(this, t, r);\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return I(this, t, r);\n      default:\n        if (n) throw new TypeError(\"Unknown encoding: \" + e);\n        e = (e + \"\").toLowerCase(), n = !0;\n    }\n  }\n  function y(e, t, r) {\n    const n = e[t];\n    e[t] = e[r], e[r] = n;\n  }\n  function g(e, t, r, n, o) {\n    if (0 === e.length) return -1;\n    if (\"string\" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), q(r = +r) && (r = o ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {\n      if (o) return -1;\n      r = e.length - 1;\n    } else if (r < 0) {\n      if (!o) return -1;\n      r = 0;\n    }\n    if (\"string\" == typeof t && (t = s.from(t, n)), s.isBuffer(t)) return 0 === t.length ? -1 : b(e, t, r, n, o);\n    if (\"number\" == typeof t) return t &= 255, \"function\" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : b(e, [t], r, n, o);\n    throw new TypeError(\"val must be string, number or Buffer\");\n  }\n  function b(e, t, r, n, o) {\n    let i,\n      s = 1,\n      a = e.length,\n      c = t.length;\n    if (void 0 !== n && (\"ucs2\" === (n = String(n).toLowerCase()) || \"ucs-2\" === n || \"utf16le\" === n || \"utf-16le\" === n)) {\n      if (e.length < 2 || t.length < 2) return -1;\n      s = 2, a /= 2, c /= 2, r /= 2;\n    }\n    function u(e, t) {\n      return 1 === s ? e[t] : e.readUInt16BE(t * s);\n    }\n    if (o) {\n      let n = -1;\n      for (i = r; i < a; i++) if (u(e, i) === u(t, -1 === n ? 0 : i - n)) {\n        if (-1 === n && (n = i), i - n + 1 === c) return n * s;\n      } else -1 !== n && (i -= i - n), n = -1;\n    } else for (r + c > a && (r = a - c), i = r; i >= 0; i--) {\n      let r = !0;\n      for (let n = 0; n < c; n++) if (u(e, i + n) !== u(t, n)) {\n        r = !1;\n        break;\n      }\n      if (r) return i;\n    }\n    return -1;\n  }\n  function m(e, t, r, n) {\n    r = Number(r) || 0;\n    const o = e.length - r;\n    n ? (n = Number(n)) > o && (n = o) : n = o;\n    const i = t.length;\n    let s;\n    for (n > i / 2 && (n = i / 2), s = 0; s < n; ++s) {\n      const n = parseInt(t.substr(2 * s, 2), 16);\n      if (q(n)) return s;\n      e[r + s] = n;\n    }\n    return s;\n  }\n  function w(e, t, r, n) {\n    return G(W(t, e.length - r), e, r, n);\n  }\n  function _(e, t, r, n) {\n    return G(function (e) {\n      const t = [];\n      for (let r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));\n      return t;\n    }(t), e, r, n);\n  }\n  function T(e, t, r, n) {\n    return G(H(t), e, r, n);\n  }\n  function E(e, t, r, n) {\n    return G(function (e, t) {\n      let r, n, o;\n      const i = [];\n      for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, o = r % 256, i.push(o), i.push(n);\n      return i;\n    }(t, e.length - r), e, r, n);\n  }\n  function v(e, r, n) {\n    return 0 === r && n === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(r, n));\n  }\n  function B(e, t, r) {\n    r = Math.min(e.length, r);\n    const n = [];\n    let o = t;\n    for (; o < r;) {\n      const t = e[o];\n      let i = null,\n        s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;\n      if (o + s <= r) {\n        let r, n, a, c;\n        switch (s) {\n          case 1:\n            t < 128 && (i = t);\n            break;\n          case 2:\n            r = e[o + 1], 128 == (192 & r) && (c = (31 & t) << 6 | 63 & r, c > 127 && (i = c));\n            break;\n          case 3:\n            r = e[o + 1], n = e[o + 2], 128 == (192 & r) && 128 == (192 & n) && (c = (15 & t) << 12 | (63 & r) << 6 | 63 & n, c > 2047 && (c < 55296 || c > 57343) && (i = c));\n            break;\n          case 4:\n            r = e[o + 1], n = e[o + 2], a = e[o + 3], 128 == (192 & r) && 128 == (192 & n) && 128 == (192 & a) && (c = (15 & t) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a, c > 65535 && c < 1114112 && (i = c));\n        }\n      }\n      null === i ? (i = 65533, s = 1) : i > 65535 && (i -= 65536, n.push(i >>> 10 & 1023 | 55296), i = 56320 | 1023 & i), n.push(i), o += s;\n    }\n    return function (e) {\n      const t = e.length;\n      if (t <= A) return String.fromCharCode.apply(String, e);\n      let r = \"\",\n        n = 0;\n      for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += A));\n      return r;\n    }(n);\n  }\n  e.kMaxLength = o, s.TYPED_ARRAY_SUPPORT = function () {\n    try {\n      const e = new Uint8Array(1),\n        t = {\n          foo: function () {\n            return 42;\n          }\n        };\n      return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo();\n    } catch (e) {\n      return !1;\n    }\n  }(), s.TYPED_ARRAY_SUPPORT || \"undefined\" == typeof console || \"function\" != typeof console.error || console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"), Object.defineProperty(s.prototype, \"parent\", {\n    enumerable: !0,\n    get: function () {\n      if (s.isBuffer(this)) return this.buffer;\n    }\n  }), Object.defineProperty(s.prototype, \"offset\", {\n    enumerable: !0,\n    get: function () {\n      if (s.isBuffer(this)) return this.byteOffset;\n    }\n  }), s.poolSize = 8192, s.from = function (e, t, r) {\n    return a(e, t, r);\n  }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array), s.alloc = function (e, t, r) {\n    return function (e, t, r) {\n      return c(e), e <= 0 ? i(e) : void 0 !== t ? \"string\" == typeof r ? i(e).fill(t, r) : i(e).fill(t) : i(e);\n    }(e, t, r);\n  }, s.allocUnsafe = function (e) {\n    return u(e);\n  }, s.allocUnsafeSlow = function (e) {\n    return u(e);\n  }, s.isBuffer = function (e) {\n    return null != e && !0 === e._isBuffer && e !== s.prototype;\n  }, s.compare = function (e, t) {\n    if (Y(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), Y(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (e === t) return 0;\n    let r = e.length,\n      n = t.length;\n    for (let o = 0, i = Math.min(r, n); o < i; ++o) if (e[o] !== t[o]) {\n      r = e[o], n = t[o];\n      break;\n    }\n    return r < n ? -1 : n < r ? 1 : 0;\n  }, s.isEncoding = function (e) {\n    switch (String(e).toLowerCase()) {\n      case \"hex\":\n      case \"utf8\":\n      case \"utf-8\":\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n      case \"base64\":\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return !0;\n      default:\n        return !1;\n    }\n  }, s.concat = function (e, t) {\n    if (!Array.isArray(e)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (0 === e.length) return s.alloc(0);\n    let r;\n    if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;\n    const n = s.allocUnsafe(t);\n    let o = 0;\n    for (r = 0; r < e.length; ++r) {\n      let t = e[r];\n      if (Y(t, Uint8Array)) o + t.length > n.length ? (s.isBuffer(t) || (t = s.from(t)), t.copy(n, o)) : Uint8Array.prototype.set.call(n, t, o);else {\n        if (!s.isBuffer(t)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        t.copy(n, o);\n      }\n      o += t.length;\n    }\n    return n;\n  }, s.byteLength = d, s.prototype._isBuffer = !0, s.prototype.swap16 = function () {\n    const e = this.length;\n    if (e % 2 != 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for (let t = 0; t < e; t += 2) y(this, t, t + 1);\n    return this;\n  }, s.prototype.swap32 = function () {\n    const e = this.length;\n    if (e % 4 != 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for (let t = 0; t < e; t += 4) y(this, t, t + 3), y(this, t + 1, t + 2);\n    return this;\n  }, s.prototype.swap64 = function () {\n    const e = this.length;\n    if (e % 8 != 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for (let t = 0; t < e; t += 8) y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4);\n    return this;\n  }, s.prototype.toString = function () {\n    const e = this.length;\n    return 0 === e ? \"\" : 0 === arguments.length ? B(this, 0, e) : p.apply(this, arguments);\n  }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (e) {\n    if (!s.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n    return this === e || 0 === s.compare(this, e);\n  }, s.prototype.inspect = function () {\n    let t = \"\";\n    const r = e.INSPECT_MAX_BYTES;\n    return t = this.toString(\"hex\", 0, r).replace(/(.{2})/g, \"$1 \").trim(), this.length > r && (t += \" ... \"), \"<Buffer \" + t + \">\";\n  }, n && (s.prototype[n] = s.prototype.inspect), s.prototype.compare = function (e, t, r, n, o) {\n    if (Y(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);\n    if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === o && (o = this.length), t < 0 || r > e.length || n < 0 || o > this.length) throw new RangeError(\"out of range index\");\n    if (n >= o && t >= r) return 0;\n    if (n >= o) return -1;\n    if (t >= r) return 1;\n    if (this === e) return 0;\n    let i = (o >>>= 0) - (n >>>= 0),\n      a = (r >>>= 0) - (t >>>= 0);\n    const c = Math.min(i, a),\n      u = this.slice(n, o),\n      f = e.slice(t, r);\n    for (let e = 0; e < c; ++e) if (u[e] !== f[e]) {\n      i = u[e], a = f[e];\n      break;\n    }\n    return i < a ? -1 : a < i ? 1 : 0;\n  }, s.prototype.includes = function (e, t, r) {\n    return -1 !== this.indexOf(e, t, r);\n  }, s.prototype.indexOf = function (e, t, r) {\n    return g(this, e, t, r, !0);\n  }, s.prototype.lastIndexOf = function (e, t, r) {\n    return g(this, e, t, r, !1);\n  }, s.prototype.write = function (e, t, r, n) {\n    if (void 0 === t) n = \"utf8\", r = this.length, t = 0;else if (void 0 === r && \"string\" == typeof t) n = t, r = this.length, t = 0;else {\n      if (!isFinite(t)) throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n      t >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = \"utf8\")) : (n = r, r = void 0);\n    }\n    const o = this.length - t;\n    if ((void 0 === r || r > o) && (r = o), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    n || (n = \"utf8\");\n    let i = !1;\n    for (;;) switch (n) {\n      case \"hex\":\n        return m(this, e, t, r);\n      case \"utf8\":\n      case \"utf-8\":\n        return w(this, e, t, r);\n      case \"ascii\":\n      case \"latin1\":\n      case \"binary\":\n        return _(this, e, t, r);\n      case \"base64\":\n        return T(this, e, t, r);\n      case \"ucs2\":\n      case \"ucs-2\":\n      case \"utf16le\":\n      case \"utf-16le\":\n        return E(this, e, t, r);\n      default:\n        if (i) throw new TypeError(\"Unknown encoding: \" + n);\n        n = (\"\" + n).toLowerCase(), i = !0;\n    }\n  }, s.prototype.toJSON = function () {\n    return {\n      type: \"Buffer\",\n      data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n  };\n  const A = 4096;\n  function k(e, t, r) {\n    let n = \"\";\n    r = Math.min(e.length, r);\n    for (let o = t; o < r; ++o) n += String.fromCharCode(127 & e[o]);\n    return n;\n  }\n  function $(e, t, r) {\n    let n = \"\";\n    r = Math.min(e.length, r);\n    for (let o = t; o < r; ++o) n += String.fromCharCode(e[o]);\n    return n;\n  }\n  function S(e, t, r) {\n    const n = e.length;\n    (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);\n    let o = \"\";\n    for (let n = t; n < r; ++n) o += K[e[n]];\n    return o;\n  }\n  function I(e, t, r) {\n    const n = e.slice(t, r);\n    let o = \"\";\n    for (let e = 0; e < n.length - 1; e += 2) o += String.fromCharCode(n[e] + 256 * n[e + 1]);\n    return o;\n  }\n  function C(e, t, r) {\n    if (e % 1 != 0 || e < 0) throw new RangeError(\"offset is not uint\");\n    if (e + t > r) throw new RangeError(\"Trying to access beyond buffer length\");\n  }\n  function x(e, t, r, n, o, i) {\n    if (!s.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (t > o || t < i) throw new RangeError('\"value\" argument is out of bounds');\n    if (r + n > e.length) throw new RangeError(\"Index out of range\");\n  }\n  function D(e, t, r, n, o) {\n    F(t, n, o, e, r, 7);\n    let i = Number(t & BigInt(4294967295));\n    e[r++] = i, i >>= 8, e[r++] = i, i >>= 8, e[r++] = i, i >>= 8, e[r++] = i;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r++] = s, s >>= 8, e[r++] = s, s >>= 8, e[r++] = s, s >>= 8, e[r++] = s, r;\n  }\n  function R(e, t, r, n, o) {\n    F(t, n, o, e, r, 7);\n    let i = Number(t & BigInt(4294967295));\n    e[r + 7] = i, i >>= 8, e[r + 6] = i, i >>= 8, e[r + 5] = i, i >>= 8, e[r + 4] = i;\n    let s = Number(t >> BigInt(32) & BigInt(4294967295));\n    return e[r + 3] = s, s >>= 8, e[r + 2] = s, s >>= 8, e[r + 1] = s, s >>= 8, e[r] = s, r + 8;\n  }\n  function O(e, t, r, n, o, i) {\n    if (r + n > e.length) throw new RangeError(\"Index out of range\");\n    if (r < 0) throw new RangeError(\"Index out of range\");\n  }\n  function U(e, t, n, o, i) {\n    return t = +t, n >>>= 0, i || O(e, 0, n, 4), r.write(e, t, n, o, 23, 4), n + 4;\n  }\n  function L(e, t, n, o, i) {\n    return t = +t, n >>>= 0, i || O(e, 0, n, 8), r.write(e, t, n, o, 52, 8), n + 8;\n  }\n  s.prototype.slice = function (e, t) {\n    const r = this.length;\n    (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e);\n    const n = this.subarray(e, t);\n    return Object.setPrototypeOf(n, s.prototype), n;\n  }, s.prototype.readUintLE = s.prototype.readUIntLE = function (e, t, r) {\n    e >>>= 0, t >>>= 0, r || C(e, t, this.length);\n    let n = this[e],\n      o = 1,\n      i = 0;\n    for (; ++i < t && (o *= 256);) n += this[e + i] * o;\n    return n;\n  }, s.prototype.readUintBE = s.prototype.readUIntBE = function (e, t, r) {\n    e >>>= 0, t >>>= 0, r || C(e, t, this.length);\n    let n = this[e + --t],\n      o = 1;\n    for (; t > 0 && (o *= 256);) n += this[e + --t] * o;\n    return n;\n  }, s.prototype.readUint8 = s.prototype.readUInt8 = function (e, t) {\n    return e >>>= 0, t || C(e, 1, this.length), this[e];\n  }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function (e, t) {\n    return e >>>= 0, t || C(e, 2, this.length), this[e] | this[e + 1] << 8;\n  }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function (e, t) {\n    return e >>>= 0, t || C(e, 2, this.length), this[e] << 8 | this[e + 1];\n  }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];\n  }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n  }, s.prototype.readBigUInt64LE = J(function (e) {\n    M(e >>>= 0, \"offset\");\n    const t = this[e],\n      r = this[e + 7];\n    void 0 !== t && void 0 !== r || z(e, this.length - 8);\n    const n = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,\n      o = this[++e] + 256 * this[++e] + 65536 * this[++e] + r * 2 ** 24;\n    return BigInt(n) + (BigInt(o) << BigInt(32));\n  }), s.prototype.readBigUInt64BE = J(function (e) {\n    M(e >>>= 0, \"offset\");\n    const t = this[e],\n      r = this[e + 7];\n    void 0 !== t && void 0 !== r || z(e, this.length - 8);\n    const n = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],\n      o = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r;\n    return (BigInt(n) << BigInt(32)) + BigInt(o);\n  }), s.prototype.readIntLE = function (e, t, r) {\n    e >>>= 0, t >>>= 0, r || C(e, t, this.length);\n    let n = this[e],\n      o = 1,\n      i = 0;\n    for (; ++i < t && (o *= 256);) n += this[e + i] * o;\n    return o *= 128, n >= o && (n -= Math.pow(2, 8 * t)), n;\n  }, s.prototype.readIntBE = function (e, t, r) {\n    e >>>= 0, t >>>= 0, r || C(e, t, this.length);\n    let n = t,\n      o = 1,\n      i = this[e + --n];\n    for (; n > 0 && (o *= 256);) i += this[e + --n] * o;\n    return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i;\n  }, s.prototype.readInt8 = function (e, t) {\n    return e >>>= 0, t || C(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];\n  }, s.prototype.readInt16LE = function (e, t) {\n    e >>>= 0, t || C(e, 2, this.length);\n    const r = this[e] | this[e + 1] << 8;\n    return 32768 & r ? 4294901760 | r : r;\n  }, s.prototype.readInt16BE = function (e, t) {\n    e >>>= 0, t || C(e, 2, this.length);\n    const r = this[e + 1] | this[e] << 8;\n    return 32768 & r ? 4294901760 | r : r;\n  }, s.prototype.readInt32LE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n  }, s.prototype.readInt32BE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n  }, s.prototype.readBigInt64LE = J(function (e) {\n    M(e >>>= 0, \"offset\");\n    const t = this[e],\n      r = this[e + 7];\n    void 0 !== t && void 0 !== r || z(e, this.length - 8);\n    const n = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24);\n    return (BigInt(n) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24);\n  }), s.prototype.readBigInt64BE = J(function (e) {\n    M(e >>>= 0, \"offset\");\n    const t = this[e],\n      r = this[e + 7];\n    void 0 !== t && void 0 !== r || z(e, this.length - 8);\n    const n = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];\n    return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r);\n  }), s.prototype.readFloatLE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), r.read(this, e, !0, 23, 4);\n  }, s.prototype.readFloatBE = function (e, t) {\n    return e >>>= 0, t || C(e, 4, this.length), r.read(this, e, !1, 23, 4);\n  }, s.prototype.readDoubleLE = function (e, t) {\n    return e >>>= 0, t || C(e, 8, this.length), r.read(this, e, !0, 52, 8);\n  }, s.prototype.readDoubleBE = function (e, t) {\n    return e >>>= 0, t || C(e, 8, this.length), r.read(this, e, !1, 52, 8);\n  }, s.prototype.writeUintLE = s.prototype.writeUIntLE = function (e, t, r, n) {\n    if (e = +e, t >>>= 0, r >>>= 0, !n) {\n      x(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);\n    }\n    let o = 1,\n      i = 0;\n    for (this[t] = 255 & e; ++i < r && (o *= 256);) this[t + i] = e / o & 255;\n    return t + r;\n  }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function (e, t, r, n) {\n    if (e = +e, t >>>= 0, r >>>= 0, !n) {\n      x(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);\n    }\n    let o = r - 1,\n      i = 1;\n    for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);) this[t + o] = e / i & 255;\n    return t + r;\n  }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1;\n  }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;\n  }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;\n  }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4;\n  }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;\n  }, s.prototype.writeBigUInt64LE = J(function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return D(this, e, t, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  }), s.prototype.writeBigUInt64BE = J(function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return R(this, e, t, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n  }), s.prototype.writeIntLE = function (e, t, r, n) {\n    if (e = +e, t >>>= 0, !n) {\n      const n = Math.pow(2, 8 * r - 1);\n      x(this, e, t, r, n - 1, -n);\n    }\n    let o = 0,\n      i = 1,\n      s = 0;\n    for (this[t] = 255 & e; ++o < r && (i *= 256);) e < 0 && 0 === s && 0 !== this[t + o - 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255;\n    return t + r;\n  }, s.prototype.writeIntBE = function (e, t, r, n) {\n    if (e = +e, t >>>= 0, !n) {\n      const n = Math.pow(2, 8 * r - 1);\n      x(this, e, t, r, n - 1, -n);\n    }\n    let o = r - 1,\n      i = 1,\n      s = 0;\n    for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);) e < 0 && 0 === s && 0 !== this[t + o + 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255;\n    return t + r;\n  }, s.prototype.writeInt8 = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;\n  }, s.prototype.writeInt16LE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;\n  }, s.prototype.writeInt16BE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;\n  }, s.prototype.writeInt32LE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;\n  }, s.prototype.writeInt32BE = function (e, t, r) {\n    return e = +e, t >>>= 0, r || x(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;\n  }, s.prototype.writeBigInt64LE = J(function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return D(this, e, t, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  }), s.prototype.writeBigInt64BE = J(function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return R(this, e, t, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n  }), s.prototype.writeFloatLE = function (e, t, r) {\n    return U(this, e, t, !0, r);\n  }, s.prototype.writeFloatBE = function (e, t, r) {\n    return U(this, e, t, !1, r);\n  }, s.prototype.writeDoubleLE = function (e, t, r) {\n    return L(this, e, t, !0, r);\n  }, s.prototype.writeDoubleBE = function (e, t, r) {\n    return L(this, e, t, !1, r);\n  }, s.prototype.copy = function (e, t, r, n) {\n    if (!s.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n    if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;\n    if (0 === e.length || 0 === this.length) return 0;\n    if (t < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (r < 0 || r >= this.length) throw new RangeError(\"Index out of range\");\n    if (n < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);\n    const o = n - r;\n    return this === e && \"function\" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, r, n) : Uint8Array.prototype.set.call(e, this.subarray(r, n), t), o;\n  }, s.prototype.fill = function (e, t, r, n) {\n    if (\"string\" == typeof e) {\n      if (\"string\" == typeof t ? (n = t, t = 0, r = this.length) : \"string\" == typeof r && (n = r, r = this.length), void 0 !== n && \"string\" != typeof n) throw new TypeError(\"encoding must be a string\");\n      if (\"string\" == typeof n && !s.isEncoding(n)) throw new TypeError(\"Unknown encoding: \" + n);\n      if (1 === e.length) {\n        const t = e.charCodeAt(0);\n        (\"utf8\" === n && t < 128 || \"latin1\" === n) && (e = t);\n      }\n    } else \"number\" == typeof e ? e &= 255 : \"boolean\" == typeof e && (e = Number(e));\n    if (t < 0 || this.length < t || this.length < r) throw new RangeError(\"Out of range index\");\n    if (r <= t) return this;\n    let o;\n    if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), \"number\" == typeof e) for (o = t; o < r; ++o) this[o] = e;else {\n      const i = s.isBuffer(e) ? e : s.from(e, n),\n        a = i.length;\n      if (0 === a) throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n      for (o = 0; o < r - t; ++o) this[o + t] = i[o % a];\n    }\n    return this;\n  };\n  const N = {};\n  function j(e, t, r) {\n    N[e] = class extends r {\n      constructor() {\n        super(), Object.defineProperty(this, \"message\", {\n          value: t.apply(this, arguments),\n          writable: !0,\n          configurable: !0\n        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;\n      }\n      get code() {\n        return e;\n      }\n      set code(e) {\n        Object.defineProperty(this, \"code\", {\n          configurable: !0,\n          enumerable: !0,\n          value: e,\n          writable: !0\n        });\n      }\n      toString() {\n        return `${this.name} [${e}]: ${this.message}`;\n      }\n    };\n  }\n  function P(e) {\n    let t = \"\",\n      r = e.length;\n    const n = \"-\" === e[0] ? 1 : 0;\n    for (; r >= n + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;\n    return `${e.slice(0, r)}${t}`;\n  }\n  function F(e, t, r, n, o, i) {\n    if (e > r || e < t) {\n      const n = \"bigint\" == typeof t ? \"n\" : \"\";\n      let o;\n      throw o = i > 3 ? 0 === t || t === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8 * (i + 1)}${n}` : `>= -(2${n} ** ${8 * (i + 1) - 1}${n}) and < 2 ** ${8 * (i + 1) - 1}${n}` : `>= ${t}${n} and <= ${r}${n}`, new N.ERR_OUT_OF_RANGE(\"value\", o, e);\n    }\n    !function (e, t, r) {\n      M(t, \"offset\"), void 0 !== e[t] && void 0 !== e[t + r] || z(t, e.length - (r + 1));\n    }(n, o, i);\n  }\n  function M(e, t) {\n    if (\"number\" != typeof e) throw new N.ERR_INVALID_ARG_TYPE(t, \"number\", e);\n  }\n  function z(e, t, r) {\n    if (Math.floor(e) !== e) throw M(e, r), new N.ERR_OUT_OF_RANGE(r || \"offset\", \"an integer\", e);\n    if (t < 0) throw new N.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new N.ERR_OUT_OF_RANGE(r || \"offset\", `>= ${r ? 1 : 0} and <= ${t}`, e);\n  }\n  j(\"ERR_BUFFER_OUT_OF_BOUNDS\", function (e) {\n    return e ? `${e} is outside of buffer bounds` : \"Attempt to access memory outside buffer bounds\";\n  }, RangeError), j(\"ERR_INVALID_ARG_TYPE\", function (e, t) {\n    return `The \"${e}\" argument must be of type number. Received type ${typeof t}`;\n  }, TypeError), j(\"ERR_OUT_OF_RANGE\", function (e, t, r) {\n    let n = `The value of \"${e}\" is out of range.`,\n      o = r;\n    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = P(String(r)) : \"bigint\" == typeof r && (o = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (o = P(o)), o += \"n\"), n += ` It must be ${t}. Received ${o}`, n;\n  }, RangeError);\n  const V = /[^+/0-9A-Za-z-_]/g;\n  function W(e, t) {\n    let r;\n    t = t || 1 / 0;\n    const n = e.length;\n    let o = null;\n    const i = [];\n    for (let s = 0; s < n; ++s) {\n      if (r = e.charCodeAt(s), r > 55295 && r < 57344) {\n        if (!o) {\n          if (r > 56319) {\n            (t -= 3) > -1 && i.push(239, 191, 189);\n            continue;\n          }\n          if (s + 1 === n) {\n            (t -= 3) > -1 && i.push(239, 191, 189);\n            continue;\n          }\n          o = r;\n          continue;\n        }\n        if (r < 56320) {\n          (t -= 3) > -1 && i.push(239, 191, 189), o = r;\n          continue;\n        }\n        r = 65536 + (o - 55296 << 10 | r - 56320);\n      } else o && (t -= 3) > -1 && i.push(239, 191, 189);\n      if (o = null, r < 128) {\n        if ((t -= 1) < 0) break;\n        i.push(r);\n      } else if (r < 2048) {\n        if ((t -= 2) < 0) break;\n        i.push(r >> 6 | 192, 63 & r | 128);\n      } else if (r < 65536) {\n        if ((t -= 3) < 0) break;\n        i.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);\n      } else {\n        if (!(r < 1114112)) throw new Error(\"Invalid code point\");\n        if ((t -= 4) < 0) break;\n        i.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);\n      }\n    }\n    return i;\n  }\n  function H(e) {\n    return t.toByteArray(function (e) {\n      if ((e = (e = e.split(\"=\")[0]).trim().replace(V, \"\")).length < 2) return \"\";\n      for (; e.length % 4 != 0;) e += \"=\";\n      return e;\n    }(e));\n  }\n  function G(e, t, r, n) {\n    let o;\n    for (o = 0; o < n && !(o + r >= t.length || o >= e.length); ++o) t[o + r] = e[o];\n    return o;\n  }\n  function Y(e, t) {\n    return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name;\n  }\n  function q(e) {\n    return e != e;\n  }\n  const K = function () {\n    const e = \"0123456789abcdef\",\n      t = new Array(256);\n    for (let r = 0; r < 16; ++r) {\n      const n = 16 * r;\n      for (let o = 0; o < 16; ++o) t[n + o] = e[r] + e[o];\n    }\n    return t;\n  }();\n  function J(e) {\n    return \"undefined\" == typeof BigInt ? X : e;\n  }\n  function X() {\n    throw new Error(\"BigInt not supported\");\n  }\n}(buffer);\nconst {\n    Buffer: Buffer\n  } = buffer,\n  symbol = Symbol.for(\"BufferList\");\nfunction BufferList(e) {\n  if (!(this instanceof BufferList)) return new BufferList(e);\n  BufferList._init.call(this, e);\n}\nBufferList._init = function (e) {\n  Object.defineProperty(this, symbol, {\n    value: !0\n  }), this._bufs = [], this.length = 0, e && this.append(e);\n}, BufferList.prototype._new = function (e) {\n  return new BufferList(e);\n}, BufferList.prototype._offset = function (e) {\n  if (0 === e) return [0, 0];\n  let t = 0;\n  for (let r = 0; r < this._bufs.length; r++) {\n    const n = t + this._bufs[r].length;\n    if (e < n || r === this._bufs.length - 1) return [r, e - t];\n    t = n;\n  }\n}, BufferList.prototype._reverseOffset = function (e) {\n  const t = e[0];\n  let r = e[1];\n  for (let e = 0; e < t; e++) r += this._bufs[e].length;\n  return r;\n}, BufferList.prototype.get = function (e) {\n  if (e > this.length || e < 0) return;\n  const t = this._offset(e);\n  return this._bufs[t[0]][t[1]];\n}, BufferList.prototype.slice = function (e, t) {\n  return \"number\" == typeof e && e < 0 && (e += this.length), \"number\" == typeof t && t < 0 && (t += this.length), this.copy(null, 0, e, t);\n}, BufferList.prototype.copy = function (e, t, r, n) {\n  if ((\"number\" != typeof r || r < 0) && (r = 0), (\"number\" != typeof n || n > this.length) && (n = this.length), r >= this.length) return e || Buffer.alloc(0);\n  if (n <= 0) return e || Buffer.alloc(0);\n  const o = !!e,\n    i = this._offset(r),\n    s = n - r;\n  let a = s,\n    c = o && t || 0,\n    u = i[1];\n  if (0 === r && n === this.length) {\n    if (!o) return 1 === this._bufs.length ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n    for (let t = 0; t < this._bufs.length; t++) this._bufs[t].copy(e, c), c += this._bufs[t].length;\n    return e;\n  }\n  if (a <= this._bufs[i[0]].length - u) return o ? this._bufs[i[0]].copy(e, t, u, u + a) : this._bufs[i[0]].slice(u, u + a);\n  o || (e = Buffer.allocUnsafe(s));\n  for (let t = i[0]; t < this._bufs.length; t++) {\n    const r = this._bufs[t].length - u;\n    if (!(a > r)) {\n      this._bufs[t].copy(e, c, u, u + a), c += r;\n      break;\n    }\n    this._bufs[t].copy(e, c, u), c += r, a -= r, u && (u = 0);\n  }\n  return e.length > c ? e.slice(0, c) : e;\n}, BufferList.prototype.shallowSlice = function (e, t) {\n  if (e = e || 0, t = \"number\" != typeof t ? this.length : t, e < 0 && (e += this.length), t < 0 && (t += this.length), e === t) return this._new();\n  const r = this._offset(e),\n    n = this._offset(t),\n    o = this._bufs.slice(r[0], n[0] + 1);\n  return 0 === n[1] ? o.pop() : o[o.length - 1] = o[o.length - 1].slice(0, n[1]), 0 !== r[1] && (o[0] = o[0].slice(r[1])), this._new(o);\n}, BufferList.prototype.toString = function (e, t, r) {\n  return this.slice(t, r).toString(e);\n}, BufferList.prototype.consume = function (e) {\n  if (e = Math.trunc(e), Number.isNaN(e) || e <= 0) return this;\n  for (; this._bufs.length;) {\n    if (!(e >= this._bufs[0].length)) {\n      this._bufs[0] = this._bufs[0].slice(e), this.length -= e;\n      break;\n    }\n    e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();\n  }\n  return this;\n}, BufferList.prototype.duplicate = function () {\n  const e = this._new();\n  for (let t = 0; t < this._bufs.length; t++) e.append(this._bufs[t]);\n  return e;\n}, BufferList.prototype.append = function (e) {\n  if (null == e) return this;\n  if (e.buffer) this._appendBuffer(Buffer.from(e.buffer, e.byteOffset, e.byteLength));else if (Array.isArray(e)) for (let t = 0; t < e.length; t++) this.append(e[t]);else if (this._isBufferList(e)) for (let t = 0; t < e._bufs.length; t++) this.append(e._bufs[t]);else \"number\" == typeof e && (e = e.toString()), this._appendBuffer(Buffer.from(e));\n  return this;\n}, BufferList.prototype._appendBuffer = function (e) {\n  this._bufs.push(e), this.length += e.length;\n}, BufferList.prototype.indexOf = function (e, t, r) {\n  if (void 0 === r && \"string\" == typeof t && (r = t, t = void 0), \"function\" == typeof e || Array.isArray(e)) throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');\n  if (\"number\" == typeof e ? e = Buffer.from([e]) : \"string\" == typeof e ? e = Buffer.from(e, r) : this._isBufferList(e) ? e = e.slice() : Array.isArray(e.buffer) ? e = Buffer.from(e.buffer, e.byteOffset, e.byteLength) : Buffer.isBuffer(e) || (e = Buffer.from(e)), t = Number(t || 0), isNaN(t) && (t = 0), t < 0 && (t = this.length + t), t < 0 && (t = 0), 0 === e.length) return t > this.length ? this.length : t;\n  const n = this._offset(t);\n  let o = n[0],\n    i = n[1];\n  for (; o < this._bufs.length; o++) {\n    const t = this._bufs[o];\n    for (; i < t.length;) {\n      if (t.length - i >= e.length) {\n        const r = t.indexOf(e, i);\n        if (-1 !== r) return this._reverseOffset([o, r]);\n        i = t.length - e.length + 1;\n      } else {\n        const t = this._reverseOffset([o, i]);\n        if (this._match(t, e)) return t;\n        i++;\n      }\n    }\n    i = 0;\n  }\n  return -1;\n}, BufferList.prototype._match = function (e, t) {\n  if (this.length - e < t.length) return !1;\n  for (let r = 0; r < t.length; r++) if (this.get(e + r) !== t[r]) return !1;\n  return !0;\n}, function () {\n  const e = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  };\n  for (const t in e) !function (t) {\n    BufferList.prototype[t] = null === e[t] ? function (e, r) {\n      return this.slice(e, e + r)[t](0, r);\n    } : function () {\n      let r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.slice(r, r + e[t])[t](0);\n    };\n  }(t);\n}(), BufferList.prototype._isBufferList = function (e) {\n  return e instanceof BufferList || BufferList.isBufferList(e);\n}, BufferList.isBufferList = function (e) {\n  return null != e && e[symbol];\n};\nvar BufferList_1 = BufferList;\nclass Rabin$1 {\n  constructor(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8192;\n    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32768;\n    let o = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 64;\n    let i = arguments.length > 5 ? arguments[5] : undefined;\n    this.bits = t, this.min = r, this.max = n, this.asModule = e, this.rabin = new e.Rabin(t, r, n, o, i), this.polynomial = i;\n  }\n  fingerprint(e) {\n    const {\n        __retain: t,\n        __release: r,\n        __allocArray: n,\n        __getInt32Array: o,\n        Int32Array_ID: i,\n        Uint8Array_ID: s\n      } = this.asModule,\n      a = t(n(i, new Int32Array(Math.ceil(e.length / this.min)))),\n      c = t(n(s, e)),\n      u = o(this.rabin.fingerprint(c, a));\n    r(c), r(a);\n    const f = u.indexOf(0);\n    return f >= 0 ? u.subarray(0, f) : u;\n  }\n}\nvar rabin$1 = Rabin$1,\n  loader = {};\nconst ID_OFFSET = -8,\n  SIZE_OFFSET = -4,\n  ARRAYBUFFER_ID = 0,\n  STRING_ID = 1,\n  ARRAYBUFFERVIEW = 1,\n  ARRAY = 2,\n  VAL_ALIGN_OFFSET = 5,\n  VAL_SIGNED = 1024,\n  VAL_FLOAT = 2048,\n  VAL_MANAGED = 8192,\n  ARRAYBUFFERVIEW_BUFFER_OFFSET = 0,\n  ARRAYBUFFERVIEW_DATASTART_OFFSET = 4,\n  ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8,\n  ARRAYBUFFERVIEW_SIZE = 12,\n  ARRAY_LENGTH_OFFSET = 12,\n  ARRAY_SIZE = 16,\n  BIGINT = \"undefined\" != typeof BigUint64Array,\n  THIS = Symbol(),\n  CHUNKSIZE = 1024;\nfunction getStringImpl(e, t) {\n  const r = new Uint32Array(e),\n    n = new Uint16Array(e);\n  var o = r[t + SIZE_OFFSET >>> 2] >>> 1,\n    i = t >>> 1;\n  if (o <= CHUNKSIZE) return String.fromCharCode.apply(String, n.subarray(i, i + o));\n  const s = [];\n  do {\n    const e = n[i + CHUNKSIZE - 1],\n      t = e >= 55296 && e < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    s.push(String.fromCharCode.apply(String, n.subarray(i, i += t))), o -= t;\n  } while (o > CHUNKSIZE);\n  return s.join(\"\") + String.fromCharCode.apply(String, n.subarray(i, i + o));\n}\nfunction preInstantiate(e) {\n  const t = {};\n  function r(e, t) {\n    return e ? getStringImpl(e.buffer, t) : \"<yet unknown>\";\n  }\n  const n = e.env = e.env || {};\n  return n.abort = n.abort || function (e, o, i, s) {\n    const a = t.memory || n.memory;\n    throw Error(\"abort: \" + r(a, e) + \" at \" + r(a, o) + \":\" + i + \":\" + s);\n  }, n.trace = n.trace || function (e, o) {\n    const i = t.memory || n.memory;\n    console.log(\"trace: \" + r(i, e) + (o ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + o).join(\", \"));\n  }, e.Math = e.Math || Math, e.Date = e.Date || Date, t;\n}\nfunction postInstantiate(e, t) {\n  const r = t.exports,\n    n = r.memory,\n    o = r.table,\n    i = r.__alloc,\n    s = r.__retain,\n    a = r.__rtti_base || -1;\n  function c(e) {\n    const t = new Uint32Array(n.buffer);\n    if ((e >>>= 0) >= t[a >>> 2]) throw Error(\"invalid id: \" + e);\n    return t[(a + 4 >>> 2) + 2 * e];\n  }\n  function u(e) {\n    const t = new Uint32Array(n.buffer);\n    if ((e >>>= 0) >= t[a >>> 2]) throw Error(\"invalid id: \" + e);\n    return t[(a + 4 >>> 2) + 2 * e + 1];\n  }\n  function f(e) {\n    return 31 - Math.clz32(e >>> VAL_ALIGN_OFFSET & 31);\n  }\n  function l(e, t, r) {\n    const o = n.buffer;\n    if (r) switch (e) {\n      case 2:\n        return new Float32Array(o);\n      case 3:\n        return new Float64Array(o);\n    } else switch (e) {\n      case 0:\n        return new (t ? Int8Array : Uint8Array)(o);\n      case 1:\n        return new (t ? Int16Array : Uint16Array)(o);\n      case 2:\n        return new (t ? Int32Array : Uint32Array)(o);\n      case 3:\n        return new (t ? BigInt64Array : BigUint64Array)(o);\n    }\n    throw Error(\"unsupported align: \" + e);\n  }\n  function h(e) {\n    const t = new Uint32Array(n.buffer),\n      r = t[e + ID_OFFSET >>> 2],\n      o = c(r);\n    if (!(o & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + r);\n    const i = f(o);\n    var s = t[e + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const a = o & ARRAY ? t[e + ARRAY_LENGTH_OFFSET >>> 2] : t[s + SIZE_OFFSET >>> 2] >>> i;\n    return l(i, o & VAL_SIGNED, o & VAL_FLOAT).subarray(s >>>= i, s + a);\n  }\n  function d(e, t, r) {\n    return new e(p(e, t, r));\n  }\n  function p(e, t, r) {\n    const o = n.buffer,\n      i = new Uint32Array(o),\n      s = i[r + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new e(o, s, i[s + SIZE_OFFSET >>> 2] >>> t);\n  }\n  return e.__allocString = function (e) {\n    const t = e.length,\n      r = i(t << 1, STRING_ID),\n      o = new Uint16Array(n.buffer);\n    for (var s = 0, a = r >>> 1; s < t; ++s) o[a + s] = e.charCodeAt(s);\n    return r;\n  }, e.__getString = function (e) {\n    const t = n.buffer;\n    if (new Uint32Array(t)[e + ID_OFFSET >>> 2] !== STRING_ID) throw Error(\"not a string: \" + e);\n    return getStringImpl(t, e);\n  }, e.__allocArray = function (e, t) {\n    const r = c(e);\n    if (!(r & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + e + \" @ \" + r);\n    const o = f(r),\n      a = t.length,\n      u = i(a << o, ARRAYBUFFER_ID),\n      h = i(r & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, e),\n      d = new Uint32Array(n.buffer);\n    d[h + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = s(u), d[h + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = u, d[h + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = a << o, r & ARRAY && (d[h + ARRAY_LENGTH_OFFSET >>> 2] = a);\n    const p = l(o, r & VAL_SIGNED, r & VAL_FLOAT);\n    if (r & VAL_MANAGED) for (let e = 0; e < a; ++e) p[(u >>> o) + e] = s(t[e]);else p.set(t, u >>> o);\n    return h;\n  }, e.__getArrayView = h, e.__getArray = function (e) {\n    const t = h(e),\n      r = t.length,\n      n = new Array(r);\n    for (let e = 0; e < r; e++) n[e] = t[e];\n    return n;\n  }, e.__getArrayBuffer = function (e) {\n    const t = n.buffer,\n      r = new Uint32Array(t)[e + SIZE_OFFSET >>> 2];\n    return t.slice(e, e + r);\n  }, e.__getInt8Array = d.bind(null, Int8Array, 0), e.__getInt8ArrayView = p.bind(null, Int8Array, 0), e.__getUint8Array = d.bind(null, Uint8Array, 0), e.__getUint8ArrayView = p.bind(null, Uint8Array, 0), e.__getUint8ClampedArray = d.bind(null, Uint8ClampedArray, 0), e.__getUint8ClampedArrayView = p.bind(null, Uint8ClampedArray, 0), e.__getInt16Array = d.bind(null, Int16Array, 1), e.__getInt16ArrayView = p.bind(null, Int16Array, 1), e.__getUint16Array = d.bind(null, Uint16Array, 1), e.__getUint16ArrayView = p.bind(null, Uint16Array, 1), e.__getInt32Array = d.bind(null, Int32Array, 2), e.__getInt32ArrayView = p.bind(null, Int32Array, 2), e.__getUint32Array = d.bind(null, Uint32Array, 2), e.__getUint32ArrayView = p.bind(null, Uint32Array, 2), BIGINT && (e.__getInt64Array = d.bind(null, BigInt64Array, 3), e.__getInt64ArrayView = p.bind(null, BigInt64Array, 3), e.__getUint64Array = d.bind(null, BigUint64Array, 3), e.__getUint64ArrayView = p.bind(null, BigUint64Array, 3)), e.__getFloat32Array = d.bind(null, Float32Array, 2), e.__getFloat32ArrayView = p.bind(null, Float32Array, 2), e.__getFloat64Array = d.bind(null, Float64Array, 3), e.__getFloat64ArrayView = p.bind(null, Float64Array, 3), e.__instanceof = function (e, t) {\n    const r = new Uint32Array(n.buffer);\n    var o = r[e + ID_OFFSET >>> 2];\n    if (o <= r[a >>> 2]) do {\n      if (o == t) return !0;\n    } while (o = u(o));\n    return !1;\n  }, e.memory = e.memory || n, e.table = e.table || o, demangle(r, e);\n}\nfunction isResponse(e) {\n  return \"undefined\" != typeof Response && e instanceof Response;\n}\nasync function instantiate$1(e, t) {\n  return isResponse(e = await e) ? instantiateStreaming(e, t) : postInstantiate(preInstantiate(t || (t = {})), await WebAssembly.instantiate(e instanceof WebAssembly.Module ? e : await WebAssembly.compile(e), t));\n}\nfunction instantiateSync(e, t) {\n  return postInstantiate(preInstantiate(t || (t = {})), new WebAssembly.Instance(e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e), t));\n}\nasync function instantiateStreaming(e, t) {\n  return WebAssembly.instantiateStreaming ? postInstantiate(preInstantiate(t || (t = {})), (await WebAssembly.instantiateStreaming(e, t)).instance) : instantiate$1(isResponse(e = await e) ? e.arrayBuffer() : e, t);\n}\nfunction demangle(e, t) {\n  var r = t ? Object.create(t) : {},\n    n = e.__argumentsLength ? function (t) {\n      e.__argumentsLength.value = t;\n    } : e.__setArgumentsLength || e.__setargc || function () {};\n  for (let t in e) {\n    if (!Object.prototype.hasOwnProperty.call(e, t)) continue;\n    const o = e[t];\n    let i = t.split(\".\"),\n      s = r;\n    for (; i.length > 1;) {\n      let e = i.shift();\n      Object.prototype.hasOwnProperty.call(s, e) || (s[e] = {}), s = s[e];\n    }\n    let a = i[0],\n      c = a.indexOf(\"#\");\n    if (c >= 0) {\n      let r = a.substring(0, c),\n        i = s[r];\n      if (void 0 === i || !i.prototype) {\n        let e = function () {\n          for (var _len4 = arguments.length, t = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n            t[_key4] = arguments[_key4];\n          }\n          return e.wrap(e.prototype.constructor(0, ...t));\n        };\n        e.prototype = {\n          valueOf: function () {\n            return this[THIS];\n          }\n        }, e.wrap = function (t) {\n          return Object.create(e.prototype, {\n            [THIS]: {\n              value: t,\n              writable: !1\n            }\n          });\n        }, i && Object.getOwnPropertyNames(i).forEach(t => Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))), s[r] = e;\n      }\n      if (a = a.substring(c + 1), s = s[r].prototype, /^(get|set):/.test(a)) {\n        if (!Object.prototype.hasOwnProperty.call(s, a = a.substring(4))) {\n          let r = e[t.replace(\"set:\", \"get:\")],\n            n = e[t.replace(\"get:\", \"set:\")];\n          Object.defineProperty(s, a, {\n            get: function () {\n              return r(this[THIS]);\n            },\n            set: function (e) {\n              n(this[THIS], e);\n            },\n            enumerable: !0\n          });\n        }\n      } else \"constructor\" === a ? (s[a] = function () {\n        return n(arguments.length), o(...arguments);\n      }).original = o : (s[a] = function () {\n        for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          e[_key5] = arguments[_key5];\n        }\n        return n(e.length), o(this[THIS], ...e);\n      }).original = o;\n    } else /^(get|set):/.test(a) ? Object.prototype.hasOwnProperty.call(s, a = a.substring(4)) || Object.defineProperty(s, a, {\n      get: e[t.replace(\"set:\", \"get:\")],\n      set: e[t.replace(\"get:\", \"set:\")],\n      enumerable: !0\n    }) : \"function\" == typeof o && o !== n ? (s[a] = function () {\n      return n(arguments.length), o(...arguments);\n    }).original = o : s[a] = o;\n  }\n  return r;\n}\nloader.instantiate = instantiate$1, loader.instantiateSync = instantiateSync, loader.instantiateStreaming = instantiateStreaming, loader.demangle = demangle;\nconst {\n  instantiate: instantiate\n} = loader;\nfunction loadWebAssembly() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (!loadWebAssembly.supported) return null;\n  var t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);\n  return instantiate(new Response(new Blob([t], {\n    type: \"application/wasm\"\n  })), e);\n}\nloadWebAssembly.supported = \"undefined\" != typeof WebAssembly;\nvar rabinWasm = loadWebAssembly;\nconst Rabin = rabin$1,\n  getRabin = rabinWasm,\n  create = async (e, t, r, n, o) => {\n    const i = await getRabin();\n    return new Rabin(i, e, t, r, n, o);\n  };\nvar src$1 = {\n  Rabin: Rabin,\n  create: create\n};\nasync function* rabinChunker(e, t) {\n  let r, n, o;\n  if (t.minChunkSize && t.maxChunkSize && t.avgChunkSize) o = t.avgChunkSize, r = t.minChunkSize, n = t.maxChunkSize;else {\n    if (!t.avgChunkSize) throw errCode(new Error(\"please specify an average chunk size\"), \"ERR_INVALID_AVG_CHUNK_SIZE\");\n    o = t.avgChunkSize, r = o / 3, n = o + o / 2;\n  }\n  if (r < 16) throw errCode(new Error(\"rabin min must be greater than 16\"), \"ERR_INVALID_MIN_CHUNK_SIZE\");\n  n < r && (n = r), o < r && (o = r);\n  const i = Math.floor(Math.log2(o));\n  for await (const o of rabin(e, {\n    min: r,\n    max: n,\n    bits: i,\n    window: t.window,\n    polynomial: t.polynomial\n  })) yield o;\n}\nasync function* rabin(e, t) {\n  const r = await src$1.create(t.bits, t.min, t.max, t.window),\n    n = new BufferList_1();\n  for await (const t of e) {\n    n.append(t);\n    const e = r.fingerprint(t);\n    for (let t = 0; t < e.length; t++) {\n      const r = e[t],\n        o = n.slice(0, r);\n      n.consume(r), yield o;\n    }\n  }\n  n.length && (yield n.slice(0));\n}\nasync function* fixedSizeChunker(e, t) {\n  let r = new BufferList_1(),\n    n = 0,\n    o = !1;\n  const i = t.maxChunkSize;\n  for await (const t of e) for (r.append(t), n += t.length; n >= i;) if (yield r.slice(0, i), o = !0, i === r.length) r = new BufferList_1(), n = 0;else {\n    const e = new BufferList_1();\n    e.append(r.shallowSlice(i)), r = e, n -= i;\n  }\n  o && !n || (yield r.slice(0, n));\n}\nconst identity = from$1({\n  prefix: \"\\0\",\n  name: \"identity\",\n  encode: e => toString$1(e),\n  decode: e => fromString$3(e)\n});\nvar identityBase = Object.freeze({\n  __proto__: null,\n  identity: identity\n});\nconst base2 = rfc4648({\n  prefix: \"0\",\n  name: \"base2\",\n  alphabet: \"01\",\n  bitsPerChar: 1\n});\nvar base2$1 = Object.freeze({\n  __proto__: null,\n  base2: base2\n});\nconst base8 = rfc4648({\n  prefix: \"7\",\n  name: \"base8\",\n  alphabet: \"01234567\",\n  bitsPerChar: 3\n});\nvar base8$1 = Object.freeze({\n  __proto__: null,\n  base8: base8\n});\nconst base10 = baseX({\n  prefix: \"9\",\n  name: \"base10\",\n  alphabet: \"0123456789\"\n});\nvar base10$1 = Object.freeze({\n  __proto__: null,\n  base10: base10\n});\nconst base16 = rfc4648({\n    prefix: \"f\",\n    name: \"base16\",\n    alphabet: \"0123456789abcdef\",\n    bitsPerChar: 4\n  }),\n  base16upper = rfc4648({\n    prefix: \"F\",\n    name: \"base16upper\",\n    alphabet: \"0123456789ABCDEF\",\n    bitsPerChar: 4\n  });\nvar base16$1 = Object.freeze({\n  __proto__: null,\n  base16: base16,\n  base16upper: base16upper\n});\nconst base36 = baseX({\n    prefix: \"k\",\n    name: \"base36\",\n    alphabet: \"0123456789abcdefghijklmnopqrstuvwxyz\"\n  }),\n  base36upper = baseX({\n    prefix: \"K\",\n    name: \"base36upper\",\n    alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  });\nvar base36$1 = Object.freeze({\n  __proto__: null,\n  base36: base36,\n  base36upper: base36upper\n});\nconst base64 = rfc4648({\n    prefix: \"m\",\n    name: \"base64\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    bitsPerChar: 6\n  }),\n  base64pad = rfc4648({\n    prefix: \"M\",\n    name: \"base64pad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    bitsPerChar: 6\n  }),\n  base64url = rfc4648({\n    prefix: \"u\",\n    name: \"base64url\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n    bitsPerChar: 6\n  }),\n  base64urlpad = rfc4648({\n    prefix: \"U\",\n    name: \"base64urlpad\",\n    alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\",\n    bitsPerChar: 6\n  });\nvar base64$1 = Object.freeze({\n  __proto__: null,\n  base64: base64,\n  base64pad: base64pad,\n  base64url: base64url,\n  base64urlpad: base64urlpad\n});\nconst alphabet = Array.from(\"🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂\"),\n  alphabetBytesToChars = alphabet.reduce((e, t, r) => (e[r] = t, e), []),\n  alphabetCharsToBytes = alphabet.reduce((e, t, r) => (e[t.codePointAt(0)] = r, e), []);\nfunction encode$1(e) {\n  return e.reduce((e, t) => e += alphabetBytesToChars[t], \"\");\n}\nfunction decode$1(e) {\n  const t = [];\n  for (const r of e) {\n    const e = alphabetCharsToBytes[r.codePointAt(0)];\n    if (void 0 === e) throw new Error(`Non-base256emoji character: ${r}`);\n    t.push(e);\n  }\n  return new Uint8Array(t);\n}\nconst base256emoji = from$1({\n  prefix: \"🚀\",\n  name: \"base256emoji\",\n  encode: encode$1,\n  decode: decode$1\n});\nvar base256emoji$1 = Object.freeze({\n  __proto__: null,\n  base256emoji: base256emoji\n});\nnew TextEncoder(), new TextDecoder();\nconst bases = {\n  ...identityBase,\n  ...base2$1,\n  ...base8$1,\n  ...base10$1,\n  ...base16$1,\n  ...base32$1,\n  ...base36$1,\n  ...base58,\n  ...base64$1,\n  ...base256emoji$1\n};\nfunction allocUnsafe() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return null != globalThis.Buffer && null != globalThis.Buffer.allocUnsafe ? globalThis.Buffer.allocUnsafe(e) : new Uint8Array(e);\n}\nfunction createCodec(e, t, r, n) {\n  return {\n    name: e,\n    prefix: t,\n    encoder: {\n      name: e,\n      prefix: t,\n      encode: r\n    },\n    decoder: {\n      decode: n\n    }\n  };\n}\nconst string = createCodec(\"utf8\", \"u\", e => \"u\" + new TextDecoder(\"utf8\").decode(e), e => new TextEncoder().encode(e.substring(1))),\n  ascii = createCodec(\"ascii\", \"a\", e => {\n    let t = \"a\";\n    for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);\n    return t;\n  }, e => {\n    const t = allocUnsafe((e = e.substring(1)).length);\n    for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);\n    return t;\n  }),\n  BASES = {\n    utf8: string,\n    \"utf-8\": string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii: ascii,\n    binary: ascii,\n    ...bases\n  };\nfunction fromString(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n  const r = BASES[t];\n  if (!r) throw new Error(`Unsupported encoding \"${t}\"`);\n  return \"utf8\" !== t && \"utf-8\" !== t || null == globalThis.Buffer || null == globalThis.Buffer.from ? r.decoder.decode(`${r.prefix}${e}`) : globalThis.Buffer.from(e, \"utf8\");\n}\nvar fromString$1 = Object.freeze({\n  __proto__: null,\n  fromString: fromString\n});\nasync function* validateChunks(e) {\n  for await (const t of e) {\n    if (void 0 === t.length) throw errCode(new Error(\"Content was invalid\"), \"ERR_INVALID_CONTENT\");\n    if (\"string\" == typeof t || t instanceof String) yield fromString(t.toString());else if (Array.isArray(t)) yield Uint8Array.from(t);else {\n      if (!(t instanceof Uint8Array)) throw errCode(new Error(\"Content was invalid\"), \"ERR_INVALID_CONTENT\");\n      yield t;\n    }\n  }\n}\nfunction isIterable(e) {\n  return Symbol.iterator in e;\n}\nfunction isAsyncIterable(e) {\n  return Symbol.asyncIterator in e;\n}\nfunction contentAsAsyncIterable(e) {\n  try {\n    if (e instanceof Uint8Array) return async function* () {\n      yield e;\n    }();\n    if (isIterable(e)) return async function* () {\n      yield* e;\n    }();\n    if (isAsyncIterable(e)) return e;\n  } catch {\n    throw errCode(new Error(\"Content was invalid\"), \"ERR_INVALID_CONTENT\");\n  }\n  throw errCode(new Error(\"Content was invalid\"), \"ERR_INVALID_CONTENT\");\n}\nasync function* dagBuilder(e, t, r) {\n  for await (const n of e) if (n.path && (\"./\" === n.path.substring(0, 2) && (r.wrapWithDirectory = !0), n.path = n.path.split(\"/\").filter(e => e && \".\" !== e).join(\"/\")), n.content) {\n    let e, o;\n    e = \"function\" == typeof r.chunker ? r.chunker : \"rabin\" === r.chunker ? rabinChunker : fixedSizeChunker, o = \"function\" == typeof r.chunkValidator ? r.chunkValidator : validateChunks;\n    const i = {\n      path: n.path,\n      mtime: n.mtime,\n      mode: n.mode,\n      content: e(o(contentAsAsyncIterable(n.content), r), r)\n    };\n    yield () => fileBuilder(i, t, r);\n  } else {\n    if (!n.path) throw new Error(\"Import candidate must have content or path or both\");\n    {\n      const e = {\n        path: n.path,\n        mtime: n.mtime,\n        mode: n.mode\n      };\n      yield () => dirBuilder(e, t, r);\n    }\n  }\n}\nclass Dir {\n  constructor(e, t) {\n    this.options = t || {}, this.root = e.root, this.dir = e.dir, this.path = e.path, this.dirty = e.dirty, this.flat = e.flat, this.parent = e.parent, this.parentKey = e.parentKey, this.unixfs = e.unixfs, this.mode = e.mode, this.mtime = e.mtime, this.cid = void 0, this.size = void 0;\n  }\n  async put(e, t) {}\n  get(e) {\n    return Promise.resolve(this);\n  }\n  async *eachChildSeries() {}\n  async *flush(e) {}\n}\nclass DirFlat extends Dir {\n  constructor(e, t) {\n    super(e, t), this._children = {};\n  }\n  async put(e, t) {\n    this.cid = void 0, this.size = void 0, this._children[e] = t;\n  }\n  get(e) {\n    return Promise.resolve(this._children[e]);\n  }\n  childCount() {\n    return Object.keys(this._children).length;\n  }\n  directChildrenCount() {\n    return this.childCount();\n  }\n  onlyChild() {\n    return this._children[Object.keys(this._children)[0]];\n  }\n  async *eachChildSeries() {\n    const e = Object.keys(this._children);\n    for (let t = 0; t < e.length; t++) {\n      const r = e[t];\n      yield {\n        key: r,\n        child: this._children[r]\n      };\n    }\n  }\n  async *flush(e) {\n    const t = Object.keys(this._children),\n      r = [];\n    for (let n = 0; n < t.length; n++) {\n      let o = this._children[t[n]];\n      if (o instanceof Dir) for await (const t of o.flush(e)) o = t, yield o;\n      null != o.size && o.cid && r.push({\n        Name: t[n],\n        Tsize: o.size,\n        Hash: o.cid\n      });\n    }\n    const n = new UnixFS({\n        type: \"directory\",\n        mtime: this.mtime,\n        mode: this.mode\n      }),\n      o = {\n        Data: n.marshal(),\n        Links: r\n      },\n      i = encode$2(prepare(o)),\n      s = await persist(i, e, this.options),\n      a = i.length + o.Links.reduce((e, t) => e + (null == t.Tsize ? 0 : t.Tsize), 0);\n    this.cid = s, this.size = a, yield {\n      cid: s,\n      unixfs: n,\n      path: this.path,\n      size: a\n    };\n  }\n}\nconst BITS_PER_BYTE = 7;\nvar sparseArray = class {\n  constructor() {\n    this._bitArrays = [], this._data = [], this._length = 0, this._changedLength = !1, this._changedData = !1;\n  }\n  set(e, t) {\n    let r = this._internalPositionFor(e, !1);\n    if (void 0 === t) -1 !== r && (this._unsetInternalPos(r), this._unsetBit(e), this._changedLength = !0, this._changedData = !0);else {\n      let n = !1;\n      -1 === r ? (r = this._data.length, this._setBit(e), this._changedData = !0) : n = !0, this._setInternalPos(r, e, t, n), this._changedLength = !0;\n    }\n  }\n  unset(e) {\n    this.set(e, void 0);\n  }\n  get(e) {\n    this._sortData();\n    const t = this._internalPositionFor(e, !0);\n    if (-1 !== t) return this._data[t][1];\n  }\n  push(e) {\n    return this.set(this.length, e), this.length;\n  }\n  get length() {\n    if (this._sortData(), this._changedLength) {\n      const e = this._data[this._data.length - 1];\n      this._length = e ? e[0] + 1 : 0, this._changedLength = !1;\n    }\n    return this._length;\n  }\n  forEach(e) {\n    let t = 0;\n    for (; t < this.length;) e(this.get(t), t, this), t++;\n  }\n  map(e) {\n    let t = 0,\n      r = new Array(this.length);\n    for (; t < this.length;) r[t] = e(this.get(t), t, this), t++;\n    return r;\n  }\n  reduce(e, t) {\n    let r = 0,\n      n = t;\n    for (; r < this.length;) {\n      n = e(n, this.get(r), r), r++;\n    }\n    return n;\n  }\n  find(e) {\n    let t,\n      r,\n      n = 0;\n    for (; n < this.length && !t;) r = this.get(n), t = e(r), n++;\n    return t ? r : void 0;\n  }\n  _internalPositionFor(e, t) {\n    const r = this._bytePosFor(e, t);\n    if (r >= this._bitArrays.length) return -1;\n    const n = this._bitArrays[r],\n      o = e - r * BITS_PER_BYTE;\n    if (!((n & 1 << o) > 0)) return -1;\n    return this._bitArrays.slice(0, r).reduce(popCountReduce, 0) + popCount(n & ~(4294967295 << o + 1)) - 1;\n  }\n  _bytePosFor(e, t) {\n    const r = Math.floor(e / BITS_PER_BYTE),\n      n = r + 1;\n    for (; !t && this._bitArrays.length < n;) this._bitArrays.push(0);\n    return r;\n  }\n  _setBit(e) {\n    const t = this._bytePosFor(e, !1);\n    this._bitArrays[t] |= 1 << e - t * BITS_PER_BYTE;\n  }\n  _unsetBit(e) {\n    const t = this._bytePosFor(e, !1);\n    this._bitArrays[t] &= ~(1 << e - t * BITS_PER_BYTE);\n  }\n  _setInternalPos(e, t, r, n) {\n    const o = this._data,\n      i = [t, r];\n    if (n) this._sortData(), o[e] = i;else {\n      if (o.length) {\n        if (o[o.length - 1][0] >= t) o.push(i);else if (o[0][0] <= t) o.unshift(i);else {\n          const e = Math.round(o.length / 2);\n          this._data = o.slice(0, e).concat(i).concat(o.slice(e));\n        }\n      } else this._data.push(i);\n      this._changedData = !0, this._changedLength = !0;\n    }\n  }\n  _unsetInternalPos(e) {\n    this._data.splice(e, 1);\n  }\n  _sortData() {\n    this._changedData && this._data.sort(sortInternal), this._changedData = !1;\n  }\n  bitField() {\n    const e = [];\n    let t,\n      r = 8,\n      n = 0,\n      o = 0;\n    const i = this._bitArrays.slice();\n    for (; i.length || n;) {\n      0 === n && (t = i.shift(), n = 7);\n      const s = Math.min(n, r);\n      o |= (t & ~(255 << s)) << 8 - r, t >>>= s, n -= s, r -= s, r && (n || i.length) || (e.push(o), o = 0, r = 8);\n    }\n    for (var s = e.length - 1; s > 0; s--) {\n      if (0 !== e[s]) break;\n      e.pop();\n    }\n    return e;\n  }\n  compactArray() {\n    return this._sortData(), this._data.map(valueOnly);\n  }\n};\nfunction popCountReduce(e, t) {\n  return e + popCount(t);\n}\nfunction popCount(e) {\n  let t = e;\n  return t -= t >> 1 & 1431655765, t = (858993459 & t) + (t >> 2 & 858993459), 16843009 * (t + (t >> 4) & 252645135) >> 24;\n}\nfunction sortInternal(e, t) {\n  return e[0] - t[0];\n}\nfunction valueOnly(e) {\n  return e[1];\n}\nvar require$$1$1 = getAugmentedNamespace(fromString$1);\nconst SparseArray = sparseArray,\n  {\n    fromString: uint8ArrayFromString\n  } = require$$1$1;\nclass Bucket$1 {\n  constructor(e, t) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this._options = e, this._popCount = 0, this._parent = t, this._posAtParent = r, this._children = new SparseArray(), this.key = null;\n  }\n  async put(e, t) {\n    const r = await this._findNewBucketAndPos(e);\n    await r.bucket._putAt(r, e, t);\n  }\n  async get(e) {\n    const t = await this._findChild(e);\n    if (t) return t.value;\n  }\n  async del(e) {\n    const t = await this._findPlace(e),\n      r = t.bucket._at(t.pos);\n    r && r.key === e && t.bucket._delAt(t.pos);\n  }\n  leafCount() {\n    return this._children.compactArray().reduce((e, t) => t instanceof Bucket$1 ? e + t.leafCount() : e + 1, 0);\n  }\n  childrenCount() {\n    return this._children.length;\n  }\n  onlyChild() {\n    return this._children.get(0);\n  }\n  *eachLeafSeries() {\n    const e = this._children.compactArray();\n    for (const t of e) t instanceof Bucket$1 ? yield* t.eachLeafSeries() : yield t;\n    return [];\n  }\n  serialize(e, t) {\n    return t(this._children.reduce((r, n, o) => (n && (n instanceof Bucket$1 ? r.push(n.serialize(e, t)) : r.push(e(n, o))), r), []));\n  }\n  asyncTransform(e, t) {\n    return asyncTransformBucket(this, e, t);\n  }\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, \"  \");\n  }\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n  async _findChild(e) {\n    const t = await this._findPlace(e),\n      r = t.bucket._at(t.pos);\n    if (!(r instanceof Bucket$1)) return r && r.key === e ? r : void 0;\n  }\n  async _findPlace(e) {\n    const t = this._options.hash(\"string\" == typeof e ? uint8ArrayFromString(e) : e),\n      r = await t.take(this._options.bits),\n      n = this._children.get(r);\n    return n instanceof Bucket$1 ? n._findPlace(t) : {\n      bucket: this,\n      pos: r,\n      hash: t,\n      existingChild: n\n    };\n  }\n  async _findNewBucketAndPos(e) {\n    const t = await this._findPlace(e);\n    if (t.existingChild && t.existingChild.key !== e) {\n      const e = new Bucket$1(this._options, t.bucket, t.pos);\n      t.bucket._putObjectAt(t.pos, e);\n      const r = await e._findPlace(t.existingChild.hash);\n      return r.bucket._putAt(r, t.existingChild.key, t.existingChild.value), e._findNewBucketAndPos(t.hash);\n    }\n    return t;\n  }\n  _putAt(e, t, r) {\n    this._putObjectAt(e.pos, {\n      key: t,\n      value: r,\n      hash: e.hash\n    });\n  }\n  _putObjectAt(e, t) {\n    this._children.get(e) || this._popCount++, this._children.set(e, t);\n  }\n  _delAt(e) {\n    if (-1 === e) throw new Error(\"Invalid position\");\n    this._children.get(e) && this._popCount--, this._children.unset(e), this._level();\n  }\n  _level() {\n    if (this._parent && this._popCount <= 1) if (1 === this._popCount) {\n      const e = this._children.find(exists);\n      if (e && !(e instanceof Bucket$1)) {\n        const t = e.hash;\n        t.untake(this._options.bits);\n        const r = {\n          pos: this._posAtParent,\n          hash: t,\n          bucket: this._parent\n        };\n        this._parent._putAt(r, e.key, e.value);\n      }\n    } else this._parent._delAt(this._posAtParent);\n  }\n  _at(e) {\n    return this._children.get(e);\n  }\n}\nfunction exists(e) {\n  return Boolean(e);\n}\nfunction mapNode(e, t) {\n  return e.key;\n}\nfunction reduceNodes(e) {\n  return e;\n}\nasync function asyncTransformBucket(e, t, r) {\n  const n = [];\n  for (const o of e._children.compactArray()) if (o instanceof Bucket$1) await asyncTransformBucket(o, t, r);else {\n    const r = await t(o);\n    n.push({\n      bitField: e._children.bitField(),\n      children: r\n    });\n  }\n  return r(n);\n}\nvar bucket = Bucket$1,\n  consumableHash = {\n    exports: {}\n  };\nconst START_MASKS = [255, 254, 252, 248, 240, 224, 192, 128],\n  STOP_MASKS = [1, 3, 7, 15, 31, 63, 127, 255];\nvar consumableBuffer = class {\n  constructor(e) {\n    this._value = e, this._currentBytePos = e.length - 1, this._currentBitPos = 7;\n  }\n  availableBits() {\n    return this._currentBitPos + 1 + 8 * this._currentBytePos;\n  }\n  totalBits() {\n    return 8 * this._value.length;\n  }\n  take(e) {\n    let t = e,\n      r = 0;\n    for (; t && this._haveBits();) {\n      const e = this._value[this._currentBytePos],\n        n = this._currentBitPos + 1,\n        o = Math.min(n, t);\n      r = (r << o) + byteBitsToInt(e, n - o, o), t -= o, this._currentBitPos -= o, this._currentBitPos < 0 && (this._currentBitPos = 7, this._currentBytePos--);\n    }\n    return r;\n  }\n  untake(e) {\n    for (this._currentBitPos += e; this._currentBitPos > 7;) this._currentBitPos -= 8, this._currentBytePos += 1;\n  }\n  _haveBits() {\n    return this._currentBytePos >= 0;\n  }\n};\nfunction byteBitsToInt(e, t, r) {\n  return (e & maskFor(t, r)) >>> t;\n}\nfunction maskFor(e, t) {\n  return START_MASKS[e] & STOP_MASKS[Math.min(t + e - 1, 7)];\n}\nfunction concat(e, t) {\n  t || (t = e.reduce((e, t) => e + t.length, 0));\n  const r = allocUnsafe(t);\n  let n = 0;\n  for (const t of e) r.set(t, n), n += t.length;\n  return r;\n}\nvar concat$1 = Object.freeze({\n    __proto__: null,\n    concat: concat\n  }),\n  require$$1 = getAugmentedNamespace(concat$1);\nconst ConsumableBuffer = consumableBuffer,\n  {\n    concat: uint8ArrayConcat\n  } = require$$1;\nfunction wrapHash$1(e) {\n  return function (t) {\n    return t instanceof InfiniteHash ? t : new InfiniteHash(t, e);\n  };\n}\nclass InfiniteHash {\n  constructor(e, t) {\n    if (!(e instanceof Uint8Array)) throw new Error(\"can only hash Uint8Arrays\");\n    this._value = e, this._hashFn = t, this._depth = -1, this._availableBits = 0, this._currentBufferIndex = 0, this._buffers = [];\n  }\n  async take(e) {\n    let t = e;\n    for (; this._availableBits < t;) await this._produceMoreBits();\n    let r = 0;\n    for (; t > 0;) {\n      const e = this._buffers[this._currentBufferIndex],\n        n = Math.min(e.availableBits(), t);\n      r = (r << n) + e.take(n), t -= n, this._availableBits -= n, 0 === e.availableBits() && this._currentBufferIndex++;\n    }\n    return r;\n  }\n  untake(e) {\n    let t = e;\n    for (; t > 0;) {\n      const e = this._buffers[this._currentBufferIndex],\n        r = Math.min(e.totalBits() - e.availableBits(), t);\n      e.untake(r), t -= r, this._availableBits += r, this._currentBufferIndex > 0 && e.totalBits() === e.availableBits() && (this._depth--, this._currentBufferIndex--);\n    }\n  }\n  async _produceMoreBits() {\n    this._depth++;\n    const e = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value,\n      t = await this._hashFn(e),\n      r = new ConsumableBuffer(t);\n    this._buffers.push(r), this._availableBits += r.availableBits();\n  }\n}\nconsumableHash.exports = wrapHash$1, consumableHash.exports.InfiniteHash = InfiniteHash;\nconst Bucket = bucket,\n  wrapHash = consumableHash.exports;\nfunction createHAMT(e) {\n  if (!e || !e.hashFn) throw new Error(\"please define an options.hashFn\");\n  const t = {\n    bits: e.bits || 8,\n    hash: wrapHash(e.hashFn)\n  };\n  return new Bucket(t);\n}\nvar src = {\n  createHAMT: createHAMT,\n  Bucket: Bucket\n};\nclass DirSharded extends Dir {\n  constructor(e, t) {\n    super(e, t), this._bucket = src.createHAMT({\n      hashFn: t.hamtHashFn,\n      bits: t.hamtBucketBits\n    });\n  }\n  async put(e, t) {\n    await this._bucket.put(e, t);\n  }\n  get(e) {\n    return this._bucket.get(e);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {\n      key: e,\n      value: t\n    } of this._bucket.eachLeafSeries()) yield {\n      key: e,\n      child: t\n    };\n  }\n  async *flush(e) {\n    for await (const t of flush(this._bucket, e, this, this.options)) yield {\n      ...t,\n      path: this.path\n    };\n  }\n}\nasync function* flush(e, t, r, n) {\n  const o = e._children,\n    i = [];\n  let s = 0;\n  for (let e = 0; e < o.length; e++) {\n    const r = o.get(e);\n    if (!r) continue;\n    const a = e.toString(16).toUpperCase().padStart(2, \"0\");\n    if (r instanceof src.Bucket) {\n      let e;\n      for await (const o of await flush(r, t, null, n)) e = o;\n      if (!e) throw new Error(\"Could not flush sharded directory, no subshard found\");\n      i.push({\n        Name: a,\n        Tsize: e.size,\n        Hash: e.cid\n      }), s += e.size;\n    } else if (\"function\" == typeof r.value.flush) {\n      const e = r.value;\n      let n;\n      for await (const r of e.flush(t)) n = r, yield n;\n      const o = a + r.key;\n      i.push({\n        Name: o,\n        Tsize: n.size,\n        Hash: n.cid\n      }), s += n.size;\n    } else {\n      const e = r.value;\n      if (!e.cid) continue;\n      const t = a + r.key,\n        n = e.size;\n      i.push({\n        Name: t,\n        Tsize: n,\n        Hash: e.cid\n      }), s += n;\n    }\n  }\n  const a = Uint8Array.from(o.bitField().reverse()),\n    c = new UnixFS({\n      type: \"hamt-sharded-directory\",\n      data: a,\n      fanout: e.tableSize(),\n      hashType: n.hamtHashCode,\n      mtime: r && r.mtime,\n      mode: r && r.mode\n    }),\n    u = encode$2(prepare({\n      Data: c.marshal(),\n      Links: i\n    })),\n    f = await persist(u, t, n),\n    l = u.length + s;\n  yield {\n    cid: f,\n    unixfs: c,\n    size: l\n  };\n}\nasync function flatToShard(e, t, r, n) {\n  let o = t;\n  t instanceof DirFlat && t.directChildrenCount() >= r && (o = await convertToShard(t, n));\n  const i = o.parent;\n  if (i) {\n    if (o !== t) {\n      if (e && (e.parent = o), !o.parentKey) throw new Error(\"No parent key found\");\n      await i.put(o.parentKey, o);\n    }\n    return flatToShard(o, i, r, n);\n  }\n  return o;\n}\nasync function convertToShard(e, t) {\n  const r = new DirSharded({\n    root: e.root,\n    dir: !0,\n    parent: e.parent,\n    parentKey: e.parentKey,\n    path: e.path,\n    dirty: e.dirty,\n    flat: !1,\n    mtime: e.mtime,\n    mode: e.mode\n  }, t);\n  for await (const {\n    key: t,\n    child: n\n  } of e.eachChildSeries()) await r.put(t, n);\n  return r;\n}\nconst toPathComponents = function () {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  return (e.trim().match(/([^\\\\/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nasync function addToTree(e, t, r) {\n  const n = toPathComponents(e.path || \"\"),\n    o = n.length - 1;\n  let i = t,\n    s = \"\";\n  for (let a = 0; a < n.length; a++) {\n    const c = n[a];\n    s += `${s ? \"/\" : \"\"}${c}`;\n    const u = a === o;\n    if (i.dirty = !0, i.cid = void 0, i.size = void 0, u) await i.put(c, e), t = await flatToShard(null, i, r.shardSplitThreshold, r);else {\n      let e = await i.get(c);\n      e && e instanceof Dir || (e = new DirFlat({\n        root: !1,\n        dir: !0,\n        parent: i,\n        parentKey: c,\n        path: s,\n        dirty: !0,\n        flat: !0,\n        mtime: e && e.unixfs && e.unixfs.mtime,\n        mode: e && e.unixfs && e.unixfs.mode\n      }, r)), await i.put(c, e), i = e;\n    }\n  }\n  return t;\n}\nasync function* flushAndYield(e, t) {\n  e instanceof Dir ? yield* e.flush(t) : e && e.unixfs && e.unixfs.isDirectory() && (yield e);\n}\nasync function* treeBuilder(e, t, r) {\n  let n = new DirFlat({\n    root: !0,\n    dir: !0,\n    path: \"\",\n    dirty: !0,\n    flat: !0\n  }, r);\n  for await (const t of e) t && (n = await addToTree(t, n, r), t.unixfs && t.unixfs.isDirectory() || (yield t));\n  if (r.wrapWithDirectory) yield* flushAndYield(n, t);else for await (const e of n.eachChildSeries()) e && (yield* flushAndYield(e.child, t));\n}\nasync function* importer(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const n = defaultOptions$1(r);\n  let o, i, s;\n  o = \"function\" == typeof r.dagBuilder ? r.dagBuilder : dagBuilder, i = \"function\" == typeof r.treeBuilder ? r.treeBuilder : treeBuilder, s = Symbol.asyncIterator in e || Symbol.iterator in e ? e : [e];\n  for await (const e of i(itParallelBatch(o(s, t, n), n.fileImportConcurrency), t, n)) yield {\n    cid: e.cid,\n    path: e.path,\n    unixfs: e.unixfs,\n    size: e.size\n  };\n}\nasync function* browserReadableStreamToIt$1(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const r = e.getReader();\n  try {\n    for (;;) {\n      const e = await r.read();\n      if (e.done) return;\n      yield e.value;\n    }\n  } finally {\n    !0 !== t.preventCancel && r.cancel(), r.releaseLock();\n  }\n}\nvar browserReadablestreamToIt = browserReadableStreamToIt$1;\nconst browserReadableStreamToIt = browserReadablestreamToIt;\nfunction blobToIt(e) {\n  return \"function\" == typeof e.stream ? browserReadableStreamToIt(e.stream()) : browserReadableStreamToIt(new Response(e).body);\n}\nvar blobToIt_1 = blobToIt;\nfunction peekableIterator(e) {\n  const [t, r] = e[Symbol.asyncIterator] ? [e[Symbol.asyncIterator](), Symbol.asyncIterator] : [e[Symbol.iterator](), Symbol.iterator],\n    n = [];\n  return {\n    peek: () => t.next(),\n    push: e => {\n      n.push(e);\n    },\n    next: () => n.length ? {\n      done: !1,\n      value: n.shift()\n    } : t.next(),\n    [r]() {\n      return this;\n    }\n  };\n}\nvar itPeekable = peekableIterator;\nconst map = async function* (e, t) {\n  for await (const r of e) yield t(r);\n};\nvar itMap = map;\nfunction isBytes$1(e) {\n  return ArrayBuffer.isView(e) || e instanceof ArrayBuffer;\n}\nfunction isBlob$2(e) {\n  return e.constructor && (\"Blob\" === e.constructor.name || \"File\" === e.constructor.name) && \"function\" == typeof e.stream;\n}\nfunction isFileObject(e) {\n  return \"object\" == typeof e && (e.path || e.content);\n}\nconst isReadableStream = e => e && \"function\" == typeof e.getReader;\nasync function* toAsyncIterable$1(e) {\n  yield e;\n}\nasync function normaliseContent(e) {\n  if (isBytes$1(e)) return toAsyncIterable$1(toBytes(e));\n  if (\"string\" == typeof e || e instanceof String) return toAsyncIterable$1(toBytes(e.toString()));\n  if (isBlob$2(e)) return blobToIt_1(e);\n  if (isReadableStream(e) && (e = browserReadablestreamToIt(e)), Symbol.iterator in e || Symbol.asyncIterator in e) {\n    const t = itPeekable(e),\n      {\n        value: r,\n        done: n\n      } = await t.peek();\n    if (n) return toAsyncIterable$1(new Uint8Array(0));\n    if (t.push(r), Number.isInteger(r)) return toAsyncIterable$1(Uint8Array.from(await itAll(t)));\n    if (isBytes$1(r) || \"string\" == typeof r || r instanceof String) return itMap(t, toBytes);\n  }\n  throw errCode(new Error(`Unexpected input: ${e}`), \"ERR_UNEXPECTED_INPUT\");\n}\nfunction toBytes(e) {\n  return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer ? new Uint8Array(e) : Array.isArray(e) ? Uint8Array.from(e) : fromString(e.toString());\n}\nasync function* normaliseCandidateSingle(e, t) {\n  if (null == e) throw errCode(new Error(`Unexpected input: ${e}`), \"ERR_UNEXPECTED_INPUT\");\n  if (\"string\" == typeof e || e instanceof String) yield toFileObject$1(e.toString(), t);else if (isBytes$1(e) || isBlob$2(e)) yield toFileObject$1(e, t);else {\n    if (isReadableStream(e) && (e = browserReadablestreamToIt(e)), Symbol.iterator in e || Symbol.asyncIterator in e) {\n      const r = itPeekable(e),\n        {\n          value: n,\n          done: o\n        } = await r.peek();\n      if (o) return void (yield {\n        content: []\n      });\n      if (r.push(n), Number.isInteger(n) || isBytes$1(n) || \"string\" == typeof n || n instanceof String) return void (yield toFileObject$1(r, t));\n      throw errCode(new Error(\"Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead\"), \"ERR_UNEXPECTED_INPUT\");\n    }\n    if (!isFileObject(e)) throw errCode(new Error('Unexpected input: cannot convert \"' + typeof e + '\" into ImportCandidate'), \"ERR_UNEXPECTED_INPUT\");\n    yield toFileObject$1(e, t);\n  }\n}\nasync function toFileObject$1(e, t) {\n  const {\n      path: r,\n      mode: n,\n      mtime: o,\n      content: i\n    } = e,\n    s = {\n      path: r || \"\",\n      mode: parseMode(n),\n      mtime: parseMtime(o)\n    };\n  return i ? s.content = await t(i) : r || (s.content = await t(e)), s;\n}\nfunction normaliseInput$1(e) {\n  return normaliseCandidateSingle(e, normaliseContent);\n}\nasync function* normaliseCandidateMultiple(e, t) {\n  if (\"string\" == typeof e || e instanceof String || isBytes$1(e) || isBlob$2(e) || e._readableState) throw errCode(new Error(\"Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead\"), \"ERR_UNEXPECTED_INPUT\");\n  if (isReadableStream(e) && (e = browserReadablestreamToIt(e)), Symbol.iterator in e || Symbol.asyncIterator in e) {\n    const r = itPeekable(e),\n      {\n        value: n,\n        done: o\n      } = await r.peek();\n    if (o) return void (yield* []);\n    if (r.push(n), Number.isInteger(n)) throw errCode(new Error(\"Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead\"), \"ERR_UNEXPECTED_INPUT\");\n    if (n._readableState) return void (yield* itMap(r, e => toFileObject({\n      content: e\n    }, t)));\n    if (isBytes$1(n)) return void (yield toFileObject({\n      content: r\n    }, t));\n    if (isFileObject(n) || n[Symbol.iterator] || n[Symbol.asyncIterator] || isReadableStream(n) || isBlob$2(n)) return void (yield* itMap(r, e => toFileObject(e, t)));\n  }\n  if (isFileObject(e)) throw errCode(new Error(\"Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead\"), \"ERR_UNEXPECTED_INPUT\");\n  throw errCode(new Error(\"Unexpected input: \" + typeof e), \"ERR_UNEXPECTED_INPUT\");\n}\nasync function toFileObject(e, t) {\n  const {\n      path: r,\n      mode: n,\n      mtime: o,\n      content: i\n    } = e,\n    s = {\n      path: r || \"\",\n      mode: parseMode(n),\n      mtime: parseMtime(o)\n    };\n  return i ? s.content = await t(i) : r || (s.content = await t(e)), s;\n}\nfunction normaliseInput(e) {\n  return normaliseCandidateMultiple(e, normaliseContent);\n}\nfunction isBytes(e) {\n  return ArrayBuffer.isView(e) || e instanceof ArrayBuffer;\n}\nfunction isBlob$1(e) {\n  return Boolean(e.constructor) && (\"Blob\" === e.constructor.name || \"File\" === e.constructor.name) && \"function\" == typeof e.stream;\n}\nfunction isSingle(e) {\n  return \"string\" == typeof e || e instanceof String || isBytes(e) || isBlob$1(e) || \"_readableState\" in e;\n}\nfunction getNormaliser(e) {\n  return isSingle(e) ? normaliseInput$1(e) : normaliseInput(e);\n}\nconst drain = async e => {\n  for await (const t of e);\n};\nvar itDrain = drain;\nconst filter = async function* (e, t) {\n  for await (const r of e) (await t(r)) && (yield r);\n};\nvar itFilter = filter;\nconst take = async function* (e, t) {\n  let r = 0;\n  if (!(t < 1)) for await (const n of e) if (yield n, r++, r === t) return;\n};\nvar itTake = take;\nconst sortAll = (e, t) => async function* () {\n  const r = await itAll(e);\n  yield* r.sort(t);\n}();\nclass BaseBlockstore {\n  open() {\n    return Promise.reject(new Error(\".open is not implemented\"));\n  }\n  close() {\n    return Promise.reject(new Error(\".close is not implemented\"));\n  }\n  put(e, t, r) {\n    return Promise.reject(new Error(\".put is not implemented\"));\n  }\n  get(e, t) {\n    return Promise.reject(new Error(\".get is not implemented\"));\n  }\n  has(e, t) {\n    return Promise.reject(new Error(\".has is not implemented\"));\n  }\n  delete(e, t) {\n    return Promise.reject(new Error(\".delete is not implemented\"));\n  }\n  async *putMany(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for await (const {\n      key: r,\n      value: n\n    } of e) await this.put(r, n, t), yield {\n      key: r,\n      value: n\n    };\n  }\n  async *getMany(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for await (const r of e) yield this.get(r, t);\n  }\n  async *deleteMany(e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for await (const r of e) await this.delete(r, t), yield r;\n  }\n  batch() {\n    let e = [],\n      t = [];\n    return {\n      put(t, r) {\n        e.push({\n          key: t,\n          value: r\n        });\n      },\n      delete(e) {\n        t.push(e);\n      },\n      commit: async r => {\n        await itDrain(this.putMany(e, r)), e = [], await itDrain(this.deleteMany(t, r)), t = [];\n      }\n    };\n  }\n  async *_all(e, t) {\n    throw new Error(\"._all is not implemented\");\n  }\n  async *_allKeys(e, t) {\n    throw new Error(\"._allKeys is not implemented\");\n  }\n  query(e, t) {\n    let r = this._all(e, t);\n    if (null != e.prefix && (r = itFilter(r, t => t.key.toString().startsWith(e.prefix || \"\"))), Array.isArray(e.filters) && (r = e.filters.reduce((e, t) => itFilter(e, t), r)), Array.isArray(e.orders) && (r = e.orders.reduce((e, t) => sortAll(e, t), r)), null != e.offset) {\n      let t = 0;\n      r = itFilter(r, () => t++ >= (e.offset || 0));\n    }\n    return null != e.limit && (r = itTake(r, e.limit)), r;\n  }\n  queryKeys(e, t) {\n    let r = this._allKeys(e, t);\n    if (null != e.prefix && (r = itFilter(r, t => t.toString().startsWith(e.prefix || \"\"))), Array.isArray(e.filters) && (r = e.filters.reduce((e, t) => itFilter(e, t), r)), Array.isArray(e.orders) && (r = e.orders.reduce((e, t) => sortAll(e, t), r)), null != e.offset) {\n      let t = 0;\n      r = itFilter(r, () => t++ >= e.offset);\n    }\n    return null != e.limit && (r = itTake(r, e.limit)), r;\n  }\n}\nclass MemoryBlockStore extends BaseBlockstore {\n  constructor() {\n    super(), this.store = new Map();\n  }\n  async *blocks() {\n    for (const [e, t] of this.store.entries()) yield {\n      cid: CID.parse(e),\n      bytes: t\n    };\n  }\n  put(e, t) {\n    return this.store.set(e.toString(), t), Promise.resolve();\n  }\n  get(e) {\n    const t = this.store.get(e.toString());\n    if (!t) throw new Error(`block with cid ${e.toString()} no found`);\n    return Promise.resolve(t);\n  }\n  has(e) {\n    return Promise.resolve(this.store.has(e.toString()));\n  }\n  close() {\n    return this.store.clear(), Promise.resolve();\n  }\n}\nconst unixfsImporterOptionsDefault = {\n  cidVersion: 1,\n  chunker: \"fixed\",\n  maxChunkSize: 262144,\n  hasher: sha256,\n  rawLeaves: !0,\n  wrapWithDirectory: !0,\n  maxChildrenPerNode: 174\n};\nasync function pack(_ref7) {\n  let {\n    input: e,\n    blockstore: t,\n    hasher: r,\n    maxChunkSize: n,\n    maxChildrenPerNode: o,\n    wrapWithDirectory: i,\n    rawLeaves: s\n  } = _ref7;\n  if (!e || Array.isArray(e) && !e.length) throw new Error(\"missing input file(s)\");\n  const a = t || new MemoryBlockStore(),\n    c = await itLast(pipe$1(getNormaliser(e), e => importer(e, a, {\n      ...unixfsImporterOptionsDefault,\n      hasher: r || unixfsImporterOptionsDefault.hasher,\n      maxChunkSize: n || unixfsImporterOptionsDefault.maxChunkSize,\n      maxChildrenPerNode: o || unixfsImporterOptionsDefault.maxChildrenPerNode,\n      wrapWithDirectory: !1 !== i && unixfsImporterOptionsDefault.wrapWithDirectory,\n      rawLeaves: null == s ? unixfsImporterOptionsDefault.rawLeaves : s\n    })));\n  if (!c || !c.cid) throw new Error(\"given input could not be parsed correctly\");\n  const u = c.cid,\n    {\n      writer: f,\n      out: l\n    } = await CarWriter.create([u]),\n    h = l[Symbol.asyncIterator]();\n  let d;\n  return {\n    root: u,\n    out: {\n      [Symbol.asyncIterator]() {\n        if (null != d) throw new Error(\"Multiple iterator not supported\");\n        return d = (async () => {\n          for await (const e of a.blocks()) await f.put(e);\n          await f.close(), t || (await a.close());\n        })(), {\n          async next() {\n            const e = await h.next();\n            return e.done && (await d), e;\n          }\n        };\n      }\n    }\n  };\n}\nvar throttledQueue$1 = {\n  exports: {}\n};\n!function (e, t) {\n  function r(e, t, r) {\n    void 0 === r && (r = !1), r && (t /= e, e = 1);\n    var n,\n      o = [],\n      i = 0,\n      s = 0,\n      a = function () {\n        var r = i + t,\n          c = Date.now();\n        if (c < r) return void 0 !== n && clearTimeout(n), void (n = setTimeout(a, r - c));\n        i = c, s = 0;\n        for (var u = 0, f = o.splice(0, e); u < f.length; u++) {\n          var l = f[u];\n          s++, l();\n        }\n        n = o.length ? setTimeout(a, t) : void 0;\n      };\n    return function (r) {\n      return new Promise(function (c, u) {\n        var f = function () {\n            return Promise.resolve().then(r).then(c).catch(u);\n          },\n          l = Date.now();\n        void 0 === n && l - i > t && (i = l, s = 0), s++ < e ? f() : (o.push(f), void 0 === n && (n = setTimeout(a, i + t - l)));\n      });\n    };\n  }\n  Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), e.exports = r, t.default = r;\n}(throttledQueue$1, throttledQueue$1.exports);\nvar throttledQueue = getDefaultExportFromCjs(throttledQueue$1.exports);\nconst fetch = globalThis.fetch,\n  FormData = globalThis.FormData,\n  Blob$1 = globalThis.Blob,\n  File = globalThis.File,\n  Blockstore = MemoryBlockStore,\n  GATEWAY = new URL(\"https://nftstorage.link/\"),\n  toGatewayURL = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const r = t.gateway || GATEWAY;\n    return \"ipfs:\" === (e = new URL(String(e))).protocol ? new URL(`/ipfs/${e.href.slice(\"ipfs://\".length)}`, r) : e;\n  };\nclass BlockstoreCarReader {\n  constructor(e, t, r) {\n    this._version = e, this._roots = t, this._blockstore = r;\n  }\n  get version() {\n    return this._version;\n  }\n  get blockstore() {\n    return this._blockstore;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  has(e) {\n    return this._blockstore.has(e);\n  }\n  async get(e) {\n    return {\n      cid: e,\n      bytes: await this._blockstore.get(e)\n    };\n  }\n  blocks() {\n    return this._blockstore.blocks();\n  }\n  async *cids() {\n    for await (const e of this.blocks()) yield e.cid;\n  }\n}\nclass Token {\n  constructor(e, t, r) {\n    this.ipnft = e, this.url = t, this.data = r, Object.defineProperties(this, {\n      ipnft: {\n        enumerable: !0,\n        writable: !1\n      },\n      url: {\n        enumerable: !0,\n        writable: !1\n      },\n      data: {\n        enumerable: !1,\n        writable: !1\n      }\n    });\n  }\n  embed() {\n    return Token.embed(this);\n  }\n  static embed(_ref8) {\n    let {\n      data: e\n    } = _ref8;\n    return embed(e, {\n      gateway: GATEWAY\n    });\n  }\n  static async encode(e) {\n    const t = new Blockstore(),\n      [r, n] = mapTokenInputBlobs(e),\n      o = JSON.parse(JSON.stringify(n)),\n      i = JSON.parse(JSON.stringify(n));\n    for (const [e, n] of r.entries()) {\n      const r = n.name || \"blob\",\n        s = n.stream(),\n        {\n          root: a\n        } = await pack({\n          input: [{\n            path: r,\n            content: s\n          }],\n          blockstore: t,\n          wrapWithDirectory: !0\n        }),\n        c = new URL(`ipfs://${a}/${r}`),\n        u = e.split(\".\");\n      setIn(o, u, c), setIn(i, u, a);\n    }\n    const {\n        root: s\n      } = await pack({\n        input: [{\n          path: \"metadata.json\",\n          content: JSON.stringify(o)\n        }],\n        blockstore: t,\n        wrapWithDirectory: !1\n      }),\n      a = await encode$5({\n        value: {\n          ...i,\n          \"metadata.json\": s,\n          type: \"nft\"\n        },\n        codec: dagCbor,\n        hasher: sha256\n      });\n    return await t.put(a.cid, a.bytes), {\n      cid: a.cid,\n      token: new Token(a.cid.toString(), `ipfs://${a.cid}/metadata.json`, o),\n      car: new BlockstoreCarReader(1, [a.cid], t)\n    };\n  }\n}\nconst embed = (e, t) => mapWith(e, isURL, embedURL, t),\n  decode = (_ref9, n) => {\n    let {\n      ipnft: e,\n      url: t,\n      data: r\n    } = _ref9;\n    return new Token(e, t, mapWith(r, isEncodedURL, decodeURL, n));\n  },\n  isURL = e => e instanceof URL,\n  decodeURL = (e, t) => [e, new URL(t)],\n  embedURL = (e, t) => [e, toGatewayURL(t, e)],\n  isObject = e => \"object\" == typeof e && null != e,\n  isEncodedURL = (e, t, r) => \"string\" == typeof e && t.has(r.join(\".\")),\n  encode = e => {\n    const [t, r] = mapValueWith(e, isBlob, encodeBlob, new Map(), []),\n      n = new FormData();\n    for (const [e, r] of t.entries()) n.set(e, r);\n    return n.set(\"meta\", JSON.stringify(r)), n;\n  },\n  encodeBlob = (e, t, r) => (e.set(r.join(\".\"), t), [e, void 0]),\n  isBlob = e => e instanceof Blob$1,\n  mapTokenInputBlobs = e => mapValueWith(e, isBlob, encodeBlob, new Map(), []),\n  mapWith = (e, t, r, n) => {\n    const [, o] = mapValueWith(e, t, r, n, []);\n    return o;\n  },\n  mapValueWith = (e, t, r, n, o) => t(e, n, o) ? r(n, e, o) : Array.isArray(e) ? mapArrayWith(e, t, r, n, o) : isObject(e) ? mapObjectWith(e, t, r, n, o) : [n, e],\n  mapObjectWith = (e, t, r, n, o) => {\n    let i = n;\n    const s = {};\n    for (const [n, a] of Object.entries(e)) {\n      const [e, c] = mapValueWith(a, t, r, i, [...o, n]);\n      s[n] = c, i = e;\n    }\n    return [i, s];\n  },\n  mapArrayWith = (e, t, r, n, o) => {\n    const i = [];\n    let s = n;\n    for (const [n, a] of e.entries()) {\n      const [e, c] = mapValueWith(a, t, r, s, [...o, n]);\n      i[n] = c, s = e;\n    }\n    return [s, i];\n  },\n  setIn = (e, t, r) => {\n    const n = t.length - 1;\n    let o = e;\n    for (let [e, i] of t.entries()) e === n ? o[i] = r : o = o[i];\n  };\nvar token = Object.freeze({\n  __proto__: null,\n  Token: Token,\n  embed: embed,\n  decode: decode,\n  encode: encode,\n  mapWith: mapWith\n});\nconst MAX_STORE_RETRIES = 5,\n  MAX_CONCURRENT_UPLOADS = 3,\n  MAX_CHUNK_SIZE = 52428800,\n  RATE_LIMIT_REQUESTS = 30,\n  RATE_LIMIT_PERIOD = 1e4;\nfunction createRateLimiter() {\n  const e = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD);\n  return () => e(() => {});\n}\nconst globalRateLimiter = createRateLimiter();\nclass NFTStorage {\n  constructor(_ref10) {\n    let {\n      token: e,\n      did: t,\n      endpoint: r = new URL(\"https://api.nft.storage\"),\n      rateLimiter: n\n    } = _ref10;\n    this.token = e, this.endpoint = r, this.rateLimiter = n || createRateLimiter(), this.did = t;\n  }\n  static auth(_ref11) {\n    let {\n      token: e,\n      did: t\n    } = _ref11;\n    if (!e) throw new Error(\"missing token\");\n    return {\n      Authorization: `Bearer ${e}`,\n      \"X-Client\": \"nft.storage/js\",\n      ...(t ? {\n        \"x-agent-did\": t\n      } : {})\n    };\n  }\n  static async storeBlob(e, t, r) {\n    const n = new Blockstore();\n    let o;\n    try {\n      const {\n        cid: i,\n        car: s\n      } = await NFTStorage.encodeBlob(t, {\n        blockstore: n\n      });\n      await NFTStorage.storeCar(e, s, r), o = i.toString();\n    } finally {\n      await n.close();\n    }\n    return o;\n  }\n  static async storeCar(_ref12, n) {\n    let {\n      endpoint: e,\n      rateLimiter: t = globalRateLimiter,\n      ...r\n    } = _ref12;\n    let {\n      onStoredChunk: o,\n      maxRetries: i,\n      decoders: s,\n      signal: a\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const c = new URL(\"upload/\", e),\n      u = NFTStorage.auth(r),\n      f = MAX_CHUNK_SIZE,\n      l = n instanceof Blob$1 ? await TreewalkCarSplitter.fromBlob(n, f, {\n        decoders: s\n      }) : new TreewalkCarSplitter(n, f, {\n        decoders: s\n      }),\n      h = transform(MAX_CONCURRENT_UPLOADS, async function (e) {\n        const r = [];\n        for await (const t of e) r.push(t);\n        const n = new Blob$1(r, {\n            type: \"application/car\"\n          }),\n          s = await pRetry$1(async () => {\n            let e;\n            await t();\n            try {\n              e = await fetch(c.toString(), {\n                method: \"POST\",\n                headers: u,\n                body: n,\n                signal: a\n              });\n            } catch (e) {\n              throw a && a.aborted ? new AbortError_1(e) : e;\n            }\n            if (429 === e.status) throw new Error(\"rate limited\");\n            const r = await e.json();\n            if (!r.ok) {\n              if (401 === e.status) throw new AbortError_1(r.error.message);\n              throw new Error(r.error.message);\n            }\n            return r.value.cid;\n          }, {\n            retries: null == i ? MAX_STORE_RETRIES : i\n          });\n        return o && o(n.size), s;\n      });\n    let d;\n    for await (const e of h(l.cars())) d = e;\n    return d;\n  }\n  static async storeDirectory(e, t, r) {\n    const n = new Blockstore();\n    let o;\n    try {\n      const {\n        cid: i,\n        car: s\n      } = await NFTStorage.encodeDirectory(t, {\n        blockstore: n\n      });\n      await NFTStorage.storeCar(e, s, r), o = i.toString();\n    } finally {\n      await n.close();\n    }\n    return o;\n  }\n  static async store(e, t, r) {\n    const {\n      token: n,\n      car: o\n    } = await NFTStorage.encodeNFT(t);\n    return await NFTStorage.storeCar(e, o, r), n;\n  }\n  static async status(_ref13, n, o) {\n    let {\n      endpoint: e,\n      rateLimiter: t = globalRateLimiter,\n      ...r\n    } = _ref13;\n    const i = new URL(`${n}/`, e);\n    await t();\n    const s = await fetch(i.toString(), {\n      method: \"GET\",\n      headers: NFTStorage.auth(r),\n      signal: o && o.signal\n    });\n    if (429 === s.status) throw new Error(\"rate limited\");\n    const a = await s.json();\n    if (a.ok) return {\n      cid: a.value.cid,\n      deals: decodeDeals(a.value.deals),\n      size: a.value.size,\n      pin: decodePin(a.value.pin),\n      created: new Date(a.value.created)\n    };\n    throw new Error(a.error.message);\n  }\n  static async check(_ref14, r, n) {\n    let {\n      endpoint: e,\n      rateLimiter: t = globalRateLimiter\n    } = _ref14;\n    const o = new URL(`check/${r}/`, e);\n    await t();\n    const i = await fetch(o.toString(), {\n      signal: n && n.signal\n    });\n    if (429 === i.status) throw new Error(\"rate limited\");\n    const s = await i.json();\n    if (s.ok) return {\n      cid: s.value.cid,\n      deals: decodeDeals(s.value.deals),\n      pin: s.value.pin\n    };\n    throw new Error(s.error.message);\n  }\n  static async delete(_ref15, n, o) {\n    let {\n      endpoint: e,\n      rateLimiter: t = globalRateLimiter,\n      ...r\n    } = _ref15;\n    const i = new URL(`${n}/`, e);\n    await t();\n    const s = await fetch(i.toString(), {\n      method: \"DELETE\",\n      headers: NFTStorage.auth(r),\n      signal: o && o.signal\n    });\n    if (429 === s.status) throw new Error(\"rate limited\");\n    const a = await s.json();\n    if (!a.ok) throw new Error(a.error.message);\n  }\n  static async encodeNFT(e) {\n    return validateERC1155(e), Token.encode(e);\n  }\n  static async encodeBlob(e) {\n    let {\n      blockstore: t\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (0 === e.size) throw new Error(\"Content size is 0, make sure to provide some content\");\n    return packCar([toImportCandidate(\"blob\", e)], {\n      blockstore: t,\n      wrapWithDirectory: !1\n    });\n  }\n  static async encodeDirectory(e) {\n    let {\n      blockstore: t\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let r = 0;\n    const n = pipe$1(e, async function* (e) {\n        for await (const t of e) yield toImportCandidate(t.name, t), r += t.size;\n      }),\n      o = await packCar(n, {\n        blockstore: t,\n        wrapWithDirectory: !0\n      });\n    if (0 === r) throw new Error(\"Total size of files should exceed 0, make sure to provide some content\");\n    return o;\n  }\n  storeBlob(e, t) {\n    return NFTStorage.storeBlob(this, e, t);\n  }\n  storeCar(e, t) {\n    return NFTStorage.storeCar(this, e, t);\n  }\n  storeDirectory(e, t) {\n    return NFTStorage.storeDirectory(this, e, t);\n  }\n  status(e, t) {\n    return NFTStorage.status(this, e, t);\n  }\n  delete(e, t) {\n    return NFTStorage.delete(this, e, t);\n  }\n  check(e, t) {\n    return NFTStorage.check(this, e, t);\n  }\n  store(e, t) {\n    return NFTStorage.store(this, e, t);\n  }\n}\nfunction toAsyncIterable(e) {\n  return async function* () {\n    for (const t of e) yield t;\n  }();\n}\nconst validateERC1155 = _ref16 => {\n    let {\n      name: e,\n      description: t,\n      image: r,\n      decimals: n\n    } = _ref16;\n    if (\"string\" != typeof e) throw new TypeError(\"string property `name` identifying the asset is required\");\n    if (\"string\" != typeof t) throw new TypeError(\"string property `description` describing asset is required\");\n    if (!(r instanceof Blob$1)) throw new TypeError(\"property `image` must be a Blob or File object\");\n    if (r.type.startsWith(\"image/\") || console.warn(\"According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\\n\\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. `properties: { video: file }` and using 'image' field for storing a preview image for it instead.\\n\\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721\"), void 0 !== n && \"number\" != typeof n) throw new TypeError(\"property `decimals` must be an integer value\");\n  },\n  packCar = async function (e) {\n    let {\n      blockstore: t,\n      wrapWithDirectory: r\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    t = t || new Blockstore();\n    const {\n      root: n\n    } = await pack({\n      input: e,\n      blockstore: t,\n      wrapWithDirectory: r\n    });\n    return {\n      cid: n,\n      car: new BlockstoreCarReader(1, [n], t)\n    };\n  },\n  decodeDeals = e => e.map(e => {\n    const {\n      dealActivation: t,\n      dealExpiration: r,\n      lastChanged: n\n    } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...e\n    };\n    return {\n      ...e,\n      lastChanged: new Date(n),\n      ...(t && {\n        dealActivation: new Date(t)\n      }),\n      ...(r && {\n        dealExpiration: new Date(r)\n      })\n    };\n  }),\n  decodePin = e => ({\n    ...e,\n    created: new Date(e.created)\n  });\nfunction toImportCandidate(e, t) {\n  let r;\n  return {\n    path: e,\n    get content() {\n      return r = r || t.stream(), r;\n    }\n  };\n}\nexport { Blob$1 as Blob, File, FormData, NFTStorage, token as Token, createRateLimiter, toAsyncIterable, toGatewayURL };","map":{"version":3,"names":["getIterator","e","next","Symbol","iterator","asyncIterator","TypeError","defer","t","promise","Promise","r","n","reject","resolve","_transform","o","i","s","a","c","u","f","length","shift","done","value","l","push","h","transform","commonjsGlobal","globalThis","window","global","self","getDefaultExportFromCjs","__esModule","Object","prototype","hasOwnProperty","call","default","getAugmentedNamespace","defineProperty","keys","forEach","getOwnPropertyDescriptor","get","enumerable","pRetry$2","exports","retry$2","RetryOperation","forever","_originalTimeouts","JSON","parse","stringify","_timeouts","_options","_maxRetryTime","maxRetryTime","_fn","_errors","_attempts","_operationTimeout","_operationTimeoutCb","_timeout","_operationStart","_timer","_cachedTimeouts","slice","retry_operation","reset","stop","clearTimeout","retry","Date","getTime","unshift","Error","splice","setTimeout","unref","attempt","timeout","cb","try","console","log","start","errors","attempts","mainError","message","operation","timeouts","retries","Array","concat","factor","minTimeout","maxTimeout","randomize","createTimeout","sort","Math","random","round","max","pow","min","wrap","arguments","pop","apply","bind","options","retry$1","networkErrorMsgs","AbortError","constructor","originalError","stack","name","decorateErrorWithCounts","attemptNumber","retriesLeft","isNetworkError","includes","pRetry","onFailedAttempt","AbortError_1","pRetry$1","encode_1$1","encode$a","MSB$3","REST$3","MSBALL$1","INT$1","Number","MAX_SAFE_INTEGER","bytes","RangeError","decode$b","read$1","MSB$2","REST$2","N1$1","N2$1","N3$1","N4$1","N5$1","N6$1","N7$1","N8$1","N9$1","length$1","varint$1","encode","decode","encodingLength","encode_1","encode$9","MSB","REST","MSBALL","INT","decode$a","read","MSB$1","REST$1","N1","N2","N3","N4","N5","N6","N7","N8","N9","varint","_brrp_varint","decode$9","encodeTo","undefined","empty","Uint8Array","fromHex","match","map","parseInt","equals$1","equals","byteLength","coerce","ArrayBuffer","isView","buffer","byteOffset","fromString$3","TextEncoder","toString$1","TextDecoder","create$4","create","set","Digest","decode$8","subarray","code","size","digest","base","charAt","charCodeAt","d","p","y","isArray","from","repeat","decodeUnsafe","src$2","_brrp__multiformats_scope_baseX","Encoder","prefix","baseEncode","Decoder","codePointAt","prefixCodePoint","baseDecode","or","ComposedDecoder","decoders","Codec","encoder","decoder","from$1","_ref","baseX","_ref2","alphabet","decode$7","SyntaxError","encode$8","rfc4648","_ref3","bitsPerChar","base58btc","base58flickr","base58","freeze","__proto__","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base32$1","CID","version","multihash","asCID","_baseCache","Map","defineProperties","hidden","readonly$1","toV0","DAG_PB_CODE","SHA_256_CODE","createV0","toV1","createV1","toString","toStringV0","toStringV1","toJSON","hash","toStringTag","for","isCID","deprecate","IS_CID_DEPRECATION","cidSymbol","toBaseEncodedString","codec","multibaseName","encodeCID","decodeFirst","inspectBytes","multihashSize","digestSize","multihashCode","parseCIDtoBytes","writable","configurable","test","warn","typeofs","objectTypeNames","is","isBuffer$1","getObjectType","isBuffer","Type","major","majorEncoded","terminal","compare","uint","negint","string","array","tag","float","false","true","null","break","Token$1","type","encodedLength","encodedBytes","byteValue","useBuffer","process","browser","Buffer","textDecoder$1","textEncoder$2","asU8A","utf8Slice","fromString$2","utf8ToBytes","fromArray","concat$2","alloc","allocUnsafe","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","String","fromCharCode","defaultChunkSize","Bl","chunkSize","cursor","maxCursor","chunks","_initReuseChunk","toBytes","decodeErrPrefix","encodeErrPrefix","assertEnoughData","uintBoundaries","BigInt","readUint8","strict","readUint16","readUint32","readUint64","allowBigInt","decodeUint8","decodeUint16","decodeUint32","decodeUint64","encodeUint","encodeUintValue","decodeNegint8","decodeNegint16","decodeNegint32","encodedSize","compareTokens","neg1b","pos1b","decodeNegint64","MIN_SAFE_INTEGER","encodeNegint","toToken$3","decodeBytesCompact","decodeBytes8","decodeBytes16","decodeBytes32","decodeBytes64","tokenBytes","encodeBytes","compareBytes","toToken$2","retainStringBytes","decodeStringCompact","decodeString8","decodeString16","decodeString32","decodeString64","encodeString","toToken$1","decodeArrayCompact","decodeArray8","decodeArray16","decodeArray32","decodeArray64","decodeArrayIndefinite","allowIndefinite","encodeArray","toToken","decodeMapCompact","decodeMap8","decodeMap16","decodeMap32","decodeMap64","decodeMapIndefinite","encodeMap","decodeTagCompact","decodeTag8","decodeTag16","decodeTag32","decodeTag64","encodeTag","MINOR_FALSE","MINOR_TRUE","MINOR_NULL","MINOR_UNDEFINED","decodeUndefined","allowUndefined","coerceUndefinedToNull","decodeBreak","createToken","allowNaN","isNaN","allowInfinity","decodeFloat16","readFloat16","decodeFloat32","readFloat32","decodeFloat64","readFloat64","encodeFloat","float64","encodeFloat16","ui8a","encodeFloat32","encodeFloat64","buffer$1","dataView","DataView","setUint16","setFloat32","getUint32","NaN","getFloat32","setFloat64","getFloat64","invalidMinor","errorer","jump","quick","quickEncodeToken","defaultEncodeOptions","mapSorter","makeCborEncoders","cborEncoders","buf","Ref","obj","parent","createCheck","simpleTokens","emptyArray","emptyMap","typeEncoders","number","isInteger","isSafeInteger","bigint","boolean","addBreakTokens","objectToTokens","sortMapEntries","split","tokensToEncoded","encodeCustom","encode$7","assign","defaultDecodeOptions","Tokeniser","pos","data","padStart","DONE","BREAK","tokenToArray","tokensToObject","tokenToMap","useMaps","tags","decode$6","tokenizer","CID_CBOR_TAG$1","cidEncoder$1","undefinedEncoder$1","numberEncoder$1","encodeOptions$1","cidDecoder$1","decodeOptions$1","encode$6","decode$5","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","upTo","seek","readHeader","exactly","roots","filter","readMultihash","readCid","readBlockHead","cid","blockLength","readBlock","readBlockIndex","offset","blockOffset","createDecoder","header","blocks","blocksIndex","bytesReader","chunkReader","reduce","asyncIterableReader","CarReader","_version","_roots","_blocks","_keys","getRoots","has","indexOf","cids","fromBytes","decodeReaderComplete","fromIterable","createHeader","createEncoder","setRoots","write","writeBlock","close","async","end","noop$1","create$3","makeDrainer","drainerResolver","outWaitResolver","writer","CarWriter","_encoder","_mutex","_ended","put","then","toRoots","encodeWriter","out","CarWriterOut","createAppender","updateRootsInBytes","_iterator","_iterating","_ref4","Hasher","readonly","links","entries","join","tree","remaining","Block","_ref5","asBlock","Boolean","encode$5","_ref6","hasher","name$2","code$3","encode$4","decode$4","raw","CID_CBOR_TAG","cidEncoder","undefinedEncoder","numberEncoder","encodeOptions","cidDecoder","decodeOptions","name$1","code$2","encode$3","decode$3","dagCbor","textDecoder","decodeVarint","decodeBytes","decodeKey","decodeLink","Hash","Name","Tsize","decodeNode","Data","Links","textEncoder$1","maxInt32","maxUInt32","encodeLink","encodeVarint","encodeNode","sizeNode","sizeLink","sov","floor","len64","len8tab","pbNodeProperties","pbLinkProperties","textEncoder","linkComparator","hasOnlyProperties","some","asLink","prepare","validate","createNode","createLink","code$1","encode$2","decode$2","dagPb","TreewalkCarSplitter","_reader","_targetSize","_decoders","cars","_cars","channel","_get","find","newCar","fromBlob","arrayBuffer","last","itLast","itPipe","rawPipe","_len","_key","isIterable$1","isDuplex","sink","source","duplexPipelineFn","pipe","_len2","_key2","isIterable","pipe$1","batch$1","itBatch","batch","parallelBatch","ok","err","itParallelBatch","isPlainObj","getPrototypeOf","isOptionObject","propertyIsEnumerable","globalThis$1","defaultMergeOptions","concatArrays","ignoreUndefined","getEnumerableOwnPropertyKeys","getOwnPropertySymbols","clone","cloneArray","cloneOptionObject","mergeKeys","merge","mergeOptions","_","_len3","_key3","sha","crypto","subtle","sha256","murmurHash3js","module","x86","x64","inputValidation","hash32","hash128","g","b","m","w","T","E","murmurHash3","murmurhash3jsRevisited","fromNumberTo32BitBuf","murmur3128","hamtHashFn","reverse","defaultOptions","chunker","strategy","rawLeaves","onlyHash","reduceSingleLeafToSelf","leafType","cidVersion","progress","shardSplitThreshold","fileImportConcurrency","blockWriteConcurrency","minChunkSize","maxChunkSize","avgChunkSize","polynomial","maxChildrenPerNode","layerRepeat","wrapWithDirectory","recursive","hamtHashCode","hamtBucketBits","defaultOptions$1","createError","ErrClass","errCode","indexMinimal","minimal$1","aspromise","asPromise","base64$3","ceil","eventemitter","EventEmitter","_listeners","on","fn","ctx","off","emit","factory","Float32Array","writeFloatLE","writeFloatBE","readFloatLE","readFloatBE","LN2","writeUintLE","writeUintBE","readUintLE","readUintBE","Float64Array","writeDoubleLE","writeDoubleBE","readDoubleLE","readDoubleBE","inquire_1","inquire","moduleName","mod","eval","replace","utf8$2","pool_1","pool","longbits","LongBits$2","util$5","lo","hi","zero","toNumber","zzEncode","zzDecode","zeroHash","fromNumber","isString","Long","fromString","low","high","toLong","unsigned","fromHash","toHash","captureStackTrace","base64","utf8","LongBits","isNode","versions","node","emptyObject","isFinite","isObject","isset","isSet","utf8Write","_Buffer_from","_Buffer_allocUnsafe","newBuffer","dcodeIO","key2Re","key32Re","key64Re","longToHash","longFromHash","fromBits","lcFirst","toLowerCase","substring","newError","ProtocolError","oneOfGetter","oneOfSetter","toJSONOptions","longs","enums","json","_configure","Writer$1","util$4","BufferWriter$1","LongBits$1","base64$2","utf8$1","Op","len","val","noop","State","head","tail","states","create$2","writeByte","writeVarint32","VarintOp","writeVarint64","writeFixed32","_push","uint32","int32","sint32","uint64","int64","sint64","bool","fixed32","sfixed32","fixed64","sfixed64","double","writeBytes","fork","ldelim","finish","writer_buffer","BufferWriter","Writer","util$3","writeStringBuffer","writeBytesBuffer","copy","reader","Reader$1","util$2","BufferReader$1","indexOutOfRange","create_array","create$1","readLongVarint","readFixed32_end","readFixed64","_slice","skip","skipType","reader_buffer","BufferReader","Reader","util$1","rpc","service","Service","util","rpcImpl","requestDelimited","responseDelimited","rpcCall","build","configure","minimal","$Reader","$Writer","$util","$root","blocksizes","filesize","hashType","fanout","mode","mtime","UnixTime","instance","fromObject","fromValue","toObject","arrays","defaults","DataType","Seconds","FractionalNanoseconds","Metadata","MimeType","PBData","types","dirTypes","DEFAULT_FILE_MODE","DEFAULT_DIRECTORY_MODE","parseMode","parseMtime","secs","nsecs","UnixFS","unmarshal","objects","blockSizes","_originalMode","_mode","isDirectory","addBlockSize","removeBlockSize","fileSize","marshal","Raw","Directory","File","Symlink","HAMTShard","persist","signal","dirBuilder","path","unixfs","all","itAll","flat","balanced","reduceToParents","trickleStream","Root","isFull","addChild","SubTree","append","maxDepth","currentDepth","iteration","root","children","depth","maxChildren","_addNextNodeToParent","_findParent","_reduce","bufferImporter","content","dagBuilders","trickle","buildFileBatch","single","fileBuilder","base64Js","toByteArray","fromByteArray","lookup","revLookup","Arr","getLens","_byteLength","tripletToBase64","encodeChunk","ieee754","abs","SlowBuffer","INSPECT_MAX_BYTES","setPrototypeOf","isEncoding","Y","SharedArrayBuffer","valueOf","q","toPrimitive","W","H","S","B","k","$","v","I","lastIndexOf","readUInt16BE","substr","G","A","kMaxLength","TYPED_ARRAY_SUPPORT","foo","error","poolSize","fill","allocUnsafeSlow","_isBuffer","swap16","swap32","swap64","toLocaleString","inspect","trim","_arr","K","C","x","D","F","R","O","U","L","readUIntLE","readUIntBE","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","J","M","z","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","writeUIntLE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","copyWithin","N","j","P","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","V","X","symbol","BufferList","_init","_bufs","_new","_offset","_reverseOffset","shallowSlice","consume","trunc","duplicate","_appendBuffer","_isBufferList","_match","isBufferList","BufferList_1","Rabin$1","bits","asModule","rabin","Rabin","fingerprint","__retain","__release","__allocArray","__getInt32Array","Int32Array_ID","Uint8Array_ID","Int32Array","rabin$1","loader","ID_OFFSET","SIZE_OFFSET","ARRAYBUFFER_ID","STRING_ID","ARRAYBUFFERVIEW","ARRAY","VAL_ALIGN_OFFSET","VAL_SIGNED","VAL_FLOAT","VAL_MANAGED","ARRAYBUFFERVIEW_BUFFER_OFFSET","ARRAYBUFFERVIEW_DATASTART_OFFSET","ARRAYBUFFERVIEW_DATALENGTH_OFFSET","ARRAYBUFFERVIEW_SIZE","ARRAY_LENGTH_OFFSET","ARRAY_SIZE","BIGINT","BigUint64Array","THIS","CHUNKSIZE","getStringImpl","Uint32Array","Uint16Array","preInstantiate","env","abort","memory","trace","postInstantiate","table","__alloc","__rtti_base","clz32","Int8Array","Int16Array","BigInt64Array","__allocString","__getString","__getArrayView","__getArray","__getArrayBuffer","__getInt8Array","__getInt8ArrayView","__getUint8Array","__getUint8ArrayView","__getUint8ClampedArray","Uint8ClampedArray","__getUint8ClampedArrayView","__getInt16Array","__getInt16ArrayView","__getUint16Array","__getUint16ArrayView","__getInt32ArrayView","__getUint32Array","__getUint32ArrayView","__getInt64Array","__getInt64ArrayView","__getUint64Array","__getUint64ArrayView","__getFloat32Array","__getFloat32ArrayView","__getFloat64Array","__getFloat64ArrayView","__instanceof","demangle","isResponse","Response","instantiate$1","instantiateStreaming","WebAssembly","instantiate","Module","compile","instantiateSync","Instance","__argumentsLength","__setArgumentsLength","__setargc","ctor","_len4","_key4","getOwnPropertyNames","original","_len5","_key5","loadWebAssembly","supported","Blob","rabinWasm","getRabin","src$1","rabinChunker","log2","fixedSizeChunker","identity","identityBase","base2","base2$1","base8","base8$1","base10","base10$1","base16","base16upper","base16$1","base36","base36upper","base36$1","base64pad","base64url","base64urlpad","base64$1","alphabetBytesToChars","alphabetCharsToBytes","encode$1","decode$1","base256emoji","base256emoji$1","bases","createCodec","ascii","BASES","hex","latin1","binary","fromString$1","validateChunks","isAsyncIterable","contentAsAsyncIterable","dagBuilder","chunkValidator","Dir","dir","dirty","parentKey","eachChildSeries","flush","DirFlat","_children","childCount","directChildrenCount","onlyChild","key","child","BITS_PER_BYTE","sparseArray","_bitArrays","_data","_length","_changedLength","_changedData","_internalPositionFor","_unsetInternalPos","_unsetBit","_setBit","_setInternalPos","unset","_sortData","_bytePosFor","popCountReduce","popCount","sortInternal","bitField","compactArray","valueOnly","require$$1$1","SparseArray","uint8ArrayFromString","Bucket$1","_popCount","_parent","_posAtParent","_findNewBucketAndPos","bucket","_putAt","_findChild","del","_findPlace","_at","_delAt","leafCount","childrenCount","eachLeafSeries","serialize","asyncTransform","asyncTransformBucket","mapNode","reduceNodes","prettyPrint","tableSize","take","existingChild","_putObjectAt","_level","exists","untake","consumableHash","START_MASKS","STOP_MASKS","consumableBuffer","_value","_currentBytePos","_currentBitPos","availableBits","totalBits","_haveBits","byteBitsToInt","maskFor","concat$1","require$$1","ConsumableBuffer","uint8ArrayConcat","wrapHash$1","InfiniteHash","_hashFn","_depth","_availableBits","_currentBufferIndex","_buffers","_produceMoreBits","Bucket","wrapHash","createHAMT","hashFn","src","DirSharded","_bucket","toUpperCase","flatToShard","convertToShard","toPathComponents","addToTree","flushAndYield","treeBuilder","importer","browserReadableStreamToIt$1","getReader","preventCancel","cancel","releaseLock","browserReadablestreamToIt","browserReadableStreamToIt","blobToIt","stream","body","blobToIt_1","peekableIterator","peek","itPeekable","itMap","isBytes$1","isBlob$2","isFileObject","isReadableStream","toAsyncIterable$1","normaliseContent","normaliseCandidateSingle","toFileObject$1","normaliseInput$1","normaliseCandidateMultiple","_readableState","toFileObject","normaliseInput","isBytes","isBlob$1","isSingle","getNormaliser","drain","itDrain","itFilter","itTake","sortAll","BaseBlockstore","open","delete","putMany","getMany","deleteMany","commit","_all","_allKeys","query","startsWith","filters","orders","limit","queryKeys","MemoryBlockStore","store","clear","unixfsImporterOptionsDefault","pack","_ref7","input","blockstore","throttledQueue$1","dequeue","now","callback","catch","throttledQueue","fetch","FormData","Blob$1","Blockstore","GATEWAY","URL","toGatewayURL","gateway","protocol","href","BlockstoreCarReader","_blockstore","Token","ipnft","url","embed","_ref8","mapTokenInputBlobs","setIn","token","car","mapWith","isURL","embedURL","_ref9","isEncodedURL","decodeURL","mapValueWith","isBlob","encodeBlob","mapArrayWith","mapObjectWith","MAX_STORE_RETRIES","MAX_CONCURRENT_UPLOADS","MAX_CHUNK_SIZE","RATE_LIMIT_REQUESTS","RATE_LIMIT_PERIOD","createRateLimiter","globalRateLimiter","NFTStorage","_ref10","did","endpoint","rateLimiter","auth","_ref11","Authorization","storeBlob","storeCar","_ref12","onStoredChunk","maxRetries","method","headers","aborted","status","storeDirectory","encodeDirectory","encodeNFT","_ref13","deals","decodeDeals","pin","decodePin","created","check","_ref14","_ref15","validateERC1155","packCar","toImportCandidate","toAsyncIterable","_ref16","description","image","decimals","dealActivation","dealExpiration","lastChanged"],"sources":["../../../node_modules/streaming-iterables/dist/index.mjs","../../../node_modules/retry/lib/retry_operation.js","../../../node_modules/retry/lib/retry.js","../../../node_modules/retry/index.js","../../../node_modules/p-retry/index.js","../../../node_modules/varint/encode.js","../../../node_modules/varint/decode.js","../../../node_modules/varint/length.js","../../../node_modules/varint/index.js","../../../node_modules/multiformats/esm/vendor/varint.js","../../../node_modules/multiformats/esm/src/varint.js","../../../node_modules/multiformats/esm/src/bytes.js","../../../node_modules/multiformats/esm/src/hashes/digest.js","../../../node_modules/multiformats/esm/vendor/base-x.js","../../../node_modules/multiformats/esm/src/bases/base.js","../../../node_modules/multiformats/esm/src/bases/base58.js","../../../node_modules/multiformats/esm/src/bases/base32.js","../../../node_modules/multiformats/esm/src/cid.js","../../../node_modules/cborg/esm/lib/is.js","../../../node_modules/cborg/esm/lib/token.js","../../../node_modules/cborg/esm/lib/byte-utils.js","../../../node_modules/cborg/esm/lib/bl.js","../../../node_modules/cborg/esm/lib/common.js","../../../node_modules/cborg/esm/lib/0uint.js","../../../node_modules/cborg/esm/lib/1negint.js","../../../node_modules/cborg/esm/lib/2bytes.js","../../../node_modules/cborg/esm/lib/3string.js","../../../node_modules/cborg/esm/lib/4array.js","../../../node_modules/cborg/esm/lib/5map.js","../../../node_modules/cborg/esm/lib/6tag.js","../../../node_modules/cborg/esm/lib/7float.js","../../../node_modules/cborg/esm/lib/jump.js","../../../node_modules/cborg/esm/lib/encode.js","../../../node_modules/cborg/esm/lib/decode.js","../../../node_modules/@ipld/car/node_modules/@ipld/dag-cbor/esm/index.js","../../../node_modules/@ipld/car/esm/lib/decoder.js","../../../node_modules/@ipld/car/esm/lib/reader-browser.js","../../../node_modules/@ipld/car/esm/lib/encoder.js","../../../node_modules/@ipld/car/esm/lib/iterator-channel.js","../../../node_modules/@ipld/car/esm/lib/writer-browser.js","../../../node_modules/multiformats/esm/src/hashes/hasher.js","../../../node_modules/multiformats/esm/src/block.js","../../../node_modules/multiformats/esm/src/codecs/raw.js","../../../node_modules/@ipld/dag-cbor/esm/index.js","../../../node_modules/@ipld/dag-pb/esm/src/pb-decode.js","../../../node_modules/@ipld/dag-pb/esm/src/pb-encode.js","../../../node_modules/@ipld/dag-pb/esm/src/util.js","../../../node_modules/@ipld/dag-pb/esm/src/index.js","../../../node_modules/carbites/esm/lib/treewalk/splitter.js","../../../node_modules/it-last/index.js","../../../node_modules/it-pipe/index.js","../../../node_modules/it-batch/index.js","../../../node_modules/it-parallel-batch/index.js","../../../node_modules/is-plain-obj/index.js","../../../node_modules/merge-options/index.js","../../../node_modules/multiformats/esm/src/hashes/sha2-browser.js","../../../node_modules/murmurhash3js-revisited/lib/murmurHash3js.js","../../../node_modules/murmurhash3js-revisited/index.js","../../../node_modules/@multiformats/murmur3/esm/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/options.js","../../../node_modules/err-code/index.js","../../../node_modules/@protobufjs/aspromise/index.js","../../../node_modules/@protobufjs/base64/index.js","../../../node_modules/@protobufjs/eventemitter/index.js","../../../node_modules/@protobufjs/float/index.js","../../../node_modules/@protobufjs/inquire/index.js","../../../node_modules/@protobufjs/utf8/index.js","../../../node_modules/@protobufjs/pool/index.js","../../../node_modules/protobufjs/src/util/longbits.js","../../../node_modules/protobufjs/src/util/minimal.js","../../../node_modules/protobufjs/src/writer.js","../../../node_modules/protobufjs/src/writer_buffer.js","../../../node_modules/protobufjs/src/reader.js","../../../node_modules/protobufjs/src/reader_buffer.js","../../../node_modules/protobufjs/src/rpc/service.js","../../../node_modules/protobufjs/src/rpc.js","../../../node_modules/protobufjs/src/roots.js","../../../node_modules/protobufjs/src/index-minimal.js","../../../node_modules/protobufjs/minimal.js","../../../node_modules/ipfs-unixfs/esm/src/unixfs.js","../../../node_modules/ipfs-unixfs/esm/src/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js","../../../node_modules/it-all/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js","../../../node_modules/base64-js/index.js","../../../node_modules/ieee754/index.js","../../../node_modules/buffer/index.js","../../../node_modules/bl/BufferList.js","../../../node_modules/rabin-wasm/src/rabin.js","../../../node_modules/@assemblyscript/loader/index.js","../../../node_modules/rabin-wasm/dist/rabin-wasm.js","../../../node_modules/rabin-wasm/src/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js","../../../node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js","../../../node_modules/multiformats/esm/src/bases/identity.js","../../../node_modules/multiformats/esm/src/bases/base2.js","../../../node_modules/multiformats/esm/src/bases/base8.js","../../../node_modules/multiformats/esm/src/bases/base10.js","../../../node_modules/multiformats/esm/src/bases/base16.js","../../../node_modules/multiformats/esm/src/bases/base36.js","../../../node_modules/multiformats/esm/src/bases/base64.js","../../../node_modules/multiformats/esm/src/bases/base256emoji.js","../../../node_modules/multiformats/esm/src/codecs/json.js","../../../node_modules/multiformats/esm/src/basics.js","../../../node_modules/uint8arrays/esm/src/alloc.js","../../../node_modules/uint8arrays/esm/src/util/bases.js","../../../node_modules/uint8arrays/esm/src/from-string.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dir.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js","../../../node_modules/sparse-array/index.js","../../../node_modules/hamt-sharding/src/bucket.js","../../../node_modules/hamt-sharding/src/consumable-buffer.js","../../../node_modules/uint8arrays/esm/src/concat.js","../../../node_modules/hamt-sharding/src/consumable-hash.js","../../../node_modules/hamt-sharding/src/index.js","../../../node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js","../../../node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js","../../../node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js","../../../node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js","../../../node_modules/ipfs-unixfs-importer/esm/src/index.js","../../../node_modules/browser-readablestream-to-it/index.js","../../../node_modules/blob-to-it/index.js","../../../node_modules/it-peekable/index.js","../../../node_modules/it-map/index.js","../../../node_modules/ipfs-core-utils/esm/src/files/utils.js","../../../node_modules/ipfs-core-utils/esm/src/files/normalise-content.js","../../../node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-single.js","../../../node_modules/ipfs-core-utils/esm/src/files/normalise-input-single.js","../../../node_modules/ipfs-core-utils/esm/src/files/normalise-candidate-multiple.js","../../../node_modules/ipfs-core-utils/esm/src/files/normalise-input-multiple.js","../../../node_modules/ipfs-car/dist/esm/pack/utils/normalise-input.js","../../../node_modules/it-drain/index.js","../../../node_modules/it-filter/index.js","../../../node_modules/it-take/index.js","../../../node_modules/blockstore-core/esm/src/base.js","../../../node_modules/ipfs-car/dist/esm/blockstore/memory.js","../../../node_modules/ipfs-car/dist/esm/pack/constants.js","../../../node_modules/ipfs-car/dist/esm/pack/index.js","../../../node_modules/throttled-queue/dist/throttledQueue.js","../src/platform.web.js","../src/gateway.js","../src/bs-car-reader.js","../src/token.js","../src/lib.js"],"sourcesContent":["async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - time;\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };\n","function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n","var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n","module.exports = require('./lib/retry');","'use strict';\nconst retry = require('retry');\n\nconst networkErrorMsgs = [\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari\n\t'Network request failed' // `cross-fetch`\n];\n\nclass AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst isNetworkError = errorMessage => networkErrorMsgs.includes(errorMessage);\n\nconst pRetry = (input, options) => new Promise((resolve, reject) => {\n\toptions = {\n\t\tonFailedAttempt: () => {},\n\t\tretries: 10,\n\t\t...options\n\t};\n\n\tconst operation = retry.operation(options);\n\n\toperation.attempt(async attemptNumber => {\n\t\ttry {\n\t\t\tresolve(await input(attemptNumber));\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof Error)) {\n\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (error instanceof AbortError) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error.originalError);\n\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\toperation.stop();\n\t\t\t\treject(error);\n\t\t\t} else {\n\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\ttry {\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\treject(operation.mainError());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n});\n\nmodule.exports = pRetry;\n// TODO: remove this in the next major version\nmodule.exports.default = pRetry;\n\nmodule.exports.AbortError = AbortError;\n","module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n","module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n","\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n","module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n","var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","import varint from '../vendor/varint.js';\nexport const decode = data => {\n  const code = varint.decode(data);\n  return [\n    code,\n    varint.decode.bytes\n  ];\n};\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset);\n  return target;\n};\nexport const encodingLength = int => {\n  return varint.encodingLength(int);\n};","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};","import {\n  coerce,\n  equals as equalBytes\n} from '../bytes.js';\nimport * as varint from '../varint.js';\nexport const create = (code, digest) => {\n  const size = digest.byteLength;\n  const sizeOffset = varint.encodingLength(code);\n  const digestOffset = sizeOffset + varint.encodingLength(size);\n  const bytes = new Uint8Array(digestOffset + size);\n  varint.encodeTo(code, bytes, 0);\n  varint.encodeTo(size, bytes, sizeOffset);\n  bytes.set(digest, digestOffset);\n  return new Digest(code, size, digest, bytes);\n};\nexport const decode = multihash => {\n  const bytes = coerce(multihash);\n  const [code, sizeOffset] = varint.decode(bytes);\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset));\n  const digest = bytes.subarray(sizeOffset + digestOffset);\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length');\n  }\n  return new Digest(code, size, digest, bytes);\n};\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true;\n  } else {\n    return a.code === b.code && a.size === b.size && equalBytes(a.bytes, b.bytes);\n  }\n};\nexport class Digest {\n  constructor(code, size, digest, bytes) {\n    this.code = code;\n    this.size = size;\n    this.digest = digest;\n    this.bytes = bytes;\n  }\n}","function base(ALPHABET, name) {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError('Alphabet too long');\n  }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(x + ' is ambiguous');\n    }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256);\n  var iFACTOR = Math.log(256) / Math.log(BASE);\n  function encode(source) {\n    if (source instanceof Uint8Array);\n    else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError('Expected Uint8Array');\n    }\n    if (source.length === 0) {\n      return '';\n    }\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    var b58 = new Uint8Array(size);\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      pbegin++;\n    }\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== 'string') {\n      throw new TypeError('Expected String');\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    var psz = 0;\n    if (source[psz] === ' ') {\n      return;\n    }\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    var size = (source.length - psz) * FACTOR + 1 >>> 0;\n    var b256 = new Uint8Array(size);\n    while (source[psz]) {\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n      if (carry === 255) {\n        return;\n      }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error('Non-zero carry');\n      }\n      length = i;\n      psz++;\n    }\n    if (source[psz] === ' ') {\n      return;\n    }\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-${ name } character`);\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  };\n}\nvar src = base;\nvar _brrp__multiformats_scope_baseX = src;\nexport default _brrp__multiformats_scope_baseX;","import basex from '../../vendor/base-x.js';\nimport { coerce } from '../bytes.js';\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nexport const or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nexport class Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport const from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nexport const baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nexport const rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};","import { baseX } from './base.js';\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n});\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n});\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n});\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n});\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n});\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n});\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n});\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n});\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n});\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n});","import * as varint from './varint.js';\nimport * as Digest from './hashes/digest.js';\nimport { base58btc } from './bases/base58.js';\nimport { base32 } from './bases/base32.js';\nimport { coerce } from './bytes.js';\nexport class CID {\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    this.byteOffset = bytes.byteOffset;\n    this.byteLength = bytes.byteLength;\n    this.asCID = this;\n    this._baseCache = new Map();\n    Object.defineProperties(this, {\n      byteOffset: hidden,\n      byteLength: hidden,\n      code: readonly,\n      version: readonly,\n      multihash: readonly,\n      bytes: readonly,\n      _baseCache: hidden,\n      asCID: hidden\n    });\n  }\n  toV0() {\n    switch (this.version) {\n    case 0: {\n        return this;\n      }\n    default: {\n        const {code, multihash} = this;\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n        }\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n        }\n        return CID.createV0(multihash);\n      }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n    case 0: {\n        const {code, digest} = this.multihash;\n        const multihash = Digest.create(code, digest);\n        return CID.createV1(this.code, multihash);\n      }\n    case 1: {\n        return this;\n      }\n    default: {\n        throw Error(`Can not convert CID version ${ this.version } to version 0. This is a bug please report`);\n      }\n    }\n  }\n  equals(other) {\n    return other && this.code === other.code && this.version === other.version && Digest.equals(this.multihash, other.multihash);\n  }\n  toString(base) {\n    const {bytes, version, _baseCache} = this;\n    switch (version) {\n    case 0:\n      return toStringV0(bytes, _baseCache, base || base58btc.encoder);\n    default:\n      return toStringV1(bytes, _baseCache, base || base32.encoder);\n    }\n  }\n  toJSON() {\n    return {\n      code: this.code,\n      version: this.version,\n      hash: this.multihash.bytes\n    };\n  }\n  get [Symbol.toStringTag]() {\n    return 'CID';\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n  static isCID(value) {\n    deprecate(/^0\\.0/, IS_CID_DEPRECATION);\n    return !!(value && (value[cidSymbol] || value.asCID === value));\n  }\n  get toBaseEncodedString() {\n    throw new Error('Deprecated, use .toString()');\n  }\n  get codec() {\n    throw new Error('\"codec\" property is deprecated, use integer \"code\" property instead');\n  }\n  get buffer() {\n    throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead');\n  }\n  get multibaseName() {\n    throw new Error('\"multibaseName\" property is deprecated');\n  }\n  get prefix() {\n    throw new Error('\"prefix\" property is deprecated');\n  }\n  static asCID(value) {\n    if (value instanceof CID) {\n      return value;\n    } else if (value != null && value.asCID === value) {\n      const {version, code, multihash, bytes} = value;\n      return new CID(version, code, multihash, bytes || encodeCID(version, code, multihash.bytes));\n    } else if (value != null && value[cidSymbol] === true) {\n      const {version, multihash, code} = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      return null;\n    }\n  }\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    switch (version) {\n    case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(`Version 0 CID must use dag-pb (code: ${ DAG_PB_CODE }) block encoding`);\n        } else {\n          return new CID(version, code, digest, digest.bytes);\n        }\n      }\n    case 1: {\n        const bytes = encodeCID(version, code, digest.bytes);\n        return new CID(version, code, digest, bytes);\n      }\n    default: {\n        throw new Error('Invalid version');\n      }\n    }\n  }\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [\n      cid,\n      bytes.subarray(specs.size)\n    ];\n  }\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      version = 0;\n      offset = 0;\n    } else if (version === 1) {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${ version }`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next();\n    const digestSize = next();\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    cid._baseCache.set(prefix, source);\n    return cid;\n  }\n}\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n  case 'Q': {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(`${ base58btc.prefix }${ source }`)\n      ];\n    }\n  case base58btc.prefix: {\n      const decoder = base || base58btc;\n      return [\n        base58btc.prefix,\n        decoder.decode(source)\n      ];\n    }\n  case base32.prefix: {\n      const decoder = base || base32;\n      return [\n        base32.prefix,\n        decoder.decode(source)\n      ];\n    }\n  default: {\n      if (base == null) {\n        throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');\n      }\n      return [\n        source[0],\n        base.decode(source)\n      ];\n    }\n  }\n};\nconst toStringV0 = (bytes, cache, base) => {\n  const {prefix} = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${ base.name } encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst toStringV1 = (bytes, cache, base) => {\n  const {prefix} = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n};\nconst DAG_PB_CODE = 112;\nconst SHA_256_CODE = 18;\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n};\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');\nconst readonly = {\n  writable: false,\n  configurable: false,\n  enumerable: true\n};\nconst hidden = {\n  writable: false,\n  enumerable: false,\n  configurable: false\n};\nconst version = '0.0.0-dev';\nconst deprecate = (range, message) => {\n  if (range.test(version)) {\n    console.warn(message);\n  } else {\n    throw new Error(message);\n  }\n};\nconst IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.\nFollowing code pattern:\n\nif (CID.isCID(value)) {\n  doSomethingWithCID(value)\n}\n\nIs replaced with:\n\nconst cid = CID.asCID(value)\nif (cid) {\n  // Make sure to use cid instead of value\n  doSomethingWithCID(cid)\n}\n`;","const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}","class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};","export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}","import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}","const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}","import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};","import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;","import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}","import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};","import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};","import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);","import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}","import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarReader {\n  constructor(version, roots, blocks) {\n    this._version = version;\n    this._roots = roots;\n    this._blocks = blocks;\n    this._keys = blocks.map(b => b.cid.toString());\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  async has(key) {\n    return this._keys.indexOf(key.toString()) > -1;\n  }\n  async get(key) {\n    const index = this._keys.indexOf(key.toString());\n    return index > -1 ? this._blocks[index] : undefined;\n  }\n  async *blocks() {\n    for (const block of this._blocks) {\n      yield block;\n    }\n  }\n  async *cids() {\n    for (const block of this._blocks) {\n      yield block.cid;\n    }\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeReaderComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeReaderComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeReaderComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  const blocks = [];\n  for await (const block of decoder.blocks()) {\n    blocks.push(block);\n  }\n  return new CarReader(version, roots, blocks);\n}\nexport const __browser = true;","import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {cid, bytes} = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport {\n  createEncoder\n};","function noop() {\n}\nexport function create() {\n  const chunkQueue = [];\n  let drainer = null;\n  let drainerResolver = noop;\n  let ended = false;\n  let outWait = null;\n  let outWaitResolver = noop;\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise(resolve => {\n        drainerResolver = () => {\n          drainer = null;\n          drainerResolver = noop;\n          resolve();\n        };\n      });\n    }\n    return drainer;\n  };\n  const writer = {\n    write(chunk) {\n      chunkQueue.push(chunk);\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    },\n    async end() {\n      ended = true;\n      const drainer = makeDrainer();\n      outWaitResolver();\n      return drainer;\n    }\n  };\n  const iterator = {\n    async next() {\n      const chunk = chunkQueue.shift();\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver();\n        }\n        return {\n          done: false,\n          value: chunk\n        };\n      }\n      if (ended) {\n        drainerResolver();\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n      if (!outWait) {\n        outWait = new Promise(resolve => {\n          outWaitResolver = () => {\n            outWait = null;\n            outWaitResolver = noop;\n            return resolve(iterator.next());\n          };\n        });\n      }\n      return outWait;\n    }\n  };\n  return {\n    writer,\n    iterator\n  };\n}","import { CID } from 'multiformats/cid';\nimport {\n  createEncoder,\n  createHeader\n} from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport {\n  bytesReader,\n  readHeader\n} from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {writer, iterator} = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;","import * as Digest from './digest.js';\nexport const from = ({name, code, encode}) => new Hasher(name, code, encode);\nexport class Hasher {\n  constructor(name, code, encode) {\n    this.name = name;\n    this.code = code;\n    this.encode = encode;\n  }\n  digest(input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input);\n      return result instanceof Uint8Array ? Digest.create(this.code, result) : result.then(digest => Digest.create(this.code, digest));\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}","import {\n  bytes as binary,\n  CID\n} from './index.js';\nconst readonly = ({enumerable = true, configurable = false} = {}) => ({\n  enumerable,\n  configurable,\n  writable: false\n});\nconst links = function* (source, base) {\n  if (source == null)\n    return;\n  if (source instanceof Uint8Array)\n    return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [\n      ...base,\n      key\n    ];\n    if (value != null && typeof value === 'object') {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [\n            ...path,\n            index\n          ];\n          const cid = CID.asCID(element);\n          if (cid) {\n            yield [\n              elementPath.join('/'),\n              cid\n            ];\n          } else if (typeof element === 'object') {\n            yield* links(element, elementPath);\n          }\n        }\n      } else {\n        const cid = CID.asCID(value);\n        if (cid) {\n          yield [\n            path.join('/'),\n            cid\n          ];\n        } else {\n          yield* links(value, path);\n        }\n      }\n    }\n  }\n};\nconst tree = function* (source, base) {\n  if (source == null)\n    return;\n  for (const [key, value] of Object.entries(source)) {\n    const path = [\n      ...base,\n      key\n    ];\n    yield path.join('/');\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      if (Array.isArray(value)) {\n        for (const [index, element] of value.entries()) {\n          const elementPath = [\n            ...path,\n            index\n          ];\n          yield elementPath.join('/');\n          if (typeof element === 'object' && !CID.asCID(element)) {\n            yield* tree(element, elementPath);\n          }\n        }\n      } else {\n        yield* tree(value, path);\n      }\n    }\n  }\n};\nconst get = (source, path) => {\n  let node = source;\n  for (const [index, key] of path.entries()) {\n    node = node[key];\n    if (node == null) {\n      throw new Error(`Object has no property at ${ path.slice(0, index + 1).map(part => `[${ JSON.stringify(part) }]`).join('') }`);\n    }\n    const cid = CID.asCID(node);\n    if (cid) {\n      return {\n        value: cid,\n        remaining: path.slice(index + 1).join('/')\n      };\n    }\n  }\n  return { value: node };\n};\nclass Block {\n  constructor({cid, bytes, value}) {\n    if (!cid || !bytes || typeof value === 'undefined')\n      throw new Error('Missing required argument');\n    this.cid = cid;\n    this.bytes = bytes;\n    this.value = value;\n    this.asBlock = this;\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    });\n  }\n  links() {\n    return links(this.value, []);\n  }\n  tree() {\n    return tree(this.value, []);\n  }\n  get(path = '/') {\n    return get(this.value, path.split('/').filter(Boolean));\n  }\n}\nconst encode = async ({value, codec, hasher}) => {\n  if (typeof value === 'undefined')\n    throw new Error('Missing required argument \"value\"');\n  if (!codec || !hasher)\n    throw new Error('Missing required argument: codec or hasher');\n  const bytes = codec.encode(value);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst decode = async ({bytes, codec, hasher}) => {\n  if (!bytes)\n    throw new Error('Missing required argument \"bytes\"');\n  if (!codec || !hasher)\n    throw new Error('Missing required argument: codec or hasher');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash);\n  return new Block({\n    value,\n    bytes,\n    cid\n  });\n};\nconst createUnsafe = ({\n  bytes,\n  cid,\n  value: maybeValue,\n  codec\n}) => {\n  const value = maybeValue !== undefined ? maybeValue : codec && codec.decode(bytes);\n  if (value === undefined)\n    throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n  return new Block({\n    cid,\n    bytes,\n    value\n  });\n};\nconst create = async ({bytes, cid, hasher, codec}) => {\n  if (!bytes)\n    throw new Error('Missing required argument \"bytes\"');\n  if (!hasher)\n    throw new Error('Missing required argument \"hasher\"');\n  const value = codec.decode(bytes);\n  const hash = await hasher.digest(bytes);\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes');\n  }\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  });\n};\nexport {\n  encode,\n  decode,\n  create,\n  createUnsafe,\n  Block\n};","import { coerce } from '../bytes.js';\nexport const name = 'raw';\nexport const code = 85;\nexport const encode = node => coerce(node);\nexport const decode = data => coerce(data);","import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);","const textDecoder = new TextDecoder();\nfunction decodeVarint(bytes, offset) {\n  let v = 0;\n  for (let shift = 0;; shift += 7) {\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow');\n    }\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data');\n    }\n    const b = bytes[offset++];\n    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;\n    if (b < 128) {\n      break;\n    }\n  }\n  return [\n    v,\n    offset\n  ];\n}\nfunction decodeBytes(bytes, offset) {\n  let byteLen;\n  [byteLen, offset] = decodeVarint(bytes, offset);\n  const postOffset = offset + byteLen;\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length');\n  }\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data');\n  }\n  return [\n    bytes.subarray(offset, postOffset),\n    postOffset\n  ];\n}\nfunction decodeKey(bytes, index) {\n  let wire;\n  [wire, index] = decodeVarint(bytes, index);\n  return [\n    wire & 7,\n    wire >> 3,\n    index\n  ];\n}\nfunction decodeLink(bytes) {\n  const link = {};\n  const l = bytes.length;\n  let index = 0;\n  while (index < l) {\n    let wireType, fieldNum;\n    [wireType, fieldNum, index] = decodeKey(bytes, index);\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section');\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Hash`);\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash');\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash');\n      }\n      ;\n      [link.Hash, index] = decodeBytes(bytes, index);\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section');\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Name`);\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name');\n      }\n      let byts;\n      [byts, index] = decodeBytes(bytes, index);\n      link.Name = textDecoder.decode(byts);\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section');\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${ wireType }) for Tsize`);\n      }\n      ;\n      [link.Tsize, index] = decodeVarint(bytes, index);\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${ fieldNum }`);\n    }\n  }\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data');\n  }\n  return link;\n}\nexport function decodeNode(bytes) {\n  const l = bytes.length;\n  let index = 0;\n  let links;\n  let linksBeforeData = false;\n  let data;\n  while (index < l) {\n    let wireType, fieldNum;\n    [wireType, fieldNum, index] = decodeKey(bytes, index);\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${ wireType }`);\n    }\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section');\n      }\n      ;\n      [data, index] = decodeBytes(bytes, index);\n      if (links) {\n        linksBeforeData = true;\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) {\n        throw new Error('protobuf: (PBNode) duplicate Links section');\n      } else if (!links) {\n        links = [];\n      }\n      let byts;\n      [byts, index] = decodeBytes(bytes, index);\n      links.push(decodeLink(byts));\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${ fieldNum }`);\n    }\n  }\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data');\n  }\n  const node = {};\n  if (data) {\n    node.Data = data;\n  }\n  node.Links = links || [];\n  return node;\n}","const textEncoder = new TextEncoder();\nconst maxInt32 = 2 ** 32;\nconst maxUInt32 = 2 ** 31;\nfunction encodeLink(link, bytes) {\n  let i = bytes.length;\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative');\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding');\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1;\n    bytes[i] = 24;\n  }\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name);\n    i -= nameBytes.length;\n    bytes.set(nameBytes, i);\n    i = encodeVarint(bytes, i, nameBytes.length) - 1;\n    bytes[i] = 18;\n  }\n  if (link.Hash) {\n    i -= link.Hash.length;\n    bytes.set(link.Hash, i);\n    i = encodeVarint(bytes, i, link.Hash.length) - 1;\n    bytes[i] = 10;\n  }\n  return bytes.length - i;\n}\nexport function encodeNode(node) {\n  const size = sizeNode(node);\n  const bytes = new Uint8Array(size);\n  let i = size;\n  if (node.Data) {\n    i -= node.Data.length;\n    bytes.set(node.Data, i);\n    i = encodeVarint(bytes, i, node.Data.length) - 1;\n    bytes[i] = 10;\n  }\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i));\n      i -= size;\n      i = encodeVarint(bytes, i, size) - 1;\n      bytes[i] = 18;\n    }\n  }\n  return bytes;\n}\nfunction sizeLink(link) {\n  let n = 0;\n  if (link.Hash) {\n    const l = link.Hash.length;\n    n += 1 + l + sov(l);\n  }\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length;\n    n += 1 + l + sov(l);\n  }\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize);\n  }\n  return n;\n}\nfunction sizeNode(node) {\n  let n = 0;\n  if (node.Data) {\n    const l = node.Data.length;\n    n += 1 + l + sov(l);\n  }\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link);\n      n += 1 + l + sov(l);\n    }\n  }\n  return n;\n}\nfunction encodeVarint(bytes, offset, v) {\n  offset -= sov(v);\n  const base = offset;\n  while (v >= maxUInt32) {\n    bytes[offset++] = v & 127 | 128;\n    v /= 128;\n  }\n  while (v >= 128) {\n    bytes[offset++] = v & 127 | 128;\n    v >>>= 7;\n  }\n  bytes[offset] = v;\n  return base;\n}\nfunction sov(x) {\n  if (x % 2 === 0) {\n    x++;\n  }\n  return Math.floor((len64(x) + 6) / 7);\n}\nfunction len64(x) {\n  let n = 0;\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32);\n    n = 32;\n  }\n  if (x >= 1 << 16) {\n    x >>>= 16;\n    n += 16;\n  }\n  if (x >= 1 << 8) {\n    x >>>= 8;\n    n += 8;\n  }\n  return n + len8tab[x];\n}\nconst len8tab = [\n  0,\n  1,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  5,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  6,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  7,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8,\n  8\n];","import { CID } from 'multiformats/cid';\nconst pbNodeProperties = [\n  'Data',\n  'Links'\n];\nconst pbLinkProperties = [\n  'Hash',\n  'Name',\n  'Tsize'\n];\nconst textEncoder = new TextEncoder();\nfunction linkComparator(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  const abuf = a.Name ? textEncoder.encode(a.Name) : [];\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : [];\n  let x = abuf.length;\n  let y = bbuf.length;\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i];\n      y = bbuf[i];\n      break;\n    }\n  }\n  return x < y ? -1 : y < x ? 1 : 0;\n}\nfunction hasOnlyProperties(node, properties) {\n  return !Object.keys(node).some(p => !properties.includes(p));\n}\nfunction asLink(link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link);\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form');\n    }\n    return { Hash };\n  }\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form');\n  }\n  const pbl = {};\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash);\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash);\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash);\n        }\n      }\n    } catch (e) {\n      throw new TypeError(`Invalid DAG-PB form: ${ e.message }`);\n    }\n    if (cid) {\n      pbl.Hash = cid;\n    }\n  }\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form');\n  }\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name;\n  }\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize;\n  }\n  return pbl;\n}\nexport function prepare(node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node };\n  }\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form');\n  }\n  const pbn = {};\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data);\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data;\n    } else {\n      throw new TypeError('Invalid DAG-PB form');\n    }\n  }\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink);\n      pbn.Links.sort(linkComparator);\n    } else {\n      throw new TypeError('Invalid DAG-PB form');\n    }\n  } else {\n    pbn.Links = [];\n  }\n  return pbn;\n}\nexport function validate(node) {\n  if (!node || typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form');\n  }\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)');\n  }\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be a Uint8Array)');\n  }\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be an array)');\n  }\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i];\n    if (!link || typeof link !== 'object' || Array.isArray(link)) {\n      throw new TypeError('Invalid DAG-PB form (bad link object)');\n    }\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link object)');\n    }\n    if (!link.Hash) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)');\n    }\n    if (link.Hash.asCID !== link.Hash) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)');\n    }\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)');\n    }\n    if (link.Tsize !== undefined && (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0)) {\n      throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)');\n    }\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)');\n    }\n  }\n}\nexport function createNode(data, links = []) {\n  return prepare({\n    Data: data,\n    Links: links\n  });\n}\nexport function createLink(name, size, cid) {\n  return asLink({\n    Hash: cid,\n    Name: name,\n    Tsize: size\n  });\n}","import { CID } from 'multiformats/cid';\nimport { decodeNode } from './pb-decode.js';\nimport { encodeNode } from './pb-encode.js';\nimport {\n  prepare,\n  validate,\n  createNode,\n  createLink\n} from './util.js';\nexport const name = 'dag-pb';\nexport const code = 112;\nexport function encode(node) {\n  validate(node);\n  const pbn = {};\n  if (node.Links) {\n    pbn.Links = node.Links.map(l => {\n      const link = {};\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes;\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name;\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize;\n      }\n      return link;\n    });\n  }\n  if (node.Data) {\n    pbn.Data = node.Data;\n  }\n  return encodeNode(pbn);\n}\nexport function decode(bytes) {\n  const pbn = decodeNode(bytes);\n  const node = {};\n  if (pbn.Data) {\n    node.Data = pbn.Data;\n  }\n  if (pbn.Links) {\n    node.Links = pbn.Links.map(l => {\n      const link = {};\n      try {\n        link.Hash = CID.decode(l.Hash);\n      } catch (e) {\n      }\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID');\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name;\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize;\n      }\n      return link;\n    });\n  }\n  return node;\n}\nexport {\n  prepare,\n  validate,\n  createNode,\n  createLink\n};","import {\n  CarReader,\n  CarWriter\n} from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [\n      pb,\n      raw,\n      cbor,\n      ...options.decoders || []\n    ];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1)\n      throw new Error(`unexpected number of roots: ${ roots.length }`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out)\n        yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock)\n      throw new Error(`missing block for ${ cid }`);\n    const {bytes} = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder)\n      throw new Error(`missing decoder for ${ cid.code }`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(CarWriter.create(cid), { size: 0 });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {out} = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield { channel };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}","'use strict'\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n */\nconst last = async (source) => {\n  let res\n\n  for await (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nmodule.exports = last\n","const rawPipe = (...fns) => {\n  let res\n  while (fns.length) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isIterable = obj => obj && (\n  typeof obj[Symbol.asyncIterator] === 'function' ||\n  typeof obj[Symbol.iterator] === 'function' ||\n  typeof obj.next === 'function' // Probably, right?\n)\n\nconst isDuplex = obj => obj && typeof obj.sink === 'function' && isIterable(obj.source)\n\nconst duplexPipelineFn = duplex => source => {\n  duplex.sink(source) // TODO: error on sink side is unhandled rejection - this is the same as pull streams\n  return duplex.source\n}\n\nconst pipe = (...fns) => {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(fns[0])) {\n    const duplex = fns[0]\n    fns[0] = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(fns[0])) {\n    const source = fns[0]\n    fns[0] = () => source\n  }\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nmodule.exports = pipe\nmodule.exports.pipe = pipe\nmodule.exports.rawPipe = rawPipe\nmodule.exports.isIterable = isIterable\nmodule.exports.isDuplex = isDuplex\n","'use strict'\n\n/**\n * Takes an (async) iterable that emits things and returns an async iterable that\n * emits those things in fixed-sized batches.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T[]>}\n */\nasync function * batch (source, size = 1) {\n  /** @type {T[]} */\n  let things = []\n\n  if (size < 1) {\n    size = 1\n  }\n\n  for await (const thing of source) {\n    things.push(thing)\n\n    while (things.length >= size) {\n      yield things.slice(0, size)\n\n      things = things.slice(size)\n    }\n  }\n\n  while (things.length) {\n    yield things.slice(0, size)\n\n    things = things.slice(size)\n  }\n}\n\nmodule.exports = batch\n","'use strict'\n\nconst batch = require('it-batch')\n\n/**\n * @template T\n * @typedef {{ok:true, value:T}} Success\n */\n\n/**\n * @typedef {{ok:false, err:Error}} Failure\n */\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n *\n * @template T\n * @param {AsyncIterable<() => Promise<T>>} source\n * @param {number} [size=1]\n * @returns {AsyncIterable<T>}\n */\nasync function * parallelBatch (source, size = 1) {\n  for await (const tasks of batch(source, size)) {\n    /** @type {Promise<Success<T>|Failure>[]} */\n    const things = tasks.map(\n      /**\n       * @param {() => Promise<T>} p\n       */\n      p => {\n        return p().then(value => ({ ok: true, value }), err => ({ ok: false, err }))\n      })\n\n    for (let i = 0; i < things.length; i++) {\n      const result = await things[i]\n\n      if (result.ok) {\n        yield result.value\n      } else {\n        throw result.err\n      }\n    }\n  }\n}\n\nmodule.exports = parallelBatch\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict';\nconst isOptionObject = require('is-plain-obj');\n\nconst {hasOwnProperty} = Object.prototype;\nconst {propertyIsEnumerable} = Object;\nconst defineProperty = (object, name, value) => Object.defineProperty(object, name, {\n\tvalue,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true\n});\n\nconst globalThis = this;\nconst defaultMergeOptions = {\n\tconcatArrays: false,\n\tignoreUndefined: false\n};\n\nconst getEnumerableOwnPropertyKeys = value => {\n\tconst keys = [];\n\n\tfor (const key in value) {\n\t\tif (hasOwnProperty.call(value, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\n\t/* istanbul ignore else  */\n\tif (Object.getOwnPropertySymbols) {\n\t\tconst symbols = Object.getOwnPropertySymbols(value);\n\n\t\tfor (const symbol of symbols) {\n\t\t\tif (propertyIsEnumerable.call(value, symbol)) {\n\t\t\t\tkeys.push(symbol);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keys;\n};\n\nfunction clone(value) {\n\tif (Array.isArray(value)) {\n\t\treturn cloneArray(value);\n\t}\n\n\tif (isOptionObject(value)) {\n\t\treturn cloneOptionObject(value);\n\t}\n\n\treturn value;\n}\n\nfunction cloneArray(array) {\n\tconst result = array.slice(0, 0);\n\n\tgetEnumerableOwnPropertyKeys(array).forEach(key => {\n\t\tdefineProperty(result, key, clone(array[key]));\n\t});\n\n\treturn result;\n}\n\nfunction cloneOptionObject(object) {\n\tconst result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};\n\n\tgetEnumerableOwnPropertyKeys(object).forEach(key => {\n\t\tdefineProperty(result, key, clone(object[key]));\n\t});\n\n\treturn result;\n}\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {string[]} keys keys to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nconst mergeKeys = (merged, source, keys, config) => {\n\tkeys.forEach(key => {\n\t\tif (typeof source[key] === 'undefined' && config.ignoreUndefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Do not recurse into prototype chain of merged\n\t\tif (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n\t\t\tdefineProperty(merged, key, merge(merged[key], source[key], config));\n\t\t} else {\n\t\t\tdefineProperty(merged, key, clone(source[key]));\n\t\t}\n\t});\n\n\treturn merged;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */\nconst concatArrays = (merged, source, config) => {\n\tlet result = merged.slice(0, 0);\n\tlet resultIndex = 0;\n\n\t[merged, source].forEach(array => {\n\t\tconst indices = [];\n\n\t\t// `result.concat(array)` with cloning\n\t\tfor (let k = 0; k < array.length; k++) {\n\t\t\tif (!hasOwnProperty.call(array, k)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tindices.push(String(k));\n\n\t\t\tif (array === merged) {\n\t\t\t\t// Already cloned\n\t\t\t\tdefineProperty(result, resultIndex++, array[k]);\n\t\t\t} else {\n\t\t\t\tdefineProperty(result, resultIndex++, clone(array[k]));\n\t\t\t}\n\t\t}\n\n\t\t// Merge non-index keys\n\t\tresult = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter(key => !indices.includes(key)), config);\n\t});\n\n\treturn result;\n};\n\n/**\n * @param {*} merged already cloned\n * @param {*} source something to merge\n * @param {Object} config Config Object\n * @returns {*} cloned Object\n */\nfunction merge(merged, source, config) {\n\tif (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n\t\treturn concatArrays(merged, source, config);\n\t}\n\n\tif (!isOptionObject(source) || !isOptionObject(merged)) {\n\t\treturn clone(source);\n\t}\n\n\treturn mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);\n}\n\nmodule.exports = function (...options) {\n\tconst config = merge(clone(defaultMergeOptions), (this !== globalThis && this) || {}, defaultMergeOptions);\n\tlet merged = {_: {}};\n\n\tfor (const option of options) {\n\t\tif (option === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isOptionObject(option)) {\n\t\t\tthrow new TypeError('`' + option + '` is not an Option Object');\n\t\t}\n\n\t\tmerged = merge(merged, {_: option}, config);\n\t}\n\n\treturn merged._;\n};\n","import { from } from './hasher.js';\nconst sha = name => async data => new Uint8Array(await crypto.subtle.digest(name, data));\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 18,\n  encode: sha('SHA-256')\n});\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 19,\n  encode: sha('SHA-512')\n});","/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n","module.exports = require('./lib/murmurHash3js');\n","import { from } from 'multiformats/hashes/hasher';\nimport { bytes } from 'multiformats';\nimport mur from 'murmurhash3js-revisited';\nfunction fromNumberTo32BitBuf(number) {\n  const bytes = new Array(4);\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 255;\n    number = number >> 8;\n  }\n  return new Uint8Array(bytes);\n}\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 35,\n  encode: input => fromNumberTo32BitBuf(mur.x86.hash32(input))\n});\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 34,\n  encode: input => bytes.fromHex(mur.x64.hash128(input))\n});","import mergeOptions from 'merge-options';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { murmur3128 } from '@multiformats/murmur3';\nasync function hamtHashFn(buf) {\n  return (await murmur3128.encode(buf)).slice(0, 8).reverse();\n}\nconst defaultOptions = {\n  chunker: 'fixed',\n  strategy: 'balanced',\n  rawLeaves: false,\n  onlyHash: false,\n  reduceSingleLeafToSelf: true,\n  hasher: sha256,\n  leafType: 'file',\n  cidVersion: 0,\n  progress: () => () => {\n  },\n  shardSplitThreshold: 1000,\n  fileImportConcurrency: 50,\n  blockWriteConcurrency: 10,\n  minChunkSize: 262144,\n  maxChunkSize: 262144,\n  avgChunkSize: 262144,\n  window: 16,\n  polynomial: 17437180132763652,\n  maxChildrenPerNode: 174,\n  layerRepeat: 4,\n  wrapWithDirectory: false,\n  recursive: false,\n  hidden: false,\n  timeout: undefined,\n  hamtHashFn,\n  hamtHashCode: 34,\n  hamtBucketBits: 8\n};\nexport default (options = {}) => {\n  const defaults = mergeOptions.bind({ ignoreUndefined: true });\n  return defaults(defaultOptions, options);\n};","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n","\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n","\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n","\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n","\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n","\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n","\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n","\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n","\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n","\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n","\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n","\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n","\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n","\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n","\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n","\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n","// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n","import $protobuf from 'protobufjs/minimal.js';\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\nconst $root = $protobuf.roots['ipfs-unixfs'] || ($protobuf.roots['ipfs-unixfs'] = {});\nexport const Data = $root.Data = (() => {\n  function Data(p) {\n    this.blocksizes = [];\n    if (p)\n      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n        if (p[ks[i]] != null)\n          this[ks[i]] = p[ks[i]];\n  }\n  Data.prototype.Type = 0;\n  Data.prototype.Data = $util.newBuffer([]);\n  Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  Data.prototype.blocksizes = $util.emptyArray;\n  Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  Data.prototype.mode = 0;\n  Data.prototype.mtime = null;\n  Data.encode = function encode(m, w) {\n    if (!w)\n      w = $Writer.create();\n    w.uint32(8).int32(m.Type);\n    if (m.Data != null && Object.hasOwnProperty.call(m, 'Data'))\n      w.uint32(18).bytes(m.Data);\n    if (m.filesize != null && Object.hasOwnProperty.call(m, 'filesize'))\n      w.uint32(24).uint64(m.filesize);\n    if (m.blocksizes != null && m.blocksizes.length) {\n      for (var i = 0; i < m.blocksizes.length; ++i)\n        w.uint32(32).uint64(m.blocksizes[i]);\n    }\n    if (m.hashType != null && Object.hasOwnProperty.call(m, 'hashType'))\n      w.uint32(40).uint64(m.hashType);\n    if (m.fanout != null && Object.hasOwnProperty.call(m, 'fanout'))\n      w.uint32(48).uint64(m.fanout);\n    if (m.mode != null && Object.hasOwnProperty.call(m, 'mode'))\n      w.uint32(56).uint32(m.mode);\n    if (m.mtime != null && Object.hasOwnProperty.call(m, 'mtime'))\n      $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n    return w;\n  };\n  Data.decode = function decode(r, l) {\n    if (!(r instanceof $Reader))\n      r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n      case 1:\n        m.Type = r.int32();\n        break;\n      case 2:\n        m.Data = r.bytes();\n        break;\n      case 3:\n        m.filesize = r.uint64();\n        break;\n      case 4:\n        if (!(m.blocksizes && m.blocksizes.length))\n          m.blocksizes = [];\n        if ((t & 7) === 2) {\n          var c2 = r.uint32() + r.pos;\n          while (r.pos < c2)\n            m.blocksizes.push(r.uint64());\n        } else\n          m.blocksizes.push(r.uint64());\n        break;\n      case 5:\n        m.hashType = r.uint64();\n        break;\n      case 6:\n        m.fanout = r.uint64();\n        break;\n      case 7:\n        m.mode = r.uint32();\n        break;\n      case 8:\n        m.mtime = $root.UnixTime.decode(r, r.uint32());\n        break;\n      default:\n        r.skipType(t & 7);\n        break;\n      }\n    }\n    if (!m.hasOwnProperty('Type'))\n      throw $util.ProtocolError('missing required \\'Type\\'', { instance: m });\n    return m;\n  };\n  Data.fromObject = function fromObject(d) {\n    if (d instanceof $root.Data)\n      return d;\n    var m = new $root.Data();\n    switch (d.Type) {\n    case 'Raw':\n    case 0:\n      m.Type = 0;\n      break;\n    case 'Directory':\n    case 1:\n      m.Type = 1;\n      break;\n    case 'File':\n    case 2:\n      m.Type = 2;\n      break;\n    case 'Metadata':\n    case 3:\n      m.Type = 3;\n      break;\n    case 'Symlink':\n    case 4:\n      m.Type = 4;\n      break;\n    case 'HAMTShard':\n    case 5:\n      m.Type = 5;\n      break;\n    }\n    if (d.Data != null) {\n      if (typeof d.Data === 'string')\n        $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n      else if (d.Data.length)\n        m.Data = d.Data;\n    }\n    if (d.filesize != null) {\n      if ($util.Long)\n        (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n      else if (typeof d.filesize === 'string')\n        m.filesize = parseInt(d.filesize, 10);\n      else if (typeof d.filesize === 'number')\n        m.filesize = d.filesize;\n      else if (typeof d.filesize === 'object')\n        m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n    }\n    if (d.blocksizes) {\n      if (!Array.isArray(d.blocksizes))\n        throw TypeError('.Data.blocksizes: array expected');\n      m.blocksizes = [];\n      for (var i = 0; i < d.blocksizes.length; ++i) {\n        if ($util.Long)\n          (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n        else if (typeof d.blocksizes[i] === 'string')\n          m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n        else if (typeof d.blocksizes[i] === 'number')\n          m.blocksizes[i] = d.blocksizes[i];\n        else if (typeof d.blocksizes[i] === 'object')\n          m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n      }\n    }\n    if (d.hashType != null) {\n      if ($util.Long)\n        (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n      else if (typeof d.hashType === 'string')\n        m.hashType = parseInt(d.hashType, 10);\n      else if (typeof d.hashType === 'number')\n        m.hashType = d.hashType;\n      else if (typeof d.hashType === 'object')\n        m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n    }\n    if (d.fanout != null) {\n      if ($util.Long)\n        (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n      else if (typeof d.fanout === 'string')\n        m.fanout = parseInt(d.fanout, 10);\n      else if (typeof d.fanout === 'number')\n        m.fanout = d.fanout;\n      else if (typeof d.fanout === 'object')\n        m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n    }\n    if (d.mode != null) {\n      m.mode = d.mode >>> 0;\n    }\n    if (d.mtime != null) {\n      if (typeof d.mtime !== 'object')\n        throw TypeError('.Data.mtime: object expected');\n      m.mtime = $root.UnixTime.fromObject(d.mtime);\n    }\n    return m;\n  };\n  Data.toObject = function toObject(m, o) {\n    if (!o)\n      o = {};\n    var d = {};\n    if (o.arrays || o.defaults) {\n      d.blocksizes = [];\n    }\n    if (o.defaults) {\n      d.Type = o.enums === String ? 'Raw' : 0;\n      if (o.bytes === String)\n        d.Data = '';\n      else {\n        d.Data = [];\n        if (o.bytes !== Array)\n          d.Data = $util.newBuffer(d.Data);\n      }\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else\n        d.filesize = o.longs === String ? '0' : 0;\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else\n        d.hashType = o.longs === String ? '0' : 0;\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, true);\n        d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else\n        d.fanout = o.longs === String ? '0' : 0;\n      d.mode = 0;\n      d.mtime = null;\n    }\n    if (m.Type != null && m.hasOwnProperty('Type')) {\n      d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n    }\n    if (m.Data != null && m.hasOwnProperty('Data')) {\n      d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n    }\n    if (m.filesize != null && m.hasOwnProperty('filesize')) {\n      if (typeof m.filesize === 'number')\n        d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n      else\n        d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n    }\n    if (m.blocksizes && m.blocksizes.length) {\n      d.blocksizes = [];\n      for (var j = 0; j < m.blocksizes.length; ++j) {\n        if (typeof m.blocksizes[j] === 'number')\n          d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n        else\n          d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n      }\n    }\n    if (m.hashType != null && m.hasOwnProperty('hashType')) {\n      if (typeof m.hashType === 'number')\n        d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n      else\n        d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n    }\n    if (m.fanout != null && m.hasOwnProperty('fanout')) {\n      if (typeof m.fanout === 'number')\n        d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n      else\n        d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n    }\n    if (m.mode != null && m.hasOwnProperty('mode')) {\n      d.mode = m.mode;\n    }\n    if (m.mtime != null && m.hasOwnProperty('mtime')) {\n      d.mtime = $root.UnixTime.toObject(m.mtime, o);\n    }\n    return d;\n  };\n  Data.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  Data.DataType = function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[valuesById[0] = 'Raw'] = 0;\n    values[valuesById[1] = 'Directory'] = 1;\n    values[valuesById[2] = 'File'] = 2;\n    values[valuesById[3] = 'Metadata'] = 3;\n    values[valuesById[4] = 'Symlink'] = 4;\n    values[valuesById[5] = 'HAMTShard'] = 5;\n    return values;\n  }();\n  return Data;\n})();\nexport const UnixTime = $root.UnixTime = (() => {\n  function UnixTime(p) {\n    if (p)\n      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n        if (p[ks[i]] != null)\n          this[ks[i]] = p[ks[i]];\n  }\n  UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  UnixTime.prototype.FractionalNanoseconds = 0;\n  UnixTime.encode = function encode(m, w) {\n    if (!w)\n      w = $Writer.create();\n    w.uint32(8).int64(m.Seconds);\n    if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, 'FractionalNanoseconds'))\n      w.uint32(21).fixed32(m.FractionalNanoseconds);\n    return w;\n  };\n  UnixTime.decode = function decode(r, l) {\n    if (!(r instanceof $Reader))\n      r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n      case 1:\n        m.Seconds = r.int64();\n        break;\n      case 2:\n        m.FractionalNanoseconds = r.fixed32();\n        break;\n      default:\n        r.skipType(t & 7);\n        break;\n      }\n    }\n    if (!m.hasOwnProperty('Seconds'))\n      throw $util.ProtocolError('missing required \\'Seconds\\'', { instance: m });\n    return m;\n  };\n  UnixTime.fromObject = function fromObject(d) {\n    if (d instanceof $root.UnixTime)\n      return d;\n    var m = new $root.UnixTime();\n    if (d.Seconds != null) {\n      if ($util.Long)\n        (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n      else if (typeof d.Seconds === 'string')\n        m.Seconds = parseInt(d.Seconds, 10);\n      else if (typeof d.Seconds === 'number')\n        m.Seconds = d.Seconds;\n      else if (typeof d.Seconds === 'object')\n        m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n    }\n    if (d.FractionalNanoseconds != null) {\n      m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n    }\n    return m;\n  };\n  UnixTime.toObject = function toObject(m, o) {\n    if (!o)\n      o = {};\n    var d = {};\n    if (o.defaults) {\n      if ($util.Long) {\n        var n = new $util.Long(0, 0, false);\n        d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n      } else\n        d.Seconds = o.longs === String ? '0' : 0;\n      d.FractionalNanoseconds = 0;\n    }\n    if (m.Seconds != null && m.hasOwnProperty('Seconds')) {\n      if (typeof m.Seconds === 'number')\n        d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n      else\n        d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n    }\n    if (m.FractionalNanoseconds != null && m.hasOwnProperty('FractionalNanoseconds')) {\n      d.FractionalNanoseconds = m.FractionalNanoseconds;\n    }\n    return d;\n  };\n  UnixTime.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return UnixTime;\n})();\nexport const Metadata = $root.Metadata = (() => {\n  function Metadata(p) {\n    if (p)\n      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n        if (p[ks[i]] != null)\n          this[ks[i]] = p[ks[i]];\n  }\n  Metadata.prototype.MimeType = '';\n  Metadata.encode = function encode(m, w) {\n    if (!w)\n      w = $Writer.create();\n    if (m.MimeType != null && Object.hasOwnProperty.call(m, 'MimeType'))\n      w.uint32(10).string(m.MimeType);\n    return w;\n  };\n  Metadata.decode = function decode(r, l) {\n    if (!(r instanceof $Reader))\n      r = $Reader.create(r);\n    var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n    while (r.pos < c) {\n      var t = r.uint32();\n      switch (t >>> 3) {\n      case 1:\n        m.MimeType = r.string();\n        break;\n      default:\n        r.skipType(t & 7);\n        break;\n      }\n    }\n    return m;\n  };\n  Metadata.fromObject = function fromObject(d) {\n    if (d instanceof $root.Metadata)\n      return d;\n    var m = new $root.Metadata();\n    if (d.MimeType != null) {\n      m.MimeType = String(d.MimeType);\n    }\n    return m;\n  };\n  Metadata.toObject = function toObject(m, o) {\n    if (!o)\n      o = {};\n    var d = {};\n    if (o.defaults) {\n      d.MimeType = '';\n    }\n    if (m.MimeType != null && m.hasOwnProperty('MimeType')) {\n      d.MimeType = m.MimeType;\n    }\n    return d;\n  };\n  Metadata.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  return Metadata;\n})();\nexport {\n  $root as default\n};","import errcode from 'err-code';\nimport * as Pb from './unixfs.js';\nconst PBData = Pb.Data;\nconst types = [\n  'raw',\n  'directory',\n  'file',\n  'metadata',\n  'symlink',\n  'hamt-sharded-directory'\n];\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\nexport function parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n  if (typeof mode === 'number') {\n    return mode & 4095;\n  }\n  mode = mode.toString();\n  if (mode.substring(0, 1) === '0') {\n    return parseInt(mode, 8) & 4095;\n  }\n  return parseInt(mode, 10) & 4095;\n}\nexport function parseMtime(input) {\n  if (input == null) {\n    return undefined;\n  }\n  let mtime;\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    };\n  }\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    };\n  }\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    };\n  }\n  if (input instanceof Date) {\n    const ms = input.getTime();\n    const secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n  return mtime;\n}\nclass UnixFS {\n  static unmarshal(marshaled) {\n    const message = PBData.decode(marshaled);\n    const decoded = PBData.toObject(message, {\n      defaults: false,\n      arrays: true,\n      longs: Number,\n      objects: false\n    });\n    const data = new UnixFS({\n      type: types[decoded.Type],\n      data: decoded.Data,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.mode,\n      mtime: decoded.mtime ? {\n        secs: decoded.mtime.Seconds,\n        nsecs: decoded.mtime.FractionalNanoseconds\n      } : undefined\n    });\n    data._originalMode = decoded.mode || 0;\n    return data;\n  }\n  constructor(options = { type: 'file' }) {\n    const {type, data, blockSizes, hashType, fanout, mtime, mode} = options;\n    if (type && !types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    this.type = type || 'file';\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    this.blockSizes = blockSizes || [];\n    this._originalMode = 0;\n    this.mode = parseMode(mode);\n    if (mtime) {\n      this.mtime = parseMtime(mtime);\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0;\n      }\n    }\n  }\n  set mode(mode) {\n    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n    const parsedMode = parseMode(mode);\n    if (parsedMode !== undefined) {\n      this._mode = parsedMode;\n    }\n  }\n  get mode() {\n    return this._mode;\n  }\n  isDirectory() {\n    return Boolean(this.type && dirTypes.includes(this.type));\n  }\n  addBlockSize(size) {\n    this.blockSizes.push(size);\n  }\n  removeBlockSize(index) {\n    this.blockSizes.splice(index, 1);\n  }\n  fileSize() {\n    if (this.isDirectory()) {\n      return 0;\n    }\n    let sum = 0;\n    this.blockSizes.forEach(size => {\n      sum += size;\n    });\n    if (this.data) {\n      sum += this.data.length;\n    }\n    return sum;\n  }\n  marshal() {\n    let type;\n    switch (this.type) {\n    case 'raw':\n      type = PBData.DataType.Raw;\n      break;\n    case 'directory':\n      type = PBData.DataType.Directory;\n      break;\n    case 'file':\n      type = PBData.DataType.File;\n      break;\n    case 'metadata':\n      type = PBData.DataType.Metadata;\n      break;\n    case 'symlink':\n      type = PBData.DataType.Symlink;\n      break;\n    case 'hamt-sharded-directory':\n      type = PBData.DataType.HAMTShard;\n      break;\n    default:\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    let data = this.data;\n    if (!this.data || !this.data.length) {\n      data = undefined;\n    }\n    let mode;\n    if (this.mode != null) {\n      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined;\n      }\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined;\n      }\n    }\n    let mtime;\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime);\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        };\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds;\n        }\n      }\n    }\n    const pbData = {\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    };\n    return PBData.encode(pbData).finish();\n  }\n}\nexport {\n  UnixFS\n};","import { CID } from 'multiformats/cid';\nimport * as dagPb from '@ipld/dag-pb';\nimport { sha256 } from 'multiformats/hashes/sha2';\nconst persist = async (buffer, blockstore, options) => {\n  if (!options.codec) {\n    options.codec = dagPb;\n  }\n  if (!options.hasher) {\n    options.hasher = sha256;\n  }\n  if (options.cidVersion === undefined) {\n    options.cidVersion = 1;\n  }\n  if (options.codec === dagPb && options.hasher !== sha256) {\n    options.cidVersion = 1;\n  }\n  const multihash = await options.hasher.digest(buffer);\n  const cid = CID.create(options.cidVersion, options.codec.code, multihash);\n  if (!options.onlyHash) {\n    await blockstore.put(cid, buffer, { signal: options.signal });\n  }\n  return cid;\n};\nexport default persist;","import { UnixFS } from 'ipfs-unixfs';\nimport persist from '../utils/persist.js';\nimport {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nconst dirBuilder = async (item, blockstore, options) => {\n  const unixfs = new UnixFS({\n    type: 'directory',\n    mtime: item.mtime,\n    mode: item.mode\n  });\n  const buffer = encode(prepare({ Data: unixfs.marshal() }));\n  const cid = await persist(buffer, blockstore, options);\n  const path = item.path;\n  return {\n    cid,\n    path,\n    unixfs,\n    size: buffer.length\n  };\n};\nexport default dirBuilder;","'use strict'\n\n/**\n * Collects all values from an (async) iterable into an array and returns it.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n */\nconst all = async (source) => {\n  const arr = []\n\n  for await (const entry of source) {\n    arr.push(entry)\n  }\n\n  return arr\n}\n\nmodule.exports = all\n","import all from 'it-all';\nasync function flat(source, reduce) {\n  return reduce(await all(source));\n}\nexport default flat;","import batch from 'it-batch';\nfunction balanced(source, reduce, options) {\n  return reduceToParents(source, reduce, options);\n}\nasync function reduceToParents(source, reduce, options) {\n  const roots = [];\n  for await (const chunked of batch(source, options.maxChildrenPerNode)) {\n    roots.push(await reduce(chunked));\n  }\n  if (roots.length > 1) {\n    return reduceToParents(roots, reduce, options);\n  }\n  return roots[0];\n}\nexport default balanced;","import batch from 'it-batch';\nasync function trickleStream(source, reduce, options) {\n  const root = new Root(options.layerRepeat);\n  let iteration = 0;\n  let maxDepth = 1;\n  let subTree = root;\n  for await (const layer of batch(source, options.maxChildrenPerNode)) {\n    if (subTree.isFull()) {\n      if (subTree !== root) {\n        root.addChild(await subTree.reduce(reduce));\n      }\n      if (iteration && iteration % options.layerRepeat === 0) {\n        maxDepth++;\n      }\n      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n      iteration++;\n    }\n    subTree.append(layer);\n  }\n  if (subTree && subTree !== root) {\n    root.addChild(await subTree.reduce(reduce));\n  }\n  return root.reduce(reduce);\n}\nexport default trickleStream;\nclass SubTree {\n  constructor(maxDepth, layerRepeat, iteration = 0) {\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n  isFull() {\n    if (!this.root.data) {\n      return false;\n    }\n    if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n      this._addNextNodeToParent(this.node);\n      return false;\n    }\n    const distantRelative = this._findParent(this.node, this.currentDepth);\n    if (distantRelative) {\n      this._addNextNodeToParent(distantRelative);\n      return false;\n    }\n    return true;\n  }\n  _addNextNodeToParent(parent) {\n    this.parent = parent;\n    const nextNode = {\n      children: [],\n      depth: parent.depth + 1,\n      parent,\n      maxDepth: this.maxDepth,\n      maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n    };\n    parent.children.push(nextNode);\n    this.currentDepth = nextNode.depth;\n    this.node = nextNode;\n  }\n  append(layer) {\n    this.node.data = layer;\n  }\n  reduce(reduce) {\n    return this._reduce(this.root, reduce);\n  }\n  async _reduce(node, reduce) {\n    let children = [];\n    if (node.children.length) {\n      children = await Promise.all(node.children.filter(child => child.data).map(child => this._reduce(child, reduce)));\n    }\n    return reduce((node.data || []).concat(children));\n  }\n  _findParent(node, depth) {\n    const parent = node.parent;\n    if (!parent || parent.depth === 0) {\n      return;\n    }\n    if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n      return this._findParent(parent, depth);\n    }\n    return parent;\n  }\n}\nclass Root extends SubTree {\n  constructor(layerRepeat) {\n    super(0, layerRepeat);\n    this.root.depth = 0;\n    this.currentDepth = 1;\n  }\n  addChild(child) {\n    this.root.children.push(child);\n  }\n  reduce(reduce) {\n    return reduce((this.root.data || []).concat(this.root.children));\n  }\n}","import { UnixFS } from 'ipfs-unixfs';\nimport persist from '../../utils/persist.js';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* bufferImporter(file, block, options) {\n  for await (let buffer of file.content) {\n    yield async () => {\n      options.progress(buffer.length, file.path);\n      let unixfs;\n      const opts = {\n        codec: dagPb,\n        cidVersion: options.cidVersion,\n        hasher: options.hasher,\n        onlyHash: options.onlyHash\n      };\n      if (options.rawLeaves) {\n        opts.codec = raw;\n        opts.cidVersion = 1;\n      } else {\n        unixfs = new UnixFS({\n          type: options.leafType,\n          data: buffer\n        });\n        buffer = dagPb.encode({\n          Data: unixfs.marshal(),\n          Links: []\n        });\n      }\n      return {\n        cid: await persist(buffer, block, opts),\n        unixfs,\n        size: buffer.length\n      };\n    };\n  }\n}\nexport default bufferImporter;","import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport persist from '../../utils/persist.js';\nimport {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nimport parallelBatch from 'it-parallel-batch';\nimport * as rawCodec from 'multiformats/codecs/raw';\nimport * as dagPb from '@ipld/dag-pb';\nimport dagFlat from './flat.js';\nimport dagBalanced from './balanced.js';\nimport dagTrickle from './trickle.js';\nimport bufferImporterFn from './buffer-importer.js';\nconst dagBuilders = {\n  flat: dagFlat,\n  balanced: dagBalanced,\n  trickle: dagTrickle\n};\nasync function* buildFileBatch(file, blockstore, options) {\n  let count = -1;\n  let previous;\n  let bufferImporter;\n  if (typeof options.bufferImporter === 'function') {\n    bufferImporter = options.bufferImporter;\n  } else {\n    bufferImporter = bufferImporterFn;\n  }\n  for await (const entry of parallelBatch(bufferImporter(file, blockstore, options), options.blockWriteConcurrency)) {\n    count++;\n    if (count === 0) {\n      previous = entry;\n      continue;\n    } else if (count === 1 && previous) {\n      yield previous;\n      previous = null;\n    }\n    yield entry;\n  }\n  if (previous) {\n    previous.single = true;\n    yield previous;\n  }\n}\nconst reduce = (file, blockstore, options) => {\n  async function reducer(leaves) {\n    if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {\n      const leaf = leaves[0];\n      if (file.mtime !== undefined || file.mode !== undefined) {\n        let buffer = await blockstore.get(leaf.cid);\n        leaf.unixfs = new UnixFS({\n          type: 'file',\n          mtime: file.mtime,\n          mode: file.mode,\n          data: buffer\n        });\n        buffer = encode(prepare({ Data: leaf.unixfs.marshal() }));\n        leaf.cid = await persist(buffer, blockstore, {\n          ...options,\n          codec: dagPb,\n          hasher: options.hasher,\n          cidVersion: options.cidVersion\n        });\n        leaf.size = buffer.length;\n      }\n      return {\n        cid: leaf.cid,\n        path: file.path,\n        unixfs: leaf.unixfs,\n        size: leaf.size\n      };\n    }\n    const f = new UnixFS({\n      type: 'file',\n      mtime: file.mtime,\n      mode: file.mode\n    });\n    const links = leaves.filter(leaf => {\n      if (leaf.cid.code === rawCodec.code && leaf.size) {\n        return true;\n      }\n      if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {\n        return true;\n      }\n      return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);\n    }).map(leaf => {\n      if (leaf.cid.code === rawCodec.code) {\n        f.addBlockSize(leaf.size);\n        return {\n          Name: '',\n          Tsize: leaf.size,\n          Hash: leaf.cid\n        };\n      }\n      if (!leaf.unixfs || !leaf.unixfs.data) {\n        f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);\n      } else {\n        f.addBlockSize(leaf.unixfs.data.length);\n      }\n      return {\n        Name: '',\n        Tsize: leaf.size,\n        Hash: leaf.cid\n      };\n    });\n    const node = {\n      Data: f.marshal(),\n      Links: links\n    };\n    const buffer = encode(prepare(node));\n    const cid = await persist(buffer, blockstore, options);\n    return {\n      cid,\n      path: file.path,\n      unixfs: f,\n      size: buffer.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)\n    };\n  }\n  return reducer;\n};\nfunction fileBuilder(file, block, options) {\n  const dagBuilder = dagBuilders[options.strategy];\n  if (!dagBuilder) {\n    throw errCode(new Error(`Unknown importer build strategy name: ${ options.strategy }`), 'ERR_BAD_STRATEGY');\n  }\n  return dagBuilder(buildFileBatch(file, block, options), reduce(file, block, options), options);\n}\nexport default fileBuilder;","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nconst { Buffer } = require('buffer')\nconst symbol = Symbol.for('BufferList')\n\nfunction BufferList (buf) {\n  if (!(this instanceof BufferList)) {\n    return new BufferList(buf)\n  }\n\n  BufferList._init.call(this, buf)\n}\n\nBufferList._init = function _init (buf) {\n  Object.defineProperty(this, symbol, { value: true })\n\n  this._bufs = []\n  this.length = 0\n\n  if (buf) {\n    this.append(buf)\n  }\n}\n\nBufferList.prototype._new = function _new (buf) {\n  return new BufferList(buf)\n}\n\nBufferList.prototype._offset = function _offset (offset) {\n  if (offset === 0) {\n    return [0, 0]\n  }\n\n  let tot = 0\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    const _t = tot + this._bufs[i].length\n    if (offset < _t || i === this._bufs.length - 1) {\n      return [i, offset - tot]\n    }\n    tot = _t\n  }\n}\n\nBufferList.prototype._reverseOffset = function (blOffset) {\n  const bufferId = blOffset[0]\n  let offset = blOffset[1]\n\n  for (let i = 0; i < bufferId; i++) {\n    offset += this._bufs[i].length\n  }\n\n  return offset\n}\n\nBufferList.prototype.get = function get (index) {\n  if (index > this.length || index < 0) {\n    return undefined\n  }\n\n  const offset = this._offset(index)\n\n  return this._bufs[offset[0]][offset[1]]\n}\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start === 'number' && start < 0) {\n    start += this.length\n  }\n\n  if (typeof end === 'number' && end < 0) {\n    end += this.length\n  }\n\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart !== 'number' || srcStart < 0) {\n    srcStart = 0\n  }\n\n  if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n    srcEnd = this.length\n  }\n\n  if (srcStart >= this.length) {\n    return dst || Buffer.alloc(0)\n  }\n\n  if (srcEnd <= 0) {\n    return dst || Buffer.alloc(0)\n  }\n\n  const copy = !!dst\n  const off = this._offset(srcStart)\n  const len = srcEnd - srcStart\n  let bytes = len\n  let bufoff = (copy && dstStart) || 0\n  let start = off[1]\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd === this.length) {\n    if (!copy) {\n      // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (let i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) {\n    // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n  }\n\n  for (let i = off[0]; i < this._bufs.length; i++) {\n    const l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start) {\n      start = 0\n    }\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = typeof end !== 'number' ? this.length : end\n\n  if (start < 0) {\n    start += this.length\n  }\n\n  if (end < 0) {\n    end += this.length\n  }\n\n  if (start === end) {\n    return this._new()\n  }\n\n  const startOffset = this._offset(start)\n  const endOffset = this._offset(end)\n  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] === 0) {\n    buffers.pop()\n  } else {\n    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])\n  }\n\n  if (startOffset[1] !== 0) {\n    buffers[0] = buffers[0].slice(startOffset[1])\n  }\n\n  return this._new(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n\n  return this\n}\n\nBufferList.prototype.duplicate = function duplicate () {\n  const copy = this._new()\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    copy.append(this._bufs[i])\n  }\n\n  return copy\n}\n\nBufferList.prototype.append = function append (buf) {\n  if (buf == null) {\n    return this\n  }\n\n  if (buf.buffer) {\n    // append a view of the underlying ArrayBuffer\n    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))\n  } else if (Array.isArray(buf)) {\n    for (let i = 0; i < buf.length; i++) {\n      this.append(buf[i])\n    }\n  } else if (this._isBufferList(buf)) {\n    // unwrap argument into individual BufferLists\n    for (let i = 0; i < buf._bufs.length; i++) {\n      this.append(buf._bufs[i])\n    }\n  } else {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf === 'number') {\n      buf = buf.toString()\n    }\n\n    this._appendBuffer(Buffer.from(buf))\n  }\n\n  return this\n}\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype.indexOf = function (search, offset, encoding) {\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n  }\n\n  if (typeof search === 'function' || Array.isArray(search)) {\n    throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.')\n  } else if (typeof search === 'number') {\n    search = Buffer.from([search])\n  } else if (typeof search === 'string') {\n    search = Buffer.from(search, encoding)\n  } else if (this._isBufferList(search)) {\n    search = search.slice()\n  } else if (Array.isArray(search.buffer)) {\n    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)\n  } else if (!Buffer.isBuffer(search)) {\n    search = Buffer.from(search)\n  }\n\n  offset = Number(offset || 0)\n\n  if (isNaN(offset)) {\n    offset = 0\n  }\n\n  if (offset < 0) {\n    offset = this.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0\n  }\n\n  if (search.length === 0) {\n    return offset > this.length ? this.length : offset\n  }\n\n  const blOffset = this._offset(offset)\n  let blIndex = blOffset[0] // index of which internal buffer we're working on\n  let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n\n  // scan over each buffer\n  for (; blIndex < this._bufs.length; blIndex++) {\n    const buff = this._bufs[blIndex]\n\n    while (buffOffset < buff.length) {\n      const availableWindow = buff.length - buffOffset\n\n      if (availableWindow >= search.length) {\n        const nativeSearchResult = buff.indexOf(search, buffOffset)\n\n        if (nativeSearchResult !== -1) {\n          return this._reverseOffset([blIndex, nativeSearchResult])\n        }\n\n        buffOffset = buff.length - search.length + 1 // end of native search window\n      } else {\n        const revOffset = this._reverseOffset([blIndex, buffOffset])\n\n        if (this._match(revOffset, search)) {\n          return revOffset\n        }\n\n        buffOffset++\n      }\n    }\n\n    buffOffset = 0\n  }\n\n  return -1\n}\n\nBufferList.prototype._match = function (offset, search) {\n  if (this.length - offset < search.length) {\n    return false\n  }\n\n  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n    if (this.get(offset + searchOffset) !== search[searchOffset]) {\n      return false\n    }\n  }\n  return true\n}\n\n;(function () {\n  const methods = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  }\n\n  for (const m in methods) {\n    (function (m) {\n      if (methods[m] === null) {\n        BufferList.prototype[m] = function (offset, byteLength) {\n          return this.slice(offset, offset + byteLength)[m](0, byteLength)\n        }\n      } else {\n        BufferList.prototype[m] = function (offset = 0) {\n          return this.slice(offset, offset + methods[m])[m](0)\n        }\n      }\n    }(m))\n  }\n}())\n\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferList || BufferList.isBufferList(b)\n}\n\nBufferList.isBufferList = function isBufferList (b) {\n  return b != null && b[symbol]\n}\n\nmodule.exports = BufferList\n","/**\n * Rabin fingerprinting\n *\n * @class Rabin\n */\nclass Rabin {\n    /**\n     * Creates an instance of Rabin.\n     * @param { import(\"./../dist/rabin-wasm\") } asModule\n     * @param {number} [bits=12]\n     * @param {number} [min=8 * 1024]\n     * @param {number} [max=32 * 1024]\n     * @param {number} polynomial\n     * @memberof Rabin\n     */\n    constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {\n        this.bits = bits\n        this.min = min\n        this.max = max\n        this.asModule = asModule\n        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial)\n        this.polynomial = polynomial\n    }\n\n    /**\n     * Fingerprints the buffer\n     *\n     * @param {Uint8Array} buf\n     * @returns {Array<number>}\n     * @memberof Rabin\n     */\n    fingerprint(buf) {\n        const {\n            __retain,\n            __release,\n            __allocArray,\n            __getInt32Array,\n            Int32Array_ID,\n            Uint8Array_ID\n        } = this.asModule\n\n        const lengths = new Int32Array(Math.ceil(buf.length/this.min))\n        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths))\n        const pointer = __retain(__allocArray(Uint8Array_ID, buf))\n\n        const out = this.rabin.fingerprint(pointer, lengthsPtr)\n        const processed = __getInt32Array(out)\n\n        __release(pointer)\n        __release(lengthsPtr)\n\n        const end = processed.indexOf(0);\n        return end >= 0 ? processed.subarray(0, end) : processed;\n    }\n}\n\nmodule.exports = Rabin","\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n","\nconst { instantiate } = require(\"@assemblyscript/loader\");\n\nloadWebAssembly.supported = typeof WebAssembly !== 'undefined'\n\nfunction loadWebAssembly (imp = {}) {\n  if (!loadWebAssembly.supported) return null\n  \n  var wasm = new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112])\n  // make it work async because browsers throw when a wasm module is bigger than 4kb and load sync\n  return instantiate(new Response(new Blob([wasm], {type: 'application/wasm'})), imp)\n}\nmodule.exports = loadWebAssembly\n","const Rabin = require('./rabin')\nconst getRabin = require('../dist/rabin-wasm.node.js')\n\nconst create = async (avg, min, max, windowSize, polynomial) => {\n    const compiled = await getRabin()\n    return new Rabin(compiled, avg, min, max, windowSize, polynomial)\n}\n\nmodule.exports = {\n    Rabin,\n    create\n}\n","import BufferList from 'bl/BufferList.js';\nimport { create } from 'rabin-wasm';\nimport errcode from 'err-code';\nasync function* rabinChunker(source, options) {\n  let min, max, avg;\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  }\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n  if (max < min) {\n    max = min;\n  }\n  if (avg < min) {\n    avg = min;\n  }\n  const sizepow = Math.floor(Math.log2(avg));\n  for await (const chunk of rabin(source, {\n      min: min,\n      max: max,\n      bits: sizepow,\n      window: options.window,\n      polynomial: options.polynomial\n    })) {\n    yield chunk;\n  }\n}\nexport default rabinChunker;\nasync function* rabin(source, options) {\n  const r = await create(options.bits, options.min, options.max, options.window);\n  const buffers = new BufferList();\n  for await (const chunk of source) {\n    buffers.append(chunk);\n    const sizes = r.fingerprint(chunk);\n    for (let i = 0; i < sizes.length; i++) {\n      const size = sizes[i];\n      const buf = buffers.slice(0, size);\n      buffers.consume(size);\n      yield buf;\n    }\n  }\n  if (buffers.length) {\n    yield buffers.slice(0);\n  }\n}","import BufferList from 'bl/BufferList.js';\nasync function* fixedSizeChunker(source, options) {\n  let bl = new BufferList();\n  let currentLength = 0;\n  let emitted = false;\n  const maxChunkSize = options.maxChunkSize;\n  for await (const buffer of source) {\n    bl.append(buffer);\n    currentLength += buffer.length;\n    while (currentLength >= maxChunkSize) {\n      yield bl.slice(0, maxChunkSize);\n      emitted = true;\n      if (maxChunkSize === bl.length) {\n        bl = new BufferList();\n        currentLength = 0;\n      } else {\n        const newBl = new BufferList();\n        newBl.append(bl.shallowSlice(maxChunkSize));\n        bl = newBl;\n        currentLength -= maxChunkSize;\n      }\n    }\n  }\n  if (!emitted || currentLength) {\n    yield bl.slice(0, currentLength);\n  }\n}\nexport default fixedSizeChunker;","import { from } from './base.js';\nimport {\n  fromString,\n  toString\n} from '../bytes.js';\nexport const identity = from({\n  prefix: '\\0',\n  name: 'identity',\n  encode: buf => toString(buf),\n  decode: str => fromString(str)\n});","import { rfc4648 } from './base.js';\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n});","import { rfc4648 } from './base.js';\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n});","import { baseX } from './base.js';\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n});","import { rfc4648 } from './base.js';\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n});\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n});","import { baseX } from './base.js';\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n});\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n});","import { rfc4648 } from './base.js';\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n});\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n});\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n});\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n});","import { from } from './base.js';\nconst alphabet = Array.from('\\uD83D\\uDE80\\uD83E\\uDE90\\u2604\\uD83D\\uDEF0\\uD83C\\uDF0C\\uD83C\\uDF11\\uD83C\\uDF12\\uD83C\\uDF13\\uD83C\\uDF14\\uD83C\\uDF15\\uD83C\\uDF16\\uD83C\\uDF17\\uD83C\\uDF18\\uD83C\\uDF0D\\uD83C\\uDF0F\\uD83C\\uDF0E\\uD83D\\uDC09\\u2600\\uD83D\\uDCBB\\uD83D\\uDDA5\\uD83D\\uDCBE\\uD83D\\uDCBF\\uD83D\\uDE02\\u2764\\uD83D\\uDE0D\\uD83E\\uDD23\\uD83D\\uDE0A\\uD83D\\uDE4F\\uD83D\\uDC95\\uD83D\\uDE2D\\uD83D\\uDE18\\uD83D\\uDC4D\\uD83D\\uDE05\\uD83D\\uDC4F\\uD83D\\uDE01\\uD83D\\uDD25\\uD83E\\uDD70\\uD83D\\uDC94\\uD83D\\uDC96\\uD83D\\uDC99\\uD83D\\uDE22\\uD83E\\uDD14\\uD83D\\uDE06\\uD83D\\uDE44\\uD83D\\uDCAA\\uD83D\\uDE09\\u263A\\uD83D\\uDC4C\\uD83E\\uDD17\\uD83D\\uDC9C\\uD83D\\uDE14\\uD83D\\uDE0E\\uD83D\\uDE07\\uD83C\\uDF39\\uD83E\\uDD26\\uD83C\\uDF89\\uD83D\\uDC9E\\u270C\\u2728\\uD83E\\uDD37\\uD83D\\uDE31\\uD83D\\uDE0C\\uD83C\\uDF38\\uD83D\\uDE4C\\uD83D\\uDE0B\\uD83D\\uDC97\\uD83D\\uDC9A\\uD83D\\uDE0F\\uD83D\\uDC9B\\uD83D\\uDE42\\uD83D\\uDC93\\uD83E\\uDD29\\uD83D\\uDE04\\uD83D\\uDE00\\uD83D\\uDDA4\\uD83D\\uDE03\\uD83D\\uDCAF\\uD83D\\uDE48\\uD83D\\uDC47\\uD83C\\uDFB6\\uD83D\\uDE12\\uD83E\\uDD2D\\u2763\\uD83D\\uDE1C\\uD83D\\uDC8B\\uD83D\\uDC40\\uD83D\\uDE2A\\uD83D\\uDE11\\uD83D\\uDCA5\\uD83D\\uDE4B\\uD83D\\uDE1E\\uD83D\\uDE29\\uD83D\\uDE21\\uD83E\\uDD2A\\uD83D\\uDC4A\\uD83E\\uDD73\\uD83D\\uDE25\\uD83E\\uDD24\\uD83D\\uDC49\\uD83D\\uDC83\\uD83D\\uDE33\\u270B\\uD83D\\uDE1A\\uD83D\\uDE1D\\uD83D\\uDE34\\uD83C\\uDF1F\\uD83D\\uDE2C\\uD83D\\uDE43\\uD83C\\uDF40\\uD83C\\uDF37\\uD83D\\uDE3B\\uD83D\\uDE13\\u2B50\\u2705\\uD83E\\uDD7A\\uD83C\\uDF08\\uD83D\\uDE08\\uD83E\\uDD18\\uD83D\\uDCA6\\u2714\\uD83D\\uDE23\\uD83C\\uDFC3\\uD83D\\uDC90\\u2639\\uD83C\\uDF8A\\uD83D\\uDC98\\uD83D\\uDE20\\u261D\\uD83D\\uDE15\\uD83C\\uDF3A\\uD83C\\uDF82\\uD83C\\uDF3B\\uD83D\\uDE10\\uD83D\\uDD95\\uD83D\\uDC9D\\uD83D\\uDE4A\\uD83D\\uDE39\\uD83D\\uDDE3\\uD83D\\uDCAB\\uD83D\\uDC80\\uD83D\\uDC51\\uD83C\\uDFB5\\uD83E\\uDD1E\\uD83D\\uDE1B\\uD83D\\uDD34\\uD83D\\uDE24\\uD83C\\uDF3C\\uD83D\\uDE2B\\u26BD\\uD83E\\uDD19\\u2615\\uD83C\\uDFC6\\uD83E\\uDD2B\\uD83D\\uDC48\\uD83D\\uDE2E\\uD83D\\uDE46\\uD83C\\uDF7B\\uD83C\\uDF43\\uD83D\\uDC36\\uD83D\\uDC81\\uD83D\\uDE32\\uD83C\\uDF3F\\uD83E\\uDDE1\\uD83C\\uDF81\\u26A1\\uD83C\\uDF1E\\uD83C\\uDF88\\u274C\\u270A\\uD83D\\uDC4B\\uD83D\\uDE30\\uD83E\\uDD28\\uD83D\\uDE36\\uD83E\\uDD1D\\uD83D\\uDEB6\\uD83D\\uDCB0\\uD83C\\uDF53\\uD83D\\uDCA2\\uD83E\\uDD1F\\uD83D\\uDE41\\uD83D\\uDEA8\\uD83D\\uDCA8\\uD83E\\uDD2C\\u2708\\uD83C\\uDF80\\uD83C\\uDF7A\\uD83E\\uDD13\\uD83D\\uDE19\\uD83D\\uDC9F\\uD83C\\uDF31\\uD83D\\uDE16\\uD83D\\uDC76\\uD83E\\uDD74\\u25B6\\u27A1\\u2753\\uD83D\\uDC8E\\uD83D\\uDCB8\\u2B07\\uD83D\\uDE28\\uD83C\\uDF1A\\uD83E\\uDD8B\\uD83D\\uDE37\\uD83D\\uDD7A\\u26A0\\uD83D\\uDE45\\uD83D\\uDE1F\\uD83D\\uDE35\\uD83D\\uDC4E\\uD83E\\uDD32\\uD83E\\uDD20\\uD83E\\uDD27\\uD83D\\uDCCC\\uD83D\\uDD35\\uD83D\\uDC85\\uD83E\\uDDD0\\uD83D\\uDC3E\\uD83C\\uDF52\\uD83D\\uDE17\\uD83E\\uDD11\\uD83C\\uDF0A\\uD83E\\uDD2F\\uD83D\\uDC37\\u260E\\uD83D\\uDCA7\\uD83D\\uDE2F\\uD83D\\uDC86\\uD83D\\uDC46\\uD83C\\uDFA4\\uD83D\\uDE47\\uD83C\\uDF51\\u2744\\uD83C\\uDF34\\uD83D\\uDCA3\\uD83D\\uDC38\\uD83D\\uDC8C\\uD83D\\uDCCD\\uD83E\\uDD40\\uD83E\\uDD22\\uD83D\\uDC45\\uD83D\\uDCA1\\uD83D\\uDCA9\\uD83D\\uDC50\\uD83D\\uDCF8\\uD83D\\uDC7B\\uD83E\\uDD10\\uD83E\\uDD2E\\uD83C\\uDFBC\\uD83E\\uDD75\\uD83D\\uDEA9\\uD83C\\uDF4E\\uD83C\\uDF4A\\uD83D\\uDC7C\\uD83D\\uDC8D\\uD83D\\uDCE3\\uD83E\\uDD42');\nconst alphabetBytesToChars = alphabet.reduce((p, c, i) => {\n  p[i] = c;\n  return p;\n}, []);\nconst alphabetCharsToBytes = alphabet.reduce((p, c, i) => {\n  p[c.codePointAt(0)] = i;\n  return p;\n}, []);\nfunction encode(data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c];\n    return p;\n  }, '');\n}\nfunction decode(str) {\n  const byts = [];\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[char.codePointAt(0)];\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${ char }`);\n    }\n    byts.push(byt);\n  }\n  return new Uint8Array(byts);\n}\nexport const base256emoji = from({\n  prefix: '\\uD83D\\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n});","const textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport const name = 'json';\nexport const code = 512;\nexport const encode = node => textEncoder.encode(JSON.stringify(node));\nexport const decode = data => JSON.parse(textDecoder.decode(data));","import * as identityBase from './bases/identity.js';\nimport * as base2 from './bases/base2.js';\nimport * as base8 from './bases/base8.js';\nimport * as base10 from './bases/base10.js';\nimport * as base16 from './bases/base16.js';\nimport * as base32 from './bases/base32.js';\nimport * as base36 from './bases/base36.js';\nimport * as base58 from './bases/base58.js';\nimport * as base64 from './bases/base64.js';\nimport * as base256emoji from './bases/base256emoji.js';\nimport * as sha2 from './hashes/sha2.js';\nimport * as identity from './hashes/identity.js';\nimport * as raw from './codecs/raw.js';\nimport * as json from './codecs/json.js';\nimport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes\n} from './index.js';\nconst bases = {\n  ...identityBase,\n  ...base2,\n  ...base8,\n  ...base10,\n  ...base16,\n  ...base32,\n  ...base36,\n  ...base58,\n  ...base64,\n  ...base256emoji\n};\nconst hashes = {\n  ...sha2,\n  ...identity\n};\nconst codecs = {\n  raw,\n  json\n};\nexport {\n  CID,\n  hasher,\n  digest,\n  varint,\n  bytes,\n  hashes,\n  bases,\n  codecs\n};","export function alloc(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {\n    return globalThis.Buffer.alloc(size);\n  }\n  return new Uint8Array(size);\n}\nexport function allocUnsafe(size = 0) {\n  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {\n    return globalThis.Buffer.allocUnsafe(size);\n  }\n  return new Uint8Array(size);\n}","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: { decode }\n  };\n}\nconst string = createCodec('utf8', 'u', buf => {\n  const decoder = new TextDecoder('utf8');\n  return 'u' + decoder.decode(buf);\n}, str => {\n  const encoder = new TextEncoder();\n  return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', buf => {\n  let string = 'a';\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i]);\n  }\n  return string;\n}, str => {\n  str = str.substring(1);\n  const buf = allocUnsafe(str.length);\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n});\nconst BASES = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n  ...bases\n};\nexport default BASES;","import bases from './util/bases.js';\nexport function fromString(string, encoding = 'utf8') {\n  const base = bases[encoding];\n  if (!base) {\n    throw new Error(`Unsupported encoding \"${ encoding }\"`);\n  }\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return globalThis.Buffer.from(string, 'utf8');\n  }\n  return base.decoder.decode(`${ base.prefix }${ string }`);\n}","import errCode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nasync function* validateChunks(source) {\n  for await (const content of source) {\n    if (content.length === undefined) {\n      throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n    }\n    if (typeof content === 'string' || content instanceof String) {\n      yield uint8ArrayFromString(content.toString());\n    } else if (Array.isArray(content)) {\n      yield Uint8Array.from(content);\n    } else if (content instanceof Uint8Array) {\n      yield content;\n    } else {\n      throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n    }\n  }\n}\nexport default validateChunks;","import dirBuilder from './dir.js';\nimport fileBuilder from './file/index.js';\nimport errCode from 'err-code';\nimport rabin from '../chunker/rabin.js';\nimport fixedSize from '../chunker/fixed-size.js';\nimport validateChunks from './validate-chunks.js';\nfunction isIterable(thing) {\n  return Symbol.iterator in thing;\n}\nfunction isAsyncIterable(thing) {\n  return Symbol.asyncIterator in thing;\n}\nfunction contentAsAsyncIterable(content) {\n  try {\n    if (content instanceof Uint8Array) {\n      return async function* () {\n        yield content;\n      }();\n    } else if (isIterable(content)) {\n      return async function* () {\n        yield* content;\n      }();\n    } else if (isAsyncIterable(content)) {\n      return content;\n    }\n  } catch {\n    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n  }\n  throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');\n}\nasync function* dagBuilder(source, blockstore, options) {\n  for await (const entry of source) {\n    if (entry.path) {\n      if (entry.path.substring(0, 2) === './') {\n        options.wrapWithDirectory = true;\n      }\n      entry.path = entry.path.split('/').filter(path => path && path !== '.').join('/');\n    }\n    if (entry.content) {\n      let chunker;\n      if (typeof options.chunker === 'function') {\n        chunker = options.chunker;\n      } else if (options.chunker === 'rabin') {\n        chunker = rabin;\n      } else {\n        chunker = fixedSize;\n      }\n      let chunkValidator;\n      if (typeof options.chunkValidator === 'function') {\n        chunkValidator = options.chunkValidator;\n      } else {\n        chunkValidator = validateChunks;\n      }\n      const file = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode,\n        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)\n      };\n      yield () => fileBuilder(file, blockstore, options);\n    } else if (entry.path) {\n      const dir = {\n        path: entry.path,\n        mtime: entry.mtime,\n        mode: entry.mode\n      };\n      yield () => dirBuilder(dir, blockstore, options);\n    } else {\n      throw new Error('Import candidate must have content or path or both');\n    }\n  }\n}\nexport default dagBuilder;","class Dir {\n  constructor(props, options) {\n    this.options = options || {};\n    this.root = props.root;\n    this.dir = props.dir;\n    this.path = props.path;\n    this.dirty = props.dirty;\n    this.flat = props.flat;\n    this.parent = props.parent;\n    this.parentKey = props.parentKey;\n    this.unixfs = props.unixfs;\n    this.mode = props.mode;\n    this.mtime = props.mtime;\n    this.cid = undefined;\n    this.size = undefined;\n  }\n  async put(name, value) {\n  }\n  get(name) {\n    return Promise.resolve(this);\n  }\n  async *eachChildSeries() {\n  }\n  async *flush(blockstore) {\n  }\n}\nexport default Dir;","import {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\nclass DirFlat extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._children = {};\n  }\n  async put(name, value) {\n    this.cid = undefined;\n    this.size = undefined;\n    this._children[name] = value;\n  }\n  get(name) {\n    return Promise.resolve(this._children[name]);\n  }\n  childCount() {\n    return Object.keys(this._children).length;\n  }\n  directChildrenCount() {\n    return this.childCount();\n  }\n  onlyChild() {\n    return this._children[Object.keys(this._children)[0]];\n  }\n  async *eachChildSeries() {\n    const keys = Object.keys(this._children);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      yield {\n        key: key,\n        child: this._children[key]\n      };\n    }\n  }\n  async *flush(block) {\n    const children = Object.keys(this._children);\n    const links = [];\n    for (let i = 0; i < children.length; i++) {\n      let child = this._children[children[i]];\n      if (child instanceof Dir) {\n        for await (const entry of child.flush(block)) {\n          child = entry;\n          yield child;\n        }\n      }\n      if (child.size != null && child.cid) {\n        links.push({\n          Name: children[i],\n          Tsize: child.size,\n          Hash: child.cid\n        });\n      }\n    }\n    const unixfs = new UnixFS({\n      type: 'directory',\n      mtime: this.mtime,\n      mode: this.mode\n    });\n    const node = {\n      Data: unixfs.marshal(),\n      Links: links\n    };\n    const buffer = encode(prepare(node));\n    const cid = await persist(buffer, block, this.options);\n    const size = buffer.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);\n    this.cid = cid;\n    this.size = size;\n    yield {\n      cid,\n      unixfs,\n      path: this.path,\n      size\n    };\n  }\n}\nexport default DirFlat;","'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}","'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n","'use strict'\n\nconst START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nmodule.exports = class ConsumableBuffer {\n  /**\n   * @param {Uint8Array} value\n   */\n  constructor (value) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits () {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits () {\n    return this._value.length * 8\n  }\n\n  /**\n   * @param {number} bits\n   */\n  take (bits) {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits () {\n    return this._currentBytePos >= 0\n  }\n}\n\n/**\n * @param {number} byte\n * @param {number} start\n * @param {number} length\n */\nfunction byteBitsToInt (byte, start, length) {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\n/**\n * @param {number} start\n * @param {number} length\n */\nfunction maskFor (start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n","import { allocUnsafe } from './alloc.js';\nexport function concat(arrays, length) {\n  if (!length) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0);\n  }\n  const output = allocUnsafe(length);\n  let offset = 0;\n  for (const arr of arrays) {\n    output.set(arr, offset);\n    offset += arr.length;\n  }\n  return output;\n}","'use strict'\n\nconst ConsumableBuffer = require('./consumable-buffer')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\n\n/**\n * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n */\nfunction wrapHash (hashFn) {\n  /**\n   * @param {InfiniteHash | Uint8Array} value\n   */\n  function hashing (value) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nclass InfiniteHash {\n  /**\n   *\n   * @param {Uint8Array} value\n   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n   */\n  constructor (value, hashFn) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n\n    /** @type {ConsumableBuffer[]} */\n    this._buffers = []\n  }\n\n  /**\n   * @param {number} bits\n   */\n  async take (bits) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * @param {number} bits\n   */\n  untake (bits) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n\nmodule.exports = wrapHash\nmodule.exports.InfiniteHash = InfiniteHash\n","'use strict'\n\nconst Bucket = require('./bucket')\nconst wrapHash = require('./consumable-hash')\n\n/**\n * @typedef {object} UserBucketOptions\n * @property {(value: Uint8Array) => Promise<Uint8Array>} hashFn\n * @property {number} [bits=8]\n */\n\n/**\n * @param {UserBucketOptions} options\n */\nfunction createHAMT (options) {\n  if (!options || !options.hashFn) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits || 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket(bucketOptions)\n}\n\nmodule.exports = {\n  createHAMT,\n  Bucket\n}\n","import {\n  encode,\n  prepare\n} from '@ipld/dag-pb';\nimport { UnixFS } from 'ipfs-unixfs';\nimport Dir from './dir.js';\nimport persist from './utils/persist.js';\nimport {\n  createHAMT,\n  Bucket\n} from 'hamt-sharding';\nclass DirSharded extends Dir {\n  constructor(props, options) {\n    super(props, options);\n    this._bucket = createHAMT({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    });\n  }\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n  get(name) {\n    return this._bucket.get(name);\n  }\n  childCount() {\n    return this._bucket.leafCount();\n  }\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n  async *eachChildSeries() {\n    for await (const {key, value} of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n  async *flush(blockstore) {\n    for await (const entry of flush(this._bucket, blockstore, this, this.options)) {\n      yield {\n        ...entry,\n        path: this.path\n      };\n    }\n  }\n}\nexport default DirSharded;\nasync function* flush(bucket, blockstore, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n    if (!child) {\n      continue;\n    }\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n    if (child instanceof Bucket) {\n      let shard;\n      for await (const subShard of await flush(child, blockstore, null, options)) {\n        shard = subShard;\n      }\n      if (!shard) {\n        throw new Error('Could not flush sharded directory, no subshard found');\n      }\n      links.push({\n        Name: labelPrefix,\n        Tsize: shard.size,\n        Hash: shard.cid\n      });\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n      for await (const entry of dir.flush(blockstore)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n      const label = labelPrefix + child.key;\n      links.push({\n        Name: label,\n        Tsize: flushedDir.size,\n        Hash: flushedDir.cid\n      });\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n      if (!value.cid) {\n        continue;\n      }\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push({\n        Name: label,\n        Tsize: size,\n        Hash: value.cid\n      });\n      childrenSize += size;\n    }\n  }\n  const data = Uint8Array.from(children.bitField().reverse());\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashCode,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = {\n    Data: dir.marshal(),\n    Links: links\n  };\n  const buffer = encode(prepare(node));\n  const cid = await persist(buffer, blockstore, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    unixfs: dir,\n    size\n  };\n}","import DirSharded from './dir-sharded.js';\nimport DirFlat from './dir-flat.js';\nasync function flatToShard(child, dir, threshold, options) {\n  let newDir = dir;\n  if (dir instanceof DirFlat && dir.directChildrenCount() >= threshold) {\n    newDir = await convertToShard(dir, options);\n  }\n  const parent = newDir.parent;\n  if (parent) {\n    if (newDir !== dir) {\n      if (child) {\n        child.parent = newDir;\n      }\n      if (!newDir.parentKey) {\n        throw new Error('No parent key found');\n      }\n      await parent.put(newDir.parentKey, newDir);\n    }\n    return flatToShard(newDir, parent, threshold, options);\n  }\n  return newDir;\n}\nasync function convertToShard(oldDir, options) {\n  const newDir = new DirSharded({\n    root: oldDir.root,\n    dir: true,\n    parent: oldDir.parent,\n    parentKey: oldDir.parentKey,\n    path: oldDir.path,\n    dirty: oldDir.dirty,\n    flat: false,\n    mtime: oldDir.mtime,\n    mode: oldDir.mode\n  }, options);\n  for await (const {key, child} of oldDir.eachChildSeries()) {\n    await newDir.put(key, child);\n  }\n  return newDir;\n}\nexport default flatToShard;","const toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nexport default toPathComponents;","import DirFlat from './dir-flat.js';\nimport flatToShard from './flat-to-shard.js';\nimport Dir from './dir.js';\nimport toPathComponents from './utils/to-path-components.js';\nasync function addToTree(elem, tree, options) {\n  const pathElems = toPathComponents(elem.path || '');\n  const lastIndex = pathElems.length - 1;\n  let parent = tree;\n  let currentPath = '';\n  for (let i = 0; i < pathElems.length; i++) {\n    const pathElem = pathElems[i];\n    currentPath += `${ currentPath ? '/' : '' }${ pathElem }`;\n    const last = i === lastIndex;\n    parent.dirty = true;\n    parent.cid = undefined;\n    parent.size = undefined;\n    if (last) {\n      await parent.put(pathElem, elem);\n      tree = await flatToShard(null, parent, options.shardSplitThreshold, options);\n    } else {\n      let dir = await parent.get(pathElem);\n      if (!dir || !(dir instanceof Dir)) {\n        dir = new DirFlat({\n          root: false,\n          dir: true,\n          parent: parent,\n          parentKey: pathElem,\n          path: currentPath,\n          dirty: true,\n          flat: true,\n          mtime: dir && dir.unixfs && dir.unixfs.mtime,\n          mode: dir && dir.unixfs && dir.unixfs.mode\n        }, options);\n      }\n      await parent.put(pathElem, dir);\n      parent = dir;\n    }\n  }\n  return tree;\n}\nasync function* flushAndYield(tree, blockstore) {\n  if (!(tree instanceof Dir)) {\n    if (tree && tree.unixfs && tree.unixfs.isDirectory()) {\n      yield tree;\n    }\n    return;\n  }\n  yield* tree.flush(blockstore);\n}\nasync function* treeBuilder(source, block, options) {\n  let tree = new DirFlat({\n    root: true,\n    dir: true,\n    path: '',\n    dirty: true,\n    flat: true\n  }, options);\n  for await (const entry of source) {\n    if (!entry) {\n      continue;\n    }\n    tree = await addToTree(entry, tree, options);\n    if (!entry.unixfs || !entry.unixfs.isDirectory()) {\n      yield entry;\n    }\n  }\n  if (options.wrapWithDirectory) {\n    yield* flushAndYield(tree, block);\n  } else {\n    for await (const unwrapped of tree.eachChildSeries()) {\n      if (!unwrapped) {\n        continue;\n      }\n      yield* flushAndYield(unwrapped.child, block);\n    }\n  }\n}\nexport default treeBuilder;","import parallelBatch from 'it-parallel-batch';\nimport defaultOptions from './options.js';\nimport dagBuilderFn from './dag-builder/index.js';\nimport treeBuilderFn from './tree-builder.js';\nexport async function* importer(source, blockstore, options = {}) {\n  const opts = defaultOptions(options);\n  let dagBuilder;\n  if (typeof options.dagBuilder === 'function') {\n    dagBuilder = options.dagBuilder;\n  } else {\n    dagBuilder = dagBuilderFn;\n  }\n  let treeBuilder;\n  if (typeof options.treeBuilder === 'function') {\n    treeBuilder = options.treeBuilder;\n  } else {\n    treeBuilder = treeBuilderFn;\n  }\n  let candidates;\n  if (Symbol.asyncIterator in source || Symbol.iterator in source) {\n    candidates = source;\n  } else {\n    candidates = [source];\n  }\n  for await (const entry of treeBuilder(parallelBatch(dagBuilder(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {\n    yield {\n      cid: entry.cid,\n      path: entry.path,\n      unixfs: entry.unixfs,\n      size: entry.size\n    };\n  }\n}","'use strict'\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n * @template T\n * @param {ReadableStream<T>} stream\n * @param {Object} [options]\n * @param {boolean} [options.preventCancel=boolean]\n * @returns {AsyncIterable<T>}\n */\nasync function * browserReadableStreamToIt (stream, options = {}) {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n\nmodule.exports = browserReadableStreamToIt\n","/* eslint-env browser */\n\n'use strict'\n\nconst browserReadableStreamToIt = require('browser-readablestream-to-it')\n\n/**\n * @param {Blob} blob\n * @returns {AsyncIterable<Uint8Array>}\n */\nfunction blobToIt (blob) {\n  if (typeof blob.stream === 'function') {\n    // @ts-ignore missing some properties\n    return browserReadableStreamToIt(blob.stream())\n  }\n\n  // firefox < 69 does not support blob.stream()\n  // @ts-ignore - response.body is optional, but in practice it's a stream.\n  return browserReadableStreamToIt(new Response(blob).body)\n}\n\nmodule.exports = blobToIt\n","'use strict'\n\n/**\n * @template T\n * @typedef {Object} Peek\n * @property {() => IteratorResult<T, void>} peek\n */\n\n/**\n * @template T\n * @typedef {Object} AsyncPeek\n * @property {() => Promise<IteratorResult<T, void>>} peek\n */\n\n/**\n * @template T\n * @typedef {Object} Push\n * @property {(value:T) => void} push\n */\n\n/**\n * @template T\n * @typedef {Iterable<T> & Peek<T> & Push<T> & Iterator<T>} Peekable<T>\n */\n\n/**\n * @template T\n * @typedef {AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>} AsyncPeekable<T>\n */\n\n/**\n * @template {Iterable<any> | AsyncIterable<any>} I\n * @param {I} iterable\n * @returns {I extends Iterable<infer T>\n *  ? Peekable<T>\n *  : I extends AsyncIterable<infer T>\n *  ? AsyncPeekable<T>\n *  : never\n * }\n */\nfunction peekableIterator (iterable) {\n  // @ts-ignore\n  const [iterator, symbol] = iterable[Symbol.asyncIterator]\n    // @ts-ignore\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-ignore\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  /** @type {any[]} */\n  const queue = []\n\n  // @ts-ignore\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nmodule.exports = peekableIterator\n","'use strict'\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function.\n *\n * @template I,O\n * @param {AsyncIterable<I>|Iterable<I>} source\n * @param {function(I):O|Promise<O>} func\n * @returns {AsyncIterable<O>}\n */\nconst map = async function * (source, func) {\n  for await (const val of source) {\n    yield func(val)\n  }\n}\n\nmodule.exports = map\n","export function isBytes(obj) {\n  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nexport function isBlob(obj) {\n  return obj.constructor && (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') && typeof obj.stream === 'function';\n}\nexport function isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\nexport const isReadableStream = value => value && typeof value.getReader === 'function';","import errCode from 'err-code';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport browserStreamToIt from 'browser-readablestream-to-it';\nimport blobToIt from 'blob-to-it';\nimport itPeekable from 'it-peekable';\nimport all from 'it-all';\nimport map from 'it-map';\nimport {\n  isBytes,\n  isReadableStream,\n  isBlob\n} from './utils.js';\nasync function* toAsyncIterable(thing) {\n  yield thing;\n}\nexport async function normaliseContent(input) {\n  if (isBytes(input)) {\n    return toAsyncIterable(toBytes(input));\n  }\n  if (typeof input === 'string' || input instanceof String) {\n    return toAsyncIterable(toBytes(input.toString()));\n  }\n  if (isBlob(input)) {\n    return blobToIt(input);\n  }\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input);\n  }\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    const peekable = itPeekable(input);\n    const {value, done} = await peekable.peek();\n    if (done) {\n      return toAsyncIterable(new Uint8Array(0));\n    }\n    peekable.push(value);\n    if (Number.isInteger(value)) {\n      return toAsyncIterable(Uint8Array.from(await all(peekable)));\n    }\n    if (isBytes(value) || typeof value === 'string' || value instanceof String) {\n      return map(peekable, toBytes);\n    }\n  }\n  throw errCode(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');\n}\nfunction toBytes(chunk) {\n  if (chunk instanceof Uint8Array) {\n    return chunk;\n  }\n  if (ArrayBuffer.isView(chunk)) {\n    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n  }\n  if (chunk instanceof ArrayBuffer) {\n    return new Uint8Array(chunk);\n  }\n  if (Array.isArray(chunk)) {\n    return Uint8Array.from(chunk);\n  }\n  return uint8ArrayFromString(chunk.toString());\n}","import errCode from 'err-code';\nimport browserStreamToIt from 'browser-readablestream-to-it';\nimport itPeekable from 'it-peekable';\nimport {\n  isBytes,\n  isBlob,\n  isReadableStream,\n  isFileObject\n} from './utils.js';\nimport {\n  parseMtime,\n  parseMode\n} from 'ipfs-unixfs';\nexport async function* normaliseCandidateSingle(input, normaliseContent) {\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${ input }`), 'ERR_UNEXPECTED_INPUT');\n  }\n  if (typeof input === 'string' || input instanceof String) {\n    yield toFileObject(input.toString(), normaliseContent);\n    return;\n  }\n  if (isBytes(input) || isBlob(input)) {\n    yield toFileObject(input, normaliseContent);\n    return;\n  }\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input);\n  }\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    const peekable = itPeekable(input);\n    const {value, done} = await peekable.peek();\n    if (done) {\n      yield { content: [] };\n      return;\n    }\n    peekable.push(value);\n    if (Number.isInteger(value) || isBytes(value) || typeof value === 'string' || value instanceof String) {\n      yield toFileObject(peekable, normaliseContent);\n      return;\n    }\n    throw errCode(new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT');\n  }\n  if (isFileObject(input)) {\n    yield toFileObject(input, normaliseContent);\n    return;\n  }\n  throw errCode(new Error('Unexpected input: cannot convert \"' + typeof input + '\" into ImportCandidate'), 'ERR_UNEXPECTED_INPUT');\n}\nasync function toFileObject(input, normaliseContent) {\n  const {path, mode, mtime, content} = input;\n  const file = {\n    path: path || '',\n    mode: parseMode(mode),\n    mtime: parseMtime(mtime)\n  };\n  if (content) {\n    file.content = await normaliseContent(content);\n  } else if (!path) {\n    file.content = await normaliseContent(input);\n  }\n  return file;\n}","import { normaliseContent } from './normalise-content.js';\nimport { normaliseCandidateSingle } from './normalise-candidate-single.js';\nexport function normaliseInput(input) {\n  return normaliseCandidateSingle(input, normaliseContent);\n}","import errCode from 'err-code';\nimport browserStreamToIt from 'browser-readablestream-to-it';\nimport itPeekable from 'it-peekable';\nimport map from 'it-map';\nimport {\n  isBytes,\n  isBlob,\n  isReadableStream,\n  isFileObject\n} from './utils.js';\nimport {\n  parseMtime,\n  parseMode\n} from 'ipfs-unixfs';\nexport async function* normaliseCandidateMultiple(input, normaliseContent) {\n  if (typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || input._readableState) {\n    throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');\n  }\n  if (isReadableStream(input)) {\n    input = browserStreamToIt(input);\n  }\n  if (Symbol.iterator in input || Symbol.asyncIterator in input) {\n    const peekable = itPeekable(input);\n    const {value, done} = await peekable.peek();\n    if (done) {\n      yield* [];\n      return;\n    }\n    peekable.push(value);\n    if (Number.isInteger(value)) {\n      throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');\n    }\n    if (value._readableState) {\n      yield* map(peekable, value => toFileObject({ content: value }, normaliseContent));\n      return;\n    }\n    if (isBytes(value)) {\n      yield toFileObject({ content: peekable }, normaliseContent);\n      return;\n    }\n    if (isFileObject(value) || value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value) || isBlob(value)) {\n      yield* map(peekable, value => toFileObject(value, normaliseContent));\n      return;\n    }\n  }\n  if (isFileObject(input)) {\n    throw errCode(new Error('Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead'), 'ERR_UNEXPECTED_INPUT');\n  }\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n}\nasync function toFileObject(input, normaliseContent) {\n  const {path, mode, mtime, content} = input;\n  const file = {\n    path: path || '',\n    mode: parseMode(mode),\n    mtime: parseMtime(mtime)\n  };\n  if (content) {\n    file.content = await normaliseContent(content);\n  } else if (!path) {\n    file.content = await normaliseContent(input);\n  }\n  return file;\n}","import { normaliseContent } from './normalise-content.js';\nimport { normaliseCandidateMultiple } from './normalise-candidate-multiple.js';\nexport function normaliseInput(input) {\n  return normaliseCandidateMultiple(input, normaliseContent);\n}","import { normaliseInput as normaliseInputSingle } from 'ipfs-core-utils/files/normalise-input-single';\nimport { normaliseInput as normaliseInputMultiple } from 'ipfs-core-utils/files/normalise-input-multiple';\nfunction isBytes(obj) {\n    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\nfunction isBlob(obj) {\n    return Boolean(obj.constructor) &&\n        (obj.constructor.name === 'Blob' || obj.constructor.name === 'File') &&\n        typeof obj.stream === 'function';\n}\nfunction isSingle(input) {\n    return typeof input === 'string' || input instanceof String || isBytes(input) || isBlob(input) || '_readableState' in input;\n}\n/**\n * Get a single or multiple normaliser depending on the input.\n */\nexport function getNormaliser(input) {\n    if (isSingle(input)) {\n        return normaliseInputSingle(input);\n    }\n    else {\n        return normaliseInputMultiple(input);\n    }\n}\n","'use strict'\n\n/**\n * Drains an (async) iterable discarding its' content and does not return\n * anything.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @returns {Promise<void>}\n */\nconst drain = async (source) => {\n  for await (const _ of source) { } // eslint-disable-line no-unused-vars,no-empty\n}\n\nmodule.exports = drain\n","'use strict'\n\n/**\n * Filters the passed (async) iterable by using the filter function\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {function(T):boolean|Promise<boolean>} fn\n */\nconst filter = async function * (source, fn) {\n  for await (const entry of source) {\n    if (await fn(entry)) {\n      yield entry\n    }\n  }\n}\n\nmodule.exports = filter\n","'use strict'\n\n/**\n * Stop iteration after n items have been received.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {number} limit\n * @returns {AsyncIterable<T>}\n */\nconst take = async function * (source, limit) {\n  let items = 0\n\n  if (limit < 1) {\n    return\n  }\n\n  for await (const entry of source) {\n    yield entry\n\n    items++\n\n    if (items === limit) {\n      return\n    }\n  }\n}\n\nmodule.exports = take\n","import drain from 'it-drain';\nimport filter from 'it-filter';\nimport take from 'it-take';\nimport all from 'it-all';\nconst sortAll = (iterable, sorter) => {\n  return async function* () {\n    const values = await all(iterable);\n    yield* values.sort(sorter);\n  }();\n};\nexport class BaseBlockstore {\n  open() {\n    return Promise.reject(new Error('.open is not implemented'));\n  }\n  close() {\n    return Promise.reject(new Error('.close is not implemented'));\n  }\n  put(key, val, options) {\n    return Promise.reject(new Error('.put is not implemented'));\n  }\n  get(key, options) {\n    return Promise.reject(new Error('.get is not implemented'));\n  }\n  has(key, options) {\n    return Promise.reject(new Error('.has is not implemented'));\n  }\n  delete(key, options) {\n    return Promise.reject(new Error('.delete is not implemented'));\n  }\n  async *putMany(source, options = {}) {\n    for await (const {key, value} of source) {\n      await this.put(key, value, options);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  async *getMany(source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options);\n    }\n  }\n  async *deleteMany(source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options);\n      yield key;\n    }\n  }\n  batch() {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n      delete(key) {\n        dels.push(key);\n      },\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  async *_all(q, options) {\n    throw new Error('._all is not implemented');\n  }\n  async *_allKeys(q, options) {\n    throw new Error('._allKeys is not implemented');\n  }\n  query(q, options) {\n    let it = this._all(q, options);\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix || ''));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= (q.offset || 0));\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n  queryKeys(q, options) {\n    let it = this._allKeys(q, options);\n    if (q.prefix != null) {\n      it = filter(it, cid => cid.toString().startsWith(q.prefix || ''));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n}","import { CID } from 'multiformats';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class MemoryBlockStore extends BaseBlockstore {\n    constructor() {\n        super();\n        this.store = new Map();\n    }\n    async *blocks() {\n        for (const [cidStr, bytes] of this.store.entries()) {\n            yield { cid: CID.parse(cidStr), bytes };\n        }\n    }\n    put(cid, bytes) {\n        this.store.set(cid.toString(), bytes);\n        return Promise.resolve();\n    }\n    get(cid) {\n        const bytes = this.store.get(cid.toString());\n        if (!bytes) {\n            throw new Error(`block with cid ${cid.toString()} no found`);\n        }\n        return Promise.resolve(bytes);\n    }\n    has(cid) {\n        return Promise.resolve(this.store.has(cid.toString()));\n    }\n    close() {\n        this.store.clear();\n        return Promise.resolve();\n    }\n}\n","import { sha256 } from 'multiformats/hashes/sha2';\nexport const unixfsImporterOptionsDefault = {\n    cidVersion: 1,\n    chunker: 'fixed',\n    maxChunkSize: 262144,\n    hasher: sha256,\n    rawLeaves: true,\n    wrapWithDirectory: true,\n    maxChildrenPerNode: 174\n};\n","import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction throttledQueue(maxRequestsPerInterval, interval, evenlySpaced) {\n    if (evenlySpaced === void 0) { evenlySpaced = false; }\n    /**\n     * If all requests should be evenly spaced, adjust to suit.\n     */\n    if (evenlySpaced) {\n        interval = interval / maxRequestsPerInterval;\n        maxRequestsPerInterval = 1;\n    }\n    var queue = [];\n    var lastIntervalStart = 0;\n    var numRequestsPerInterval = 0;\n    var timeout;\n    /**\n     * Gets called at a set interval to remove items from the queue.\n     * This is a self-adjusting timer, since the browser's setTimeout is highly inaccurate.\n     */\n    var dequeue = function () {\n        var intervalEnd = lastIntervalStart + interval;\n        var now = Date.now();\n        /**\n         * Adjust the timer if it was called too early.\n         */\n        if (now < intervalEnd) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            timeout !== undefined && clearTimeout(timeout);\n            timeout = setTimeout(dequeue, intervalEnd - now);\n            return;\n        }\n        lastIntervalStart = now;\n        numRequestsPerInterval = 0;\n        for (var _i = 0, _a = queue.splice(0, maxRequestsPerInterval); _i < _a.length; _i++) {\n            var callback = _a[_i];\n            numRequestsPerInterval++;\n            void callback();\n        }\n        if (queue.length) {\n            timeout = setTimeout(dequeue, interval);\n        }\n        else {\n            timeout = undefined;\n        }\n    };\n    return function (fn) { return new Promise(function (resolve, reject) {\n        var callback = function () { return Promise.resolve().then(fn).then(resolve).catch(reject); };\n        var now = Date.now();\n        if (timeout === undefined && (now - lastIntervalStart) > interval) {\n            lastIntervalStart = now;\n            numRequestsPerInterval = 0;\n        }\n        if (numRequestsPerInterval++ < maxRequestsPerInterval) {\n            void callback();\n        }\n        else {\n            queue.push(callback);\n            if (timeout === undefined) {\n                timeout = setTimeout(dequeue, lastIntervalStart + interval - now);\n            }\n        }\n    }); };\n}\nmodule.exports = throttledQueue;\nexports.default = throttledQueue;\n//# sourceMappingURL=throttledQueue.js.map","import { MemoryBlockStore } from 'ipfs-car/blockstore/memory'\n\nexport const fetch = globalThis.fetch\nexport const FormData = globalThis.FormData\nexport const Headers = globalThis.Headers\nexport const Request = globalThis.Request\nexport const Response = globalThis.Response\nexport const Blob = globalThis.Blob\nexport const File = globalThis.File\nexport const ReadableStream = globalThis.ReadableStream\nexport const Blockstore = MemoryBlockStore\n","export const GATEWAY = new URL('https://nftstorage.link/')\n\n/**\n * @typedef {string|URL} GatewayURL Base URL of an IPFS Gateway e.g. https://dweb.link/ or https://ipfs.io/\n * @typedef {{ gateway?: GatewayURL }} GatewayURLOptions\n */\n\n/**\n * Convert an IPFS URL (starting ipfs://) to a gateway URL (starting https://)\n * that can be used in a webpage. If the passed URL is not an IPFS URL it is\n * returned as a new URL object with no further changes.\n *\n * @param {string|URL} url An IPFS URL e.g. ipfs://bafy.../path\n * @param {GatewayURLOptions} [options] Options that allow customization of the gateway used.\n * @returns {URL} An IPFS gateway URL e.g. https://nftstorage.link/ipfs/bafy.../path\n */\nexport const toGatewayURL = (url, options = {}) => {\n  const gateway = options.gateway || GATEWAY\n  url = new URL(String(url))\n  return url.protocol === 'ipfs:'\n    ? new URL(`/ipfs/${url.href.slice('ipfs://'.length)}`, gateway)\n    : url\n}\n","/**\n * An implementation of the CAR reader interface that is backed by a blockstore.\n *\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('@ipld/car/api').CarReader} CarReader\n * @implements {CarReader}\n */\nexport class BlockstoreCarReader {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {import('ipfs-car/blockstore').Blockstore} blockstore\n   */\n  constructor(version, roots, blockstore) {\n    /**\n     * @private\n     */\n    this._version = version\n    /**\n     * @private\n     */\n    this._roots = roots\n    /**\n     * @private\n     */\n    this._blockstore = blockstore\n  }\n\n  get version() {\n    return this._version\n  }\n\n  get blockstore() {\n    return this._blockstore\n  }\n\n  async getRoots() {\n    return this._roots\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  has(cid) {\n    return this._blockstore.has(cid)\n  }\n\n  /**\n   * @param {CID} cid\n   */\n  async get(cid) {\n    const bytes = await this._blockstore.get(cid)\n    return { cid, bytes }\n  }\n\n  blocks() {\n    return this._blockstore.blocks()\n  }\n\n  async *cids() {\n    for await (const b of this.blocks()) {\n      yield b.cid\n    }\n  }\n}\n","import { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport * as Block from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as dagCbor from '@ipld/dag-cbor'\nimport { Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL, GATEWAY } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\n\n/**\n * @typedef {import('./gateway.js').GatewayURLOptions} EmbedOptions\n * @typedef {import('./lib/interface.js').TokenInput} TokenInput\n * @typedef {import('ipfs-car/blockstore').Blockstore} Blockstore\n */\n\n/**\n * @template T\n * @typedef {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} EncodedBlobUrl\n */\n\n/**\n * @template G\n * @typedef {import('./lib/interface.js').Encoded<G, [[Blob, Blob]]>} EncodedBlobBlob\n */\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @template {TokenInput} T\n * @implements {TokenType<T>}\n */\nexport class Token {\n  /**\n   * @param {import('./lib/interface.js').CIDString} ipnft\n   * @param {import('./lib/interface.js').EncodedURL} url\n   * @param {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>} data\n   */\n  constructor(ipnft, url, data) {\n    /** @readonly */\n    this.ipnft = ipnft\n    /** @readonly */\n    this.url = url\n    /** @readonly */\n    this.data = data\n\n    Object.defineProperties(this, {\n      ipnft: { enumerable: true, writable: false },\n      url: { enumerable: true, writable: false },\n      data: { enumerable: false, writable: false },\n    })\n  }\n  /**\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  embed() {\n    return Token.embed(this)\n  }\n\n  /**\n   * @template {TokenInput} T\n   * @param {{data: import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}} token\n   * @returns {import('./lib/interface.js').Encoded<T, [[Blob, URL]]>}\n   */\n  static embed({ data }) {\n    return embed(data, { gateway: GATEWAY })\n  }\n\n  /**\n   * Takes token input, encodes it as a DAG, wraps it in a CAR and creates a new\n   * Token instance from it. Where values are discovered `Blob` (or `File`)\n   * objects in the given input, they are replaced with IPFS URLs (an `ipfs://`\n   * prefixed CID with an optional path).\n   *\n   * @example\n   * ```js\n   * const cat = new File(['...'], 'cat.png')\n   * const kitty = new File(['...'], 'kitty.png')\n   * const { token, car } = await Token.encode({\n   *   name: 'hello'\n   *   image: cat\n   *   properties: {\n   *     extra: {\n   *       image: kitty\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * @template {TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: import('./lib/interface.js').CarReader }>}\n   */\n  static async encode(input) {\n    const blockstore = new Blockstore()\n    const [blobs, meta] = mapTokenInputBlobs(input)\n    /** @type {EncodedBlobUrl<T>} */\n    const data = JSON.parse(JSON.stringify(meta))\n    /** @type {import('./lib/interface.js').Encoded<T, [[Blob, CID]]>} */\n    const dag = JSON.parse(JSON.stringify(meta))\n\n    for (const [dotPath, blob] of blobs.entries()) {\n      /** @type {string|undefined} */\n      // @ts-ignore blob may be a File!\n      const name = blob.name || 'blob'\n      /** @type {import('./platform.js').ReadableStream} */\n      const content = blob.stream()\n      const { root: cid } = await pack({\n        input: [{ path: name, content }],\n        blockstore,\n        wrapWithDirectory: true,\n      })\n\n      const href = new URL(`ipfs://${cid}/${name}`)\n      const path = dotPath.split('.')\n      setIn(data, path, href)\n      setIn(dag, path, cid)\n    }\n\n    const { root: metadataJsonCid } = await pack({\n      input: [{ path: 'metadata.json', content: JSON.stringify(data) }],\n      blockstore,\n      wrapWithDirectory: false,\n    })\n\n    const block = await Block.encode({\n      value: {\n        ...dag,\n        'metadata.json': metadataJsonCid,\n        type: 'nft',\n      },\n      codec: dagCbor,\n      hasher: sha256,\n    })\n    await blockstore.put(block.cid, block.bytes)\n\n    return {\n      cid: block.cid,\n      token: new Token(\n        block.cid.toString(),\n        `ipfs://${block.cid}/metadata.json`,\n        data\n      ),\n      car: new BlockstoreCarReader(1, [block.cid], blockstore),\n    }\n  }\n}\n\n/**\n * @template T\n * @param {EncodedBlobUrl<T>} input\n * @param {EmbedOptions} options\n * @returns {EncodedBlobUrl<T>}\n */\nexport const embed = (input, options) =>\n  mapWith(input, isURL, embedURL, options)\n\n/**\n * @template {TokenInput} T\n * @param {import('./lib/interface.js').EncodedToken<T>} value\n * @param {Set<string>} paths - Paths were to expect EncodedURLs\n * @returns {Token<T>}\n */\nexport const decode = ({ ipnft, url, data }, paths) =>\n  new Token(ipnft, url, mapWith(data, isEncodedURL, decodeURL, paths))\n\n/**\n * @param {any} value\n * @returns {value is URL}\n */\nconst isURL = (value) => value instanceof URL\n\n/**\n * @template State\n * @param {State} state\n * @param {import('./lib/interface.js').EncodedURL} url\n * @returns {[State, URL]}\n */\nconst decodeURL = (state, url) => [state, new URL(url)]\n\n/**\n * @param {EmbedOptions} context\n * @param {URL} url\n * @returns {[EmbedOptions, URL]}\n */\nconst embedURL = (context, url) => [context, toGatewayURL(url, context)]\n\n/**\n * @param {any} value\n * @returns {value is object}\n */\nconst isObject = (value) => typeof value === 'object' && value != null\n\n/**\n * @param {any} value\n * @param {Set<string>} assetPaths\n * @param {PropertyKey[]} path\n * @returns {value is import('./lib/interface.js').EncodedURL}\n */\nconst isEncodedURL = (value, assetPaths, path) =>\n  typeof value === 'string' && assetPaths.has(path.join('.'))\n\n/**\n * Takes token input and encodes it into\n * [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n * object where form field values are discovered `Blob` (or `File`) objects in\n * the given token and field keys are `.` joined paths where they were discoverd\n * in the token. Additionally encoded `FormData` will also have a field\n * named `meta` containing JSON serialized token with blobs and file values\n * `null` set to null (this allows backend to injest all of the files from\n * `multipart/form-data` request and update provided \"meta\" data with\n * corresponding file ipfs:// URLs)\n *\n * @example\n * ```js\n * const cat = new File([], 'cat.png')\n * const kitty = new File([], 'kitty.png')\n * const form = encode({\n *   name: 'hello'\n *   image: cat\n *   properties: {\n *     extra: {\n *       image: kitty\n *     }\n *   }\n * })\n * [...form.entries()] //>\n * // [\n * //   ['image', cat],\n * //   ['properties.extra.image', kitty],\n * //   ['meta', '{\"name\":\"hello\",image:null,\"properties\":{\"extra\":{\"kitty\": null}}}']\n * // ]\n * ```\n *\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n * @returns {FormData}\n */\nexport const encode = (input) => {\n  const [map, meta] = mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n  const form = new FormData()\n  for (const [k, v] of map.entries()) {\n    form.set(k, v)\n  }\n  form.set('meta', JSON.stringify(meta))\n  return form\n}\n\n/**\n * @param {Map<string, Blob>} data\n * @param {Blob} blob\n * @param {PropertyKey[]} path\n * @returns {[Map<string, Blob>, void]}\n */\nconst encodeBlob = (data, blob, path) => {\n  data.set(path.join('.'), blob)\n  return [data, undefined]\n}\n\n/**\n * @param {any} value\n * @returns {value is Blob}\n */\nconst isBlob = (value) => value instanceof Blob\n\n/**\n * @template {TokenInput} T\n * @param {EncodedBlobBlob<T>} input\n */\nconst mapTokenInputBlobs = (input) => {\n  return mapValueWith(input, isBlob, encodeBlob, new Map(), [])\n}\n\n/**\n * Substitues values in the given `input` that match `p(value) == true` with\n * `f(value, context, path)` where `context` is whatever you pass (usually\n * a mutable state) and `path` is a array of keys / indexes where the value\n * was encountered.\n *\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * likey you'll start with `[]`.\n * @returns {import('./lib/interface.js').Encoded<T, [[I, O]]>}\n */\nexport const mapWith = (input, p, f, state) => {\n  const [, output] = mapValueWith(input, p, f, state, [])\n  return output\n}\n\n/**\n * @template T, I, X, O, State\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input - Arbitrary input.\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p - Predicate function to determine\n * which values to swap.\n * @param {(state:State, input:X, path:PropertyKey[]) => [State, O]} f - Function\n * that swaps matching values.\n * @param {State} state - Some additional context you need in the process.\n * @param {PropertyKey[]} path - Path where the value was encountered. Most\n * likey you'll start with `[]`.\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapValueWith = (input, p, f, state, path) =>\n  p(input, state, path)\n    ? f(state, input, path)\n    : Array.isArray(input)\n    ? mapArrayWith(input, p, f, state, path)\n    : isObject(input)\n    ? mapObjectWith(input, p, f, state, path)\n    : [state, /** @type {any} */ (input)]\n\n/**\n * Just like `mapWith` except\n *\n * @template State, T, I, X, O\n * @param {import('./lib/interface.js').Encoded<T, [[I, X]]>} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapObjectWith = (input, p, f, init, path) => {\n  let state = init\n  const output =\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ ({})\n  for (const [key, value] of Object.entries(input)) {\n    const [next, out] = mapValueWith(value, p, f, state, [...path, key])\n    // @ts-ignore\n    output[key] = out\n    state = next\n  }\n  return [state, output]\n}\n\n/**\n * Just like `mapWith` except for Arrays.\n *\n * @template I, X, O, State\n * @template {any[]} T\n * @param {T} input\n * @param {(input:any, state:State, path:PropertyKey[]) => input is X} p\n * @param {(state: State, input:X, path:PropertyKey[]) => [State, O]} f\n * @param {State} init\n * @param {PropertyKey[]} path\n * @returns {[State, import('./lib/interface.js').Encoded<T, [[I, O]]>]}\n */\nconst mapArrayWith = (input, p, f, init, path) => {\n  const output = /** @type {unknown[]} */ ([])\n\n  let state = init\n  for (const [index, element] of input.entries()) {\n    const [next, out] = mapValueWith(element, p, f, state, [...path, index])\n    output[index] = out\n    state = next\n  }\n\n  return [\n    state,\n    /** @type {import('./lib/interface.js').Encoded<T, [[I, O]]>} */ (output),\n  ]\n}\n\n/**\n * Sets a given `value` at the given `path` on a passed `object`.\n *\n * @example\n * ```js\n * const obj = { a: { b: { c: 1 }}}\n * setIn(obj, ['a', 'b', 'c'], 5)\n * obj.a.b.c //> 5\n * ```\n *\n * @template V\n * @param {any} object\n * @param {string[]} path\n * @param {V} value\n */\nconst setIn = (object, path, value) => {\n  const n = path.length - 1\n  let target = object\n  for (let [index, key] of path.entries()) {\n    if (index === n) {\n      target[key] = value\n    } else {\n      target = target[key]\n    }\n  }\n}\n","/**\n * A client library for the https://nft.storage/ service. It provides a convenient\n * interface for working with the [Raw HTTP API](https://nft.storage/#api-docs)\n * from a web browser or [Node.js](https://nodejs.org/) and comes bundled with\n * TS for out-of-the box type inference and better IntelliSense.\n *\n * @example\n * ```js\n * import { NFTStorage, File, Blob } from \"nft.storage\"\n * const client = new NFTStorage({ token: API_TOKEN })\n *\n * const cid = await client.storeBlob(new Blob(['hello world']))\n * ```\n * @module\n */\n\nimport { transform } from 'streaming-iterables'\nimport pRetry, { AbortError } from 'p-retry'\nimport { TreewalkCarSplitter } from 'carbites/treewalk'\nimport { pack } from 'ipfs-car/pack'\nimport { CID } from 'multiformats/cid'\nimport throttledQueue from 'throttled-queue'\nimport * as Token from './token.js'\nimport { fetch, File, Blob, FormData, Blockstore } from './platform.js'\nimport { toGatewayURL } from './gateway.js'\nimport { BlockstoreCarReader } from './bs-car-reader.js'\nimport pipe from 'it-pipe'\n\nconst MAX_STORE_RETRIES = 5\nconst MAX_CONCURRENT_UPLOADS = 3\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 50 // chunk to ~50MB CARs\nconst RATE_LIMIT_REQUESTS = 30\nconst RATE_LIMIT_PERIOD = 10 * 1000\n\n/**\n * @typedef {import('./lib/interface.js').Service} Service\n * @typedef {import('./lib/interface.js').CIDString} CIDString\n * @typedef {import('./lib/interface.js').Deal} Deal\n * @typedef {import('./lib/interface.js').FileObject} FileObject\n * @typedef {import('./lib/interface.js').FilesSource} FilesSource\n * @typedef {import('./lib/interface.js').Pin} Pin\n * @typedef {import('./lib/interface.js').CarReader} CarReader\n * @typedef {import('ipfs-car/blockstore').Blockstore} BlockstoreI\n * @typedef {import('./lib/interface.js').RateLimiter} RateLimiter\n * @typedef {import('./lib/interface.js').RequestOptions} RequestOptions\n */\n\n/**\n * @returns {RateLimiter}\n */\nexport function createRateLimiter() {\n  const throttle = throttledQueue(RATE_LIMIT_REQUESTS, RATE_LIMIT_PERIOD)\n  return () => throttle(() => {})\n}\n\n/**\n * Rate limiter used by static API if no rate limiter is passed. Note that each\n * instance of the NFTStorage class gets it's own limiter if none is passed.\n * This is because rate limits are enforced per API token.\n */\nconst globalRateLimiter = createRateLimiter()\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @typedef {import('./lib/interface.js').Token<T>} TokenType\n */\n\n/**\n * @implements {Service}\n */\nclass NFTStorage {\n  /**\n   * Constructs a client bound to the given `options.token` and\n   * `options.endpoint`.\n   *\n   * @example\n   * ```js\n   * import { NFTStorage, File, Blob } from \"nft.storage\"\n   * const client = new NFTStorage({ token: API_TOKEN })\n   *\n   * const cid = await client.storeBlob(new Blob(['hello world']))\n   * ```\n   * Optionally you could pass an alternative API endpoint (e.g. for testing)\n   * @example\n   * ```js\n   * import { NFTStorage } from \"nft.storage\"\n   * const client = new NFTStorage({\n   *   token: API_TOKEN\n   *   endpoint: new URL('http://localhost:8080/')\n   * })\n   * ```\n   *\n   * @param {{token: string, endpoint?: URL, rateLimiter?: RateLimiter, did?: string}} options\n   */\n  constructor({\n    token,\n    did,\n    endpoint = new URL('https://api.nft.storage'),\n    rateLimiter,\n  }) {\n    /**\n     * Authorization token.\n     *\n     * @readonly\n     */\n    this.token = token\n    /**\n     * Service API endpoint `URL`.\n     * @readonly\n     */\n    this.endpoint = endpoint\n    /**\n     * @readonly\n     */\n    this.rateLimiter = rateLimiter || createRateLimiter()\n\n    /**\n     * @readonly\n     */\n    this.did = did\n  }\n\n  /**\n   * @hidden\n   * @param {object} options\n   * @param {string} options.token\n   * @param {string} [options.did]\n   */\n  static auth({ token, did }) {\n    if (!token) throw new Error('missing token')\n    return {\n      Authorization: `Bearer ${token}`,\n      'X-Client': 'nft.storage/js',\n      ...(did ? { 'x-agent-did': did } : {}),\n    }\n  }\n\n  /**\n   * Stores a single file and returns its CID.\n   *\n   * @param {Service} service\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeBlob(service, blob, options) {\n    const blockstore = new Blockstore()\n    let cidString\n\n    try {\n      const { cid, car } = await NFTStorage.encodeBlob(blob, { blockstore })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores a CAR file and returns its root CID.\n   *\n   * @param {Service} service\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeCar(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    car,\n    { onStoredChunk, maxRetries, decoders, signal } = {}\n  ) {\n    const url = new URL('upload/', endpoint)\n    const headers = NFTStorage.auth(token)\n    const targetSize = MAX_CHUNK_SIZE\n    const splitter =\n      car instanceof Blob\n        ? await TreewalkCarSplitter.fromBlob(car, targetSize, { decoders })\n        : new TreewalkCarSplitter(car, targetSize, { decoders })\n\n    const upload = transform(\n      MAX_CONCURRENT_UPLOADS,\n      async function (/** @type {AsyncIterable<Uint8Array>} */ car) {\n        const carParts = []\n        for await (const part of car) {\n          carParts.push(part)\n        }\n        const carFile = new Blob(carParts, { type: 'application/car' })\n        const cid = await pRetry(\n          async () => {\n            await rateLimiter()\n            /** @type {Response} */\n            let response\n            try {\n              response = await fetch(url.toString(), {\n                method: 'POST',\n                headers,\n                body: carFile,\n                signal,\n              })\n            } catch (/** @type {any} */ err) {\n              // TODO: remove me and test when client accepts custom fetch impl\n              /* c8 ignore next 1 */\n              throw signal && signal.aborted ? new AbortError(err) : err\n            }\n            /* c8 ignore next 3 */\n            if (response.status === 429) {\n              throw new Error('rate limited')\n            }\n            const result = await response.json()\n            if (!result.ok) {\n              // do not retry if unauthorized - will not succeed\n              if (response.status === 401) {\n                throw new AbortError(result.error.message)\n              }\n              throw new Error(result.error.message)\n            }\n            return result.value.cid\n          },\n          {\n            retries: maxRetries == null ? MAX_STORE_RETRIES : maxRetries,\n          }\n        )\n        onStoredChunk && onStoredChunk(carFile.size)\n        return cid\n      }\n    )\n\n    let root\n    for await (const cid of upload(splitter.cars())) {\n      root = cid\n    }\n\n    return /** @type {CIDString} */ (root)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID. Provided files **MUST**\n   * be within the same directory, otherwise error is raised e.g. `foo/bar.png`,\n   * `foo/bla/baz.json` is ok but `foo/bar.png`, `bla/baz.json` is not.\n   *\n   * @param {Service} service\n   * @param {FilesSource} filesSource\n   * @param {RequestOptions} [options]\n   * @returns {Promise<CIDString>}\n   */\n  static async storeDirectory(service, filesSource, options) {\n    const blockstore = new Blockstore()\n    let cidString\n    try {\n      const { cid, car } = await NFTStorage.encodeDirectory(filesSource, {\n        blockstore,\n      })\n      await NFTStorage.storeCar(service, car, options)\n      cidString = cid.toString()\n    } finally {\n      await blockstore.close()\n    }\n\n    return cidString\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155. The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {Service} service\n   * @param {T} metadata\n   * @param {RequestOptions} [options]\n   * @returns {Promise<TokenType<T>>}\n   */\n  static async store(service, metadata, options) {\n    const { token, car } = await NFTStorage.encodeNFT(metadata)\n    await NFTStorage.storeCar(service, car, options)\n    return token\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').StatusResult>}\n   */\n  static async status(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'GET',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        size: result.value.size,\n        pin: decodePin(result.value.pin),\n        created: new Date(result.value.created),\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by NFT.Storage.\n   *\n   * @param {import('./lib/interface.js').PublicService} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<import('./lib/interface.js').CheckResult>}\n   */\n  static async check(\n    { endpoint, rateLimiter = globalRateLimiter },\n    cid,\n    options\n  ) {\n    const url = new URL(`check/${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n\n    if (result.ok) {\n      return {\n        cid: result.value.cid,\n        deals: decodeDeals(result.value.deals),\n        pin: result.value.pin,\n      }\n    } else {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Removes stored content by its CID from this account. Please note that\n   * even if content is removed from the service other nodes that have\n   * replicated it might still continue providing it.\n   *\n   * @param {Service} service\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   * @returns {Promise<void>}\n   */\n  static async delete(\n    { endpoint, rateLimiter = globalRateLimiter, ...token },\n    cid,\n    options\n  ) {\n    const url = new URL(`${cid}/`, endpoint)\n    await rateLimiter()\n    const response = await fetch(url.toString(), {\n      method: 'DELETE',\n      headers: NFTStorage.auth(token),\n      signal: options && options.signal,\n    })\n    /* c8 ignore next 3 */\n    if (response.status === 429) {\n      throw new Error('rate limited')\n    }\n    const result = await response.json()\n    if (!result.ok) {\n      throw new Error(result.error.message)\n    }\n  }\n\n  /**\n   * Encodes the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in ERC-1155 to a\n   * CAR file. The `token.image` must be either a `File` or a `Blob` instance,\n   * which will be stored and the corresponding content address URL will be\n   * saved in the metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const { token, car } = await NFTStorage.encodeNFT({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', token.url)\n   * console.log('metadata.json contents:\\n', token.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', token.embed())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} input\n   * @returns {Promise<{ cid: CID, token: TokenType<T>, car: CarReader }>}\n   */\n  static async encodeNFT(input) {\n    validateERC1155(input)\n    return Token.Token.encode(input)\n  }\n\n  /**\n   * Encodes a single file to a CAR file and also returns its root CID.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const { cid, car } = await NFTStorage.encodeBlob(content)\n   *\n   * // Root CID of the file\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeBlob(blob, { blockstore } = {}) {\n    if (blob.size === 0) {\n      throw new Error('Content size is 0, make sure to provide some content')\n    }\n    return packCar([toImportCandidate('blob', blob)], {\n      blockstore,\n      wrapWithDirectory: false,\n    })\n  }\n\n  /**\n   * Encodes a directory of files to a CAR file and also returns the root CID.\n   * Provided files **MUST** be within the same directory, otherwise error is\n   * raised e.g. `foo/bar.png`, `foo/bla/baz.json` is ok but `foo/bar.png`,\n   * `bla/baz.json` is not.\n   *\n   * @example\n   * ```js\n   * const { cid, car } = await NFTStorage.encodeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   *\n   * // Root CID of the directory\n   * console.log(cid.toString())\n   *\n   * // Now store the CAR file on NFT.Storage\n   * await client.storeCar(car)\n   * ```\n   *\n   * @param {FilesSource} files\n   * @param {object} [options]\n   * @param {BlockstoreI} [options.blockstore]\n   * @returns {Promise<{ cid: CID, car: CarReader }>}\n   */\n  static async encodeDirectory(files, { blockstore } = {}) {\n    let size = 0\n    const input = pipe(files, async function* (files) {\n      for await (const file of files) {\n        yield toImportCandidate(file.name, file)\n        size += file.size\n      }\n    })\n    const packed = await packCar(input, {\n      blockstore,\n      wrapWithDirectory: true,\n    })\n    if (size === 0) {\n      throw new Error(\n        'Total size of files should exceed 0, make sure to provide some content'\n      )\n    }\n    return packed\n  }\n\n  // Just a sugar so you don't have to pass around endpoint and token around.\n\n  /**\n   * Stores a single file and returns the corresponding Content Identifier (CID).\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File). Note\n   * that no file name or file metadata is retained.\n   *\n   * @example\n   * ```js\n   * const content = new Blob(['hello world'])\n   * const cid = await client.storeBlob(content)\n   * cid //> 'zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9'\n   * ```\n   *\n   * @param {Blob} blob\n   * @param {RequestOptions} [options]\n   */\n  storeBlob(blob, options) {\n    return NFTStorage.storeBlob(this, blob, options)\n  }\n\n  /**\n   * Stores files encoded as a single [Content Addressed Archive\n   * (CAR)](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md).\n   *\n   * Takes a [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob/Blob)\n   * or a [File](https://developer.mozilla.org/en-US/docs/Web/API/File).\n   *\n   * Returns the corresponding Content Identifier (CID).\n   *\n   * See the [`ipfs-car` docs](https://www.npmjs.com/package/ipfs-car) for more\n   * details on packing a CAR file.\n   *\n   * @example\n   * ```js\n   * import { pack } from 'ipfs-car/pack'\n   * import { CarReader } from '@ipld/car'\n   * const { out, root } = await pack({\n   *  input: fs.createReadStream('pinpie.pdf')\n   * })\n   * const expectedCid = root.toString()\n   * const carReader = await CarReader.fromIterable(out)\n   * const cid = await storage.storeCar(carReader)\n   * console.assert(cid === expectedCid)\n   * ```\n   *\n   * @example\n   * ```\n   * import { packToBlob } from 'ipfs-car/pack/blob'\n   * const data = 'Hello world'\n   * const { root, car } = await packToBlob({ input: [new TextEncoder().encode(data)] })\n   * const expectedCid = root.toString()\n   * const cid = await client.storeCar(car)\n   * console.assert(cid === expectedCid)\n   * ```\n   * @param {Blob|CarReader} car\n   * @param {import('./lib/interface.js').CarStorerOptions} [options]\n   */\n  storeCar(car, options) {\n    return NFTStorage.storeCar(this, car, options)\n  }\n\n  /**\n   * Stores a directory of files and returns a CID for the directory.\n   *\n   * @example\n   * ```js\n   * const cid = await client.storeDirectory([\n   *   new File(['hello world'], 'hello.txt'),\n   *   new File([JSON.stringify({'from': 'incognito'}, null, 2)], 'metadata.json')\n   * ])\n   * cid //>\n   * ```\n   *\n   * Argument can be a [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * instance as well, in which case directory structure will be retained.\n   *\n   * @param {FilesSource} files\n   * @param {RequestOptions} [options]\n   */\n  storeDirectory(files, options) {\n    return NFTStorage.storeDirectory(this, files, options)\n  }\n\n  /**\n   * Returns current status of the stored NFT by its CID. Note the NFT must\n   * have previously been stored by this account.\n   *\n   * @example\n   * ```js\n   * const status = await client.status('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  status(cid, options) {\n    return NFTStorage.status(this, cid, options)\n  }\n\n  /**\n   * Removes stored content by its CID from the service.\n   *\n   * > Please note that even if content is removed from the service other nodes\n   * that have replicated it might still continue providing it.\n   *\n   * @example\n   * ```js\n   * await client.delete('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  delete(cid, options) {\n    return NFTStorage.delete(this, cid, options)\n  }\n\n  /**\n   * Check if a CID of an NFT is being stored by nft.storage. Throws if the NFT\n   * was not found.\n   *\n   * @example\n   * ```js\n   * const status = await client.check('zdj7Wn9FQAURCP6MbwcWuzi7u65kAsXCdjNTkhbJcoaXBusq9')\n   * ```\n   *\n   * @param {string} cid\n   * @param {RequestOptions} [options]\n   */\n  check(cid, options) {\n    return NFTStorage.check(this, cid, options)\n  }\n\n  /**\n   * Stores the given token and all resources it references (in the form of a\n   * File or a Blob) along with a metadata JSON as specificed in\n   * [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155#metadata). The\n   * `token.image` must be either a `File` or a `Blob` instance, which will be\n   * stored and the corresponding content address URL will be saved in the\n   * metadata JSON file under `image` field.\n   *\n   * If `token.properties` contains properties with `File` or `Blob` values,\n   * those also get stored and their URLs will be saved in the metadata JSON\n   * file in their place.\n   *\n   * Note: URLs for `File` objects will retain file names e.g. in case of\n   * `new File([bytes], 'cat.png', { type: 'image/png' })` will be transformed\n   * into a URL that looks like `ipfs://bafy...hash/image/cat.png`. For `Blob`\n   * objects, the URL will not have a file name name or mime type, instead it\n   * will be transformed into a URL that looks like\n   * `ipfs://bafy...hash/image/blob`.\n   *\n   * @example\n   * ```js\n   * const metadata = await client.store({\n   *   name: 'nft.storage store test',\n   *   description: 'Test ERC-1155 compatible metadata.',\n   *   image: new File(['<DATA>'], 'pinpie.jpg', { type: 'image/jpg' }),\n   *   properties: {\n   *     custom: 'Custom data can appear here, files are auto uploaded.',\n   *     file: new File(['<DATA>'], 'README.md', { type: 'text/plain' }),\n   *   }\n   * })\n   *\n   * console.log('IPFS URL for the metadata:', metadata.url)\n   * console.log('metadata.json contents:\\n', metadata.data)\n   * console.log('metadata.json with IPFS gateway URLs:\\n', metadata.embed())\n   * ```\n   *\n   * @template {import('./lib/interface.js').TokenInput} T\n   * @param {T} token\n   * @param {RequestOptions} [options]\n   */\n  store(token, options) {\n    return NFTStorage.store(this, token, options)\n  }\n}\n\n/**\n * Cast an iterable to an asyncIterable\n * @template T\n * @param {Iterable<T>} iterable\n * @returns {AsyncIterable<T>}\n */\nexport function toAsyncIterable(iterable) {\n  return (async function* () {\n    for (const item of iterable) {\n      yield item\n    }\n  })()\n}\n\n/**\n * @template {import('./lib/interface.js').TokenInput} T\n * @param {T} metadata\n */\nconst validateERC1155 = ({ name, description, image, decimals }) => {\n  // Just validate that expected fields are present\n  if (typeof name !== 'string') {\n    throw new TypeError(\n      'string property `name` identifying the asset is required'\n    )\n  }\n  if (typeof description !== 'string') {\n    throw new TypeError(\n      'string property `description` describing asset is required'\n    )\n  }\n  if (!(image instanceof Blob)) {\n    throw new TypeError('property `image` must be a Blob or File object')\n  } else if (!image.type.startsWith('image/')) {\n    console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.\n\nFor better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \\`properties: { video: file }\\` and using 'image' field for storing a preview image for it instead.\n\nFor more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`)\n  }\n\n  if (typeof decimals !== 'undefined' && typeof decimals !== 'number') {\n    throw new TypeError('property `decimals` must be an integer value')\n  }\n}\n\n/**\n * @param {import('ipfs-car/pack').ImportCandidateStream|Array<{ path: string, content: import('./platform.js').ReadableStream }>} input\n * @param {object} [options]\n * @param {BlockstoreI} [options.blockstore]\n * @param {boolean} [options.wrapWithDirectory]\n */\nconst packCar = async (input, { blockstore, wrapWithDirectory } = {}) => {\n  /* c8 ignore next 1 */\n  blockstore = blockstore || new Blockstore()\n  const { root: cid } = await pack({ input, blockstore, wrapWithDirectory })\n  const car = new BlockstoreCarReader(1, [cid], blockstore)\n  return { cid, car }\n}\n\n/**\n * @param {Deal[]} deals\n * @returns {Deal[]}\n */\nconst decodeDeals = (deals) =>\n  deals.map((deal) => {\n    const { dealActivation, dealExpiration, lastChanged } = {\n      dealExpiration: null,\n      dealActivation: null,\n      ...deal,\n    }\n\n    return {\n      ...deal,\n      lastChanged: new Date(lastChanged),\n      ...(dealActivation && { dealActivation: new Date(dealActivation) }),\n      ...(dealExpiration && { dealExpiration: new Date(dealExpiration) }),\n    }\n  })\n\n/**\n * @param {Pin} pin\n * @returns {Pin}\n */\nconst decodePin = (pin) => ({ ...pin, created: new Date(pin.created) })\n\n/**\n * Convert the passed blob to an \"import candidate\" - an object suitable for\n * passing to the ipfs-unixfs-importer. Note: content is an accessor so that\n * the stream is created only when needed.\n *\n * @param {string} path\n * @param {Pick<Blob, 'stream'>|{ stream: () => AsyncIterable<Uint8Array> }} blob\n * @returns {import('ipfs-core-types/src/utils.js').ImportCandidate}\n */\nfunction toImportCandidate(path, blob) {\n  /** @type {AsyncIterable<Uint8Array>} */\n  let stream\n  return {\n    path,\n    get content() {\n      stream = stream || blob.stream()\n      return stream\n    },\n  }\n}\n\nexport { NFTStorage, File, Blob, FormData, toGatewayURL, Token }\n"],"mappings":"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MAAJG,CAAA,GAAU,KAC5BA,CAAA,IAAK;EAEP,OAAOA,CAAA,IAAK,MACVV,CAAA,CAAMO,CAAA,MAAgB,MAAJG,CAAA,GAAU,KAC5BA,CAAA,MAAO;EAGT,OADAV,CAAA,CAAMO,CAAA,IAAUG,CAAA,EACTC,CACT;AAAA;AACA,SAAS2mB,IAAItnB,CAAA;EAIX,OAHIA,CAAA,GAAI,KAAM,KACZA,CAAA,IAEK0G,IAAA,CAAK6gB,KAAA,EAAOC,KAAA,CAAMxnB,CAAA,IAAK,KAAK,EACrC;AAAA;AACA,SAASwnB,MAAMxnB,CAAA;EACb,IAAIO,CAAA,GAAI;EAaR,OAZIP,CAAA,IAAK+mB,QAAA,KACP/mB,CAAA,GAAI0G,IAAA,CAAK6gB,KAAA,CAAMvnB,CAAA,GAAI+mB,QAAA,GACnBxmB,CAAA,GAAI,KAEFP,CAAA,IAAK,UACPA,CAAA,MAAO,IACPO,CAAA,IAAK,KAEHP,CAAA,IAAK,QACPA,CAAA,MAAO,GACPO,CAAA,IAAK,IAEAA,CAAA,GAAIknB,OAAA,CAAQznB,CAAA,CACrB;AAAA;AACA,MAAMynB,OAAA,GAAU,CACd,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA;EClXIC,gBAAA,GAAmB,CACvB,QACA;EAEIC,gBAAA,GAAmB,CACvB,QACA,QACA;EAEIC,WAAA,GAAc,IAAInb,WAAA;AACxB,SAASob,eAAe7nB,CAAA,EAAGO,CAAA;EACzB,IAAIP,CAAA,KAAMO,CAAA,EACR,OAAO;EAET,MAAMG,CAAA,GAAOV,CAAA,CAAEymB,IAAA,GAAOmB,WAAA,CAAY7d,MAAA,CAAO/J,CAAA,CAAEymB,IAAA,IAAQ;IAC7C9lB,CAAA,GAAOJ,CAAA,CAAEkmB,IAAA,GAAOmB,WAAA,CAAY7d,MAAA,CAAOxJ,CAAA,CAAEkmB,IAAA,IAAQ;EACnD,IAAI1lB,CAAA,GAAIL,CAAA,CAAKY,MAAA;IACTN,CAAA,GAAIL,CAAA,CAAKW,MAAA;EACb,KAAK,IAAItB,CAAA,GAAI,GAAGO,CAAA,GAAMmG,IAAA,CAAKK,GAAA,CAAI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IAAG,GAAE,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,KAAI,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,IAAG,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,KAAI,IAAG,KAAI,KAAI,IAAG,KAAI,KAAI,GAAE,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,KAAI,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,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"},"metadata":{},"sourceType":"module"}